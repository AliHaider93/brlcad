diff --git a/src/libdm/CMakeLists.txt b/src/libdm/CMakeLists.txt
index fd43e9dbde..8c928223a3 100644
--- a/src/libdm/CMakeLists.txt
+++ b/src/libdm/CMakeLists.txt
@@ -113,6 +113,7 @@ add_subdirectory(plot)
 add_subdirectory(postscript)
 add_subdirectory(qtgl)
 add_subdirectory(swrast)
+add_subdirectory(tinygl)
 add_subdirectory(tk)
 add_subdirectory(txt)
 add_subdirectory(wgl)
diff --git a/src/libdm/dm-gl.h b/src/libdm/dm-gl.h
index 71f28b9292..91a10c2ae9 100644
--- a/src/libdm/dm-gl.h
+++ b/src/libdm/dm-gl.h
@@ -40,6 +40,8 @@
 
 #ifdef OSMESA
 #  include "OSMesa/gl.h"
+#elif defined(TGL_PREFIX)
+#  include "TGL/gl.h"
 #else
 #  ifdef HAVE_GL_GL_H
 #    include <GL/gl.h>
diff --git a/src/libdm/tinygl/CMakeLists.txt b/src/libdm/tinygl/CMakeLists.txt
new file mode 100644
index 0000000000..304035c0fe
--- /dev/null
+++ b/src/libdm/tinygl/CMakeLists.txt
@@ -0,0 +1,52 @@
+set(TINYGL_SRCS
+  dm-tinygl.cpp
+  fb-tinygl.cpp
+  tinyglwin.cpp
+  ../dm-gl.c
+  )
+
+if(BRLCAD_ENABLE_QT)
+
+  # Qt is used for the stand-alone FB window, but other than that should not be
+  # used by tinygl code.
+  find_package(Qt5 COMPONENTS Core Widgets)
+
+  include_directories(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_SOURCE_DIR}/..
+    ${BRLCAD_BINARY_DIR}/include
+    ${BRLCAD_SOURCE_DIR}/include
+    ${BU_INCLUDE_DIRS}
+    ${TINYGL_INCLUDE_DIR}
+    )
+
+  add_definitions(-DDM_PLUGIN)
+
+  # Use the Mesa mechanism for mangling names so we don't collide with any
+  # system OpenGL libs
+  add_definitions(-DTINYGL_PREFIX)
+
+  QT5_WRAP_CPP(tinygl_moc_srcs tinyglwin.h)
+  set(TINYGL_SRCS ${TINYGL_SRCS} ${tinygl_moc_srcs})
+
+  dm_plugin_library(dm-tinygl SHARED ${TINYGL_SRCS})
+  target_link_libraries(dm-tinygl libqtcad libdm libbu tinygl Qt5::Core Qt5::Widgets)
+  set_property(TARGET dm-tinygl APPEND PROPERTY COMPILE_DEFINITIONS BRLCADBUILD HAVE_CONFIG_H TGL_PREFIX)
+  VALIDATE_STYLE(dm-tinygl "${TINYGL_SRCS}")
+
+  PLUGIN_SETUP(dm-tinygl dm)
+endif(BRLCAD_ENABLE_QT)
+
+CMAKEFILES(
+  CMakeLists.txt
+  ${TINYGL_SRCS}
+  dm-tinygl.h
+  tinyglwin.h
+  )
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
diff --git a/src/libdm/tinygl/dm-tinygl.cpp b/src/libdm/tinygl/dm-tinygl.cpp
new file mode 100644
index 0000000000..5e3305fdbb
--- /dev/null
+++ b/src/libdm/tinygl/dm-tinygl.cpp
@@ -0,0 +1,658 @@
+/*                    D M - T I N Y G L . C P P
+ * BRL-CAD
+ *
+ * Copyright (c) 1988-2021 United States Government as represented by
+ * the U.S. Army Research Laboratory.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this file; see the file named COPYING for more
+ * information.
+ */
+/** @file libdm/dm-tinygl.c
+ *
+ * A Software Rasterizer based OpenGL Display Manager.
+ *
+ */
+
+#include "common.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+
+#include "TGL/gl.h"
+#include "zbuffer.h"
+
+#undef VMIN		/* is used in vmath.h, too */
+
+extern "C" {
+#include "vmath.h"
+#include "bu.h"
+#include "bn.h"
+#include "bv/defines.h"
+#include "dm.h"
+#include "../null/dm-Null.h"
+#include "../dm-gl.h"
+}
+#include "./dm-tinygl.h"
+
+#include "../include/private.h"
+
+#define ENABLE_POINT_SMOOTH 1
+
+#define VIEWFACTOR      (1.0/(*dmp->i->dm_vp))
+#define VIEWSIZE        (2.0*(*dmp->i->dm_vp))
+
+/* these are from /usr/include/gl.h could be device dependent */
+#define XMAXSCREEN	1279
+#define YMAXSCREEN	1023
+#define YSTEREO		491	/* subfield height, in scanlines */
+#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */
+
+/* Display Manager package interface */
+#define IRBOUND 4095.9	/* Max magnification in Rot matrix */
+#define PLOTBOUND 1000.0	/* Max magnification in Rot matrix */
+
+static struct dm *tinygl_open(void *ctx, void *interp, int argc, const char **argv);
+static int tinygl_close(struct dm *dmp);
+static int tinygl_drawString2D(struct dm *dmp, const char *str, fastf_t x, fastf_t y, int size, int use_aspect);
+static int tinygl_String2DBBox(struct dm *dmp, vect2d_t *bmin, vect2d_t *bmax, const char *str, fastf_t x, fastf_t y, int size, int use_aspect);
+static int tinygl_configureWin(struct dm *dmp, int force);
+static int tinygl_makeCurrent(struct dm *dmp);
+
+
+static int
+tinygl_makeCurrent(struct dm *dmp)
+{
+    struct tinygl_vars *pv = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+
+    if (!pv || !pv->ctx || !pv->v) {
+	bu_log("tinygl_configureWin: Couldn't make context current\n");
+	return BRLCAD_ERROR;
+    }
+
+    if (dmp->i->dm_debugLevel)
+	bu_log("tinygl_makeCurrent()\n");
+
+#if 0
+    if (!OSMesaMakeCurrent(pv->ctx, pv->os_b, GL_UNSIGNED_BYTE, pv->v->gv_width, pv->v->gv_height)) {
+	bu_log("OSMesaMakeCurrent failed!\n");
+	return BRLCAD_ERROR;
+    }
+#endif
+
+    return BRLCAD_OK;
+}
+
+static int
+tinygl_doevent(struct dm *UNUSED(dmp), void *UNUSED(vclientData), void *UNUSED(veventPtr))
+{
+    /* allow further processing of this event */
+    return BRLCAD_OK;
+}
+
+static int
+tinygl_configureWin(struct dm *dmp, int UNUSED(force))
+{
+    struct tinygl_vars *pv = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+
+    if (!pv || !pv->ctx || !pv->v) {
+	bu_log("tinygl_configureWin: Couldn't make context current\n");
+	return BRLCAD_ERROR;
+    }
+
+    int width = pv->v->gv_width;
+    int height = pv->v->gv_height;
+
+    if (!width || !height) {
+	bu_log("tinygl_configureWin: Zero sized window\n");
+	return BRLCAD_ERROR;
+    }
+
+    pv->os_b = bu_realloc(pv->os_b, 4096 * 4096 * sizeof(GLubyte)*4, "TinyGL rendering buffer");
+    if (!pv->os_b) {
+	bu_log("tinygl_configureWin: render buffer allocation failed\n");
+	return BRLCAD_ERROR;
+    }
+
+    gl_reshape(dmp, width, height);
+
+    /* this is where font information is set up, if not already done */
+    if (!pv->fs) {
+	pv->fs = glfonsCreate(512, 512, FONS_ZERO_TOPLEFT);
+	if (pv->fs == NULL) {
+	    bu_log("dm-tinygl: Failed to create font stash");
+	    return BRLCAD_ERROR;
+	}
+	pv->fontNormal = FONS_INVALID;
+	pv->fontNormal = fonsAddFont(pv->fs, "sans", bu_dir(NULL, 0, BU_DIR_DATA, "fonts", "ProFont.ttf", NULL));
+    }
+
+    return BRLCAD_OK;
+}
+
+/*
+ * Gracefully release the display.
+ */
+int
+tinygl_close(struct dm *dmp)
+{
+    struct tinygl_vars *pv = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+    bu_free(pv->os_b, "rendering buffer");
+    bu_vls_free(&dmp->i->dm_pathName);
+    bu_vls_free(&dmp->i->dm_tkName);
+    bu_vls_free(&dmp->i->dm_dName);
+    bu_free(dmp->i->dm_vars.priv_vars, "tinygl_close: tinygl_vars");
+    bu_free(dmp->i->dm_vars.pub_vars, "tinygl_close: dm_swvars");
+    BU_PUT(dmp->i, struct dm_impl);
+    BU_PUT(dmp, struct dm);
+
+    return BRLCAD_OK;
+}
+
+int
+tinygl_viable(const char *UNUSED(dpy_string))
+{
+    return 1;
+}
+
+/*
+ * Fire up the display manager, and the display processor.
+ *
+ */
+struct dm *
+tinygl_open(void *ctx, void *UNUSED(interp), int argc, const char **argv)
+{
+    static int count = 0;
+    GLfloat backgnd[4];
+    struct bu_vls str = BU_VLS_INIT_ZERO;
+    struct bu_vls init_proc_vls = BU_VLS_INIT_ZERO;
+    struct dm *dmp = NULL;
+    struct dm_impl *dmpi = NULL;
+    struct gl_vars *mvars = NULL;
+    struct dm_swvars *pubvars = NULL;
+    struct tinygl_vars *privars = NULL;
+
+    BU_GET(dmp, struct dm);
+    dmp->magic = DM_MAGIC;
+    dmp->start_time = 0;
+
+    BU_GET(dmpi, struct dm_impl);
+    *dmpi = *dm_tinygl.i; /* struct copy */
+    dmp->i = dmpi;
+
+    dmp->i->dm_lineWidth = 1;
+    dmp->i->dm_light = 1;
+    dmp->i->dm_bytes_per_pixel = sizeof(GLuint);
+    dmp->i->dm_bits_per_channel = 8;
+    bu_vls_init(&(dmp->i->dm_log));
+
+    BU_ALLOC(dmp->i->dm_vars.pub_vars, struct dm_swvars);
+    if (dmp->i->dm_vars.pub_vars == (void *)NULL) {
+	bu_free(dmp, "tinygl_open: dmp");
+	return DM_NULL;
+    }
+    pubvars = (struct dm_swvars *)dmp->i->dm_vars.pub_vars;
+
+    BU_ALLOC(dmp->i->dm_vars.priv_vars, struct tinygl_vars);
+    if (dmp->i->dm_vars.priv_vars == (void *)NULL) {
+	bu_free(dmp->i->dm_vars.pub_vars, "tinygl_open: dmp->i->dm_vars.pub_vars");
+	bu_free(dmp, "tinygl_open: dmp");
+	return DM_NULL;
+    }
+    privars = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+    privars->v = (struct bview *)ctx;
+#if 0
+    // Note - for Qt, dealing with GL_RGB data display was something of a pain.  This backend
+    // was switched to RGBA to make it easier to display the output
+    privars->ctx = OSMesaCreateContextExt(OSMESA_RGBA, 16, 0, 0, NULL);
+    int width = (!privars->v->gv_width) ? 512 : privars->v->gv_width;
+    int height = (!privars->v->gv_height) ? 512 : privars->v->gv_height;
+    privars->os_b = bu_realloc(privars->os_b, width * height * sizeof(GLubyte)*4, "OSMesa rendering buffer");
+    if (!OSMesaMakeCurrent(privars->ctx, privars->os_b, GL_UNSIGNED_BYTE, width, height)) {
+	bu_log("OSMesaMakeCurrent failed!\n");
+	bu_free(dmp->i->dm_vars.pub_vars, "tinygl_open: dmp->i->dm_vars.pub_vars");
+	bu_free(dmp, "tinygl_open: dmp");
+	return DM_NULL;
+    }
+#endif
+
+    dmp->i->dm_get_internal(dmp);
+    mvars = (struct gl_vars *)dmp->i->m_vars;
+    glvars_init(dmp);
+
+    dmp->i->dm_vp = &mvars->i.default_viewscale;
+
+    bu_vls_init(&dmp->i->dm_pathName);
+    bu_vls_init(&dmp->i->dm_tkName);
+    bu_vls_init(&dmp->i->dm_dName);
+
+    dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);
+
+    if (bu_vls_strlen(&dmp->i->dm_pathName) == 0)
+	bu_vls_printf(&dmp->i->dm_pathName, ".dm_tinygl%d", count);
+    ++count;
+    if (bu_vls_strlen(&dmp->i->dm_dName) == 0) {
+	char *dp;
+
+	dp = getenv("DISPLAY");
+	if (dp)
+	    bu_vls_strcpy(&dmp->i->dm_dName, dp);
+	else
+	    bu_vls_strcpy(&dmp->i->dm_dName, ":0.0");
+    }
+
+    /* initialize dm specific variables */
+    pubvars->devmotionnotify = 0;
+    pubvars->devbuttonpress = 0;
+    pubvars->devbuttonrelease = 0;
+    dmp->i->dm_aspect = 1.0;
+    dmp->i->dm_fontsize = 20;
+
+    /* initialize modifiable variables */
+    mvars->depth = 24;
+    mvars->zbuf = 1;
+    mvars->rgb = 1;
+    mvars->doublebuffer = 1;
+    mvars->fastfog = 1;
+    mvars->fogdensity = 1.0;
+    mvars->lighting_on = dmp->i->dm_light;
+    mvars->zbuffer_on = dmp->i->dm_zbuffer;
+    mvars->zclipping_on = dmp->i->dm_zclip;
+    mvars->debug = dmp->i->dm_debugLevel;
+    mvars->bound = dmp->i->dm_bound;
+    mvars->boundFlag = dmp->i->dm_boundFlag;
+
+    /* this is important so that tinygl_configureWin knows to set the font */
+    privars->fs = NULL;
+
+
+    bu_vls_free(&init_proc_vls);
+    bu_vls_free(&str);
+
+
+    dm_make_current(dmp);
+    gl_setBGColor(dmp, 0, 0, 0);
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    if (mvars->doublebuffer)
+	glDrawBuffer(GL_BACK);
+    else
+	glDrawBuffer(GL_FRONT);
+
+    /* do viewport, ortho commands and initialize font */
+    (void)tinygl_configureWin(dmp, 1);
+
+    /* Lines will be solid when stippling disabled, dashed when enabled*/
+    glLineStipple(1, 0xCF33);
+    glDisable(GL_LINE_STIPPLE);
+
+    backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
+    glFogi(GL_FOG_MODE, GL_LINEAR);
+    glFogf(GL_FOG_START, 0.0);
+    glFogf(GL_FOG_END, 2.0);
+    glFogfv(GL_FOG_COLOR, backgnd);
+
+    /*XXX Need to do something about VIEWFACTOR */
+    glFogf(GL_FOG_DENSITY, VIEWFACTOR);
+
+    /* Initialize matrices */
+    /* Leave it in model_view mode normally */
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrtho(-mvars->i.xlim_view, mvars->i.xlim_view, -mvars->i.ylim_view, mvars->i.ylim_view, 0.0, 2.0);
+    glGetDoublev(GL_PROJECTION_MATRIX, mvars->i.faceplate_mat);
+    glPushMatrix();
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glPushMatrix();
+    glLoadIdentity();
+    mvars->i.faceFlag = 1;	/* faceplate matrix is on top of stack */
+
+    gl_setZBuffer(dmp, dmp->i->dm_zbuffer);
+    gl_setLight(dmp, dmp->i->dm_light);
+
+    return dmp;
+}
+
+/*
+ * Output a string.
+ * The starting position of the beam is as specified.
+ */
+static int
+tinygl_drawString2D(struct dm *dmp, const char *str, fastf_t x, fastf_t y, int UNUSED(size), int use_aspect)
+{
+    struct gl_vars *mvars = (struct gl_vars *)dmp->i->m_vars;
+    struct tinygl_vars *privars = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+    if (dmp->i->dm_debugLevel)
+	bu_log("tinygl_drawString2D()\n");
+
+    if (privars->fontNormal != FONS_INVALID) {
+
+	/* First, we set the position using glRasterPos2f like ogl does */
+	if (use_aspect)
+	    glRasterPos2f(x, y * dmp->i->dm_aspect);
+	else
+	    glRasterPos2f(x, y);
+
+	/* Next, we set up for fontstash */
+	fastf_t font_size = dm_get_fontsize(dmp);
+	int blend_state = glIsEnabled(GL_BLEND);
+	glEnable(GL_BLEND);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+	/* We want to restore the original state we were in when
+	 * we started the text operation - save it */
+	GLint mm;
+	glGetIntegerv(GL_MATRIX_MODE, &mm);
+
+	// Set up an identity matrix for text drawing
+	glMatrixMode(GL_PROJECTION);
+	glPushMatrix();
+	glLoadIdentity();
+
+	// Fontstash does not work in OpenGL raster coordinates,
+	// so we need the view and the coordinates in window
+	// XY coordinates.
+	glOrtho(0,dm_get_width(dmp),dm_get_height(dmp),0,-1,1);
+	GLfloat pos[4];
+	glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
+	fastf_t coord_x = pos[0];
+	fastf_t coord_y = (fastf_t)dm_get_height(dmp)-pos[1];
+	//printf("%f:%f,%f:%f\n",x, coord_x, y, coord_y);
+
+	// Have info and OpenGL state, do the text drawing
+	fonsSetFont(privars->fs, privars->fontNormal);
+	unsigned int color = glfonsRGBA(dmp->i->dm_fg[0], dmp->i->dm_fg[1], dmp->i->dm_fg[2], 255);
+	fonsSetSize(privars->fs, (int)font_size); /* cast to int so we always get a font */
+	fonsSetColor(privars->fs, color);
+	fonsDrawText(privars->fs, coord_x, coord_y, str, NULL);
+
+	// Restore previous projection matrix
+	glPopMatrix();
+
+	// Restore view matrix (changed by glOrtho call)
+	glPopMatrix();
+
+	// Put us back in whatever mode we were in before starting the text draw
+	glMatrixMode(mm);
+
+	if (!blend_state) glDisable(GL_BLEND);
+
+	glOrtho(-mvars->i.xlim_view, mvars->i.xlim_view, -mvars->i.ylim_view, mvars->i.ylim_view, dmp->i->dm_clipmin[2], dmp->i->dm_clipmax[2]);
+    }
+    return BRLCAD_OK;
+}
+
+static int
+tinygl_String2DBBox(struct dm *dmp, vect2d_t *bmin, vect2d_t *bmax, const char *str, fastf_t x, fastf_t y, int UNUSED(size), int use_aspect)
+{
+    struct tinygl_vars *privars = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+    if (dmp->i->dm_debugLevel)
+	bu_log("qtgl_drawString2D()\n");
+
+    if (privars->fontNormal != FONS_INVALID) {
+
+	/* Stash the previous raster position */
+	GLfloat rasterpos[4];
+	glGetFloatv(GL_CURRENT_RASTER_POSITION, rasterpos);
+
+	/* Try to set the new position using glRasterPos2f like ogl does */
+	if (use_aspect)
+	    glRasterPos2f(x, y * dmp->i->dm_aspect);
+	else
+	    glRasterPos2f(x, y);
+
+	/* Check if this position is valid.  If it is not, no text
+	 * will be drawn and there are no bounds to return */
+	GLboolean valid = 1;
+	glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
+	if (!valid) {
+	    glRasterPos3f(rasterpos[0], rasterpos[1], rasterpos[2]);
+	    return BRLCAD_ERROR;
+	}
+
+	/* Next, we set up for fontstash */
+	fastf_t font_size = dm_get_fontsize(dmp);
+
+	// Fontstash does not work in OpenGL raster coordinates,
+	// so we need the view and the coordinates in window
+	// XY coordinates.
+	glMatrixMode(GL_PROJECTION);
+	glPushMatrix();
+	glLoadIdentity();
+	glOrtho(0,dm_get_width(dmp),dm_get_height(dmp),0,-1,1);
+	GLfloat pos[4];
+	glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
+	fastf_t coord_x = pos[0];
+	fastf_t coord_y = (fastf_t)dm_get_height(dmp)-pos[1];
+
+	// Have info and OpenGL state, proceed
+	fonsSetFont(privars->fs, privars->fontNormal);
+	fonsSetSize(privars->fs, (int)font_size); /* cast to int so we always get a font */
+
+	float bounds[4];
+	fonsTextBounds(privars->fs, coord_x, coord_y, str, NULL, (float *)bounds);
+	//int width = fonsTextBounds(privars->fs, coord_x, coord_y, str, NULL, (float *)bounds);
+	//bu_log("%s bounds: min(%f,%f) max(%f,%f)\n", str, bounds[0], bounds[1], bounds[2], bounds[3]);
+	//bu_log("%s width %d\n", str, width);
+
+	// Done with text, put matrices back
+	glPopMatrix();
+	glMatrixMode(GL_PROJECTION);
+	glPopMatrix();
+
+	if (bmin)
+	    V2SET(*bmin, bounds[0], bounds[1]);
+	if (bmax)
+	    V2SET(*bmax, bounds[2], bounds[3]);
+    }
+    return BRLCAD_OK;
+}
+
+int
+tinygl_openFb(struct dm *dmp)
+{
+    struct fb_platform_specific *fb_ps;
+    //struct tinygl_fb_info *ofb_ps;
+    //struct tinygl_vars *privars = (struct tinygl_vars *)dmp->i->dm_vars.priv_vars;
+
+    fb_ps = fb_get_platform_specific(FB_OSGL_MAGIC);
+    //ofb_ps = (struct tinygl_fb_info *)fb_ps->data;
+    //ofb_ps->glc = privars->qw;
+    dmp->i->fbp = fb_open_existing("tinygl", dm_get_width(dmp), dm_get_height(dmp), fb_ps);
+    fb_put_platform_specific(fb_ps);
+    return 0;
+}
+
+int
+tinygl_geometry_request(struct dm *dmp, int UNUSED(width), int UNUSED(height))
+{
+    if (!dmp) return -1;
+    //Tk_GeometryRequest(((struct dm_swvars *)dmp->i->dm_vars.pub_vars)->xtkwin, width, height);
+    return 0;
+}
+
+#define SWVARS_MV_O(_m) offsetof(struct dm_swvars, _m)
+
+struct bu_structparse dm_swvars_vparse[] = {
+    {"%d",      1,      "devmotionnotify",      SWVARS_MV_O(devmotionnotify),    BU_STRUCTPARSE_FUNC_NULL, NULL, NULL },
+    {"%d",      1,      "devbuttonpress",       SWVARS_MV_O(devbuttonpress),     BU_STRUCTPARSE_FUNC_NULL, NULL, NULL },
+    {"%d",      1,      "devbuttonrelease",     SWVARS_MV_O(devbuttonrelease),   BU_STRUCTPARSE_FUNC_NULL, NULL, NULL },
+    {"",        0,      (char *)0,              0,                      BU_STRUCTPARSE_FUNC_NULL, NULL, NULL }
+};
+
+int
+tinygl_internal_var(struct bu_vls *result, struct dm *dmp, const char *key)
+{
+    if (!dmp || !result) return -1;
+    if (!key) {
+        // Print all current vars
+        bu_vls_struct_print2(result, "dm internal GLX variables", dm_swvars_vparse, (const char *)dmp->i->dm_vars.pub_vars);
+        return 0;
+    }
+    // Print specific var
+    bu_vls_struct_item_named(result, dm_swvars_vparse, key, (const char *)dmp->i->dm_vars.pub_vars, ',');
+    return 0;
+}
+
+
+// TODO - this and getDisplayImage need to be consolidated...
+int
+tinygl_write_image(struct bu_vls *UNUSED(msgs), FILE *UNUSED(fp), struct dm *UNUSED(dmp))
+{
+    return -1;
+}
+
+int
+tinygl_event_cmp(struct dm *dmp, dm_event_t type, int event)
+{
+    struct dm_swvars *pubvars = (struct dm_swvars *)dmp->i->dm_vars.pub_vars;
+    switch (type) {
+	case DM_MOTION_NOTIFY:
+	    return (event == pubvars->devmotionnotify) ? 1 : 0;
+	    break;
+	case DM_BUTTON_PRESS:
+	    return (event == pubvars->devbuttonpress) ? 1 : 0;
+	    break;
+	case DM_BUTTON_RELEASE:
+	    return (event == pubvars->devbuttonrelease) ? 1 : 0;
+	    break;
+	default:
+	    return -1;
+	    break;
+    };
+}
+
+struct dm_impl dm_tinygl_impl = {
+    tinygl_open,
+    tinygl_close,
+    tinygl_viable,
+    gl_drawBegin,
+    gl_drawEnd,
+    gl_hud_begin,
+    gl_hud_end,
+    gl_loadMatrix,
+    gl_loadPMatrix,
+    tinygl_drawString2D,
+    tinygl_String2DBBox,
+    gl_drawLine2D,
+    gl_drawLine3D,
+    gl_drawLines3D,
+    gl_drawPoint2D,
+    gl_drawPoint3D,
+    gl_drawPoints3D,
+    gl_drawVList,
+    gl_drawVListHiddenLine,
+    gl_draw_data_axes,
+    gl_draw,
+    gl_setFGColor,
+    gl_setBGColor,
+    gl_setLineAttr,
+    tinygl_configureWin,
+    gl_setWinBounds,
+    gl_setLight,
+    gl_setTransparency,
+    gl_setDepthMask,
+    gl_setZBuffer,
+    gl_debug,
+    gl_logfile,
+    gl_beginDList,
+    gl_endDList,
+    gl_drawDList,
+    gl_freeDLists,
+    gl_genDLists,
+    gl_draw_obj,
+    gl_getDisplayImage, /* display to image function */
+    gl_reshape,
+    tinygl_makeCurrent,
+    null_SwapBuffers,
+    tinygl_doevent,
+    tinygl_openFb,
+    gl_get_internal,
+    gl_put_internal,
+    tinygl_geometry_request,
+    tinygl_internal_var,
+    tinygl_write_image,
+    NULL,
+    NULL,
+    tinygl_event_cmp,
+    gl_fogHint,
+    NULL, //tinygl_share_dlist,
+    0,
+    1,				/* is graphical (sort of...) */
+    "tinygl",                   /* uses tinygl software rasterizer */
+    1,				/* has displaylist */
+    0,                          /* no stereo by default */
+    1.0,			/* zoom-in limit */
+    1,				/* bound flag */
+    "tinygl",
+    "tinygl graphics",
+    1, /* top */
+    0, /* width */
+    0, /* height */
+    0, /* dirty */
+    0, /* bytes per pixel */
+    0, /* bits per channel */
+    0,
+    0,
+    1.0, /* aspect ratio */
+    0,
+    {0, 0},
+    NULL,
+    NULL,
+    BU_VLS_INIT_ZERO,		/* bu_vls path name*/
+    BU_VLS_INIT_ZERO,		/* bu_vls full name drawing window */
+    BU_VLS_INIT_ZERO,		/* bu_vls short name drawing window */
+    BU_VLS_INIT_ZERO,		/* bu_vls logfile */
+    {0, 0, 0},			/* bg color */
+    {0, 0, 0},			/* fg color */
+    {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
+    {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
+    0,				/* no debugging */
+    0,				/* no perspective */
+    1,				/* lighting */
+    1,				/* transparency */
+    1,				/* depth buffer is writable */
+    1,				/* zbuffer */
+    0,				/* no zclipping */
+    0,                          /* clear back buffer after drawing and swap */
+    0,                          /* not overriding the auto font size */
+    gl_vparse,
+    FB_NULL,
+    0,				/* Tcl interpreter */
+    NULL,                       /* Drawing context */
+    NULL                        /* App data */
+};
+
+struct dm dm_tinygl = { DM_MAGIC, &dm_tinygl_impl, 0 };
+
+#ifdef DM_PLUGIN
+static const struct dm_plugin pinfo = { DM_API, &dm_tinygl };
+extern "C" {
+COMPILER_DLLEXPORT const struct dm_plugin *dm_plugin_info()
+{
+    return &pinfo;
+}
+}
+#endif
+
+/*
+ * Local Variables:
+ * mode: C
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-file-style: "stroustrup"
+ * End:
+ * ex: shiftwidth=4 tabstop=8
+ */
diff --git a/src/libdm/tinygl/dm-tinygl.h b/src/libdm/tinygl/dm-tinygl.h
new file mode 100644
index 0000000000..c0b26bb12a
--- /dev/null
+++ b/src/libdm/tinygl/dm-tinygl.h
@@ -0,0 +1,95 @@
+/*                    D M - T I N Y G L . H
+ * BRL-CAD
+ *
+ * Copyright (c) 1993-2021 United States Government as represented by
+ * the U.S. Army Research Laboratory.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this file; see the file named COPYING for more
+ * information.
+ */
+/** @addtogroup libstruct dm */
+/** @{ */
+/** @file dm-tinygl.h
+ *
+ */
+
+#ifndef DM_SWRAST_H
+#define DM_SWRAST_H
+
+#include "common.h"
+
+extern "C" {
+#include "TGL/gl.h"
+#include "zbuffer.h"
+
+#include "bv.h"
+
+/* For portable text in OpenGL, use fontstash */
+#if defined(__GNUC__) && !defined(__clang__)
+#  pragma GCC diagnostic push
+#endif
+#if defined(__clang__)
+#  pragma clang diagnostic push
+#endif
+#if defined(__GNUC__) && !defined(__clang__)
+#  pragma GCC diagnostic ignored "-Wfloat-equal"
+#endif
+#if defined(__clang__)
+#  pragma clang diagnostic ignored "-Wfloat-equal"
+#endif
+
+#define FONTSTASH_IMPLEMENTATION
+#include "../fontstash/fontstash.h"
+#define GLFONTSTASH_IMPLEMENTATION
+#include "../fontstash/glfontstash.h"
+
+#if defined(__GNUC__) && !defined(__clang__)
+#  pragma GCC diagnostic pop
+#endif
+#if defined(__clang__)
+#  pragma clang diagnostic pop
+#endif
+}
+
+extern struct dm dm_tinygl;
+
+struct tinygl_vars {
+    struct bview *v;
+    OSMesaContext ctx;
+    void *os_b;
+    struct FONScontext *fs;
+    int fontNormal;
+    int fontOffset;
+    int *perspective_mode;
+    int ovec;		/* Old color map entry number */
+    char is_direct;
+};
+
+struct dm_swvars {
+    int devmotionnotify;
+    int devbuttonpress;
+    int devbuttonrelease;
+};
+
+#endif /* DM_SWRAST_H */
+
+/** @} */
+/*
+ * Local Variables:
+ * mode: C
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-file-style: "stroustrup"
+ * End:
+ * ex: shiftwidth=4 tabstop=8
+ */
diff --git a/src/libdm/tinygl/fb-tinygl.cpp b/src/libdm/tinygl/fb-tinygl.cpp
new file mode 100644
index 0000000000..72994b6022
--- /dev/null
+++ b/src/libdm/tinygl/fb-tinygl.cpp
@@ -0,0 +1,1029 @@
+/*                   F B - T I N Y G L . C P P
+ * BRL-CAD
+ *
+ * Copyright (c) 1989-2021 United States Government as represented by
+ * the U.S. Army Research Laboratory.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this file; see the file named COPYING for more
+ * information.
+ */
+/** @addtogroup libstruct fb */
+/** @{ */
+/** @file fb-tinygl.cpp
+ *
+ * An OpenGL framebuffer using OSMesa software rasterization.
+ */
+/** @} */
+
+
+#include "common.h"
+
+#include "bu/app.h"
+
+#define TGL_PREFIX 1
+#include "TGL/gl.h"
+#include "zbuffer.h"
+
+extern "C" {
+#include "../include/private.h"
+#include "../dm-gl.h"
+}
+
+extern "C" {
+extern struct fb tinygl_interface;
+}
+
+// NOTE - Qt is used here because we need a dm window to display the fb in
+// stand-alone mode.  There should be nothing specific to Qt in most of the
+// core tinygl logic, and we should always be able to replace the Qt dm here
+// with any other dm backend to achieve the same results.
+#include <QApplication>
+#include "tinyglwin.h"
+
+struct tinyglinfo {
+    int ac;
+    char **av;
+    QApplication *qapp = NULL;
+    QtSWWin *mw = NULL;
+
+    int cmap_size;		/* hardware colormap size */
+    int win_width;              /* actual window width */
+    int win_height;             /* actual window height */
+    int vp_width;               /* actual viewport width */
+    int vp_height;              /* actual viewport height */
+    struct fb_clip clip;        /* current view clipping */
+    short mi_cmap_flag;		/* enabled when there is a non-linear map in memory */
+
+    int mi_memwidth;            /* width of scanline in if_mem */
+
+    int alive;
+};
+
+#define SWRAST(ptr) ((struct tinyglinfo *)((ptr)->i->pp))
+#define SWRASTL(ptr) ((ptr)->i->pp)     /* left hand side version */
+#define if_cmap u3.p		/* color map memory */
+#define CMR(x) ((struct fb_cmap *)((x)->i->if_cmap))->cmr
+#define CMG(x) ((struct fb_cmap *)((x)->i->if_cmap))->cmg
+#define CMB(x) ((struct fb_cmap *)((x)->i->if_cmap))->cmb
+
+
+static void
+tinygl_xmit_scanlines(struct fb *ifp, int ybase, int nlines, int xbase, int npix)
+{
+    int y;
+    int n;
+    struct fb_clip *clp = &(SWRAST(ifp)->clip);
+
+    int sw_cmap;	/* !0 => needs software color map */
+    if (SWRAST(ifp)->mi_cmap_flag) {
+	sw_cmap = 1;
+    } else {
+	sw_cmap = 0;
+    }
+
+    if (xbase > clp->xpixmax || ybase > clp->ypixmax)
+	return;
+    if (xbase < clp->xpixmin)
+	xbase = clp->xpixmin;
+    if (ybase < clp->ypixmin)
+	ybase = clp->ypixmin;
+
+    if ((xbase + npix -1) > clp->xpixmax)
+	npix = clp->xpixmax - xbase + 1;
+    if ((ybase + nlines - 1) > clp->ypixmax)
+	nlines = clp->ypixmax - ybase + 1;
+
+    if (sw_cmap) {
+	/* Software colormap each line as it's transmitted */
+	int x;
+	struct fb_pixel *tinyglp;
+	struct fb_pixel *scanline;
+
+	y = ybase;
+
+	if (FB_DEBUG)
+	    printf("Doing sw colormap xmit\n");
+
+	/* Perform software color mapping into temp scanline */
+	scanline = (struct fb_pixel *)calloc(ifp->i->if_width, sizeof(struct fb_pixel));
+	if (scanline == NULL) {
+	    fb_log("tinygl_getmem: scanline memory malloc failed\n");
+	    return;
+	}
+
+	for (n=nlines; n>0; n--, y++) {
+	    tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth) * sizeof(struct fb_pixel)];
+	    for (x=xbase+npix-1; x>=xbase; x--) {
+		scanline[x].red   = CMR(ifp)[tinyglp[x].red];
+		scanline[x].green = CMG(ifp)[tinyglp[x].green];
+		scanline[x].blue  = CMB(ifp)[tinyglp[x].blue];
+	    }
+
+	    glPixelStorei(GL_UNPACK_SKIP_PIXELS, xbase);
+	    glRasterPos2i(xbase, y);
+	    glDrawPixels(npix, 1, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid *)scanline);
+	}
+
+	(void)free((void *)scanline);
+
+    } else {
+	/* No need for software colormapping */
+	glPixelStorei(GL_UNPACK_ROW_LENGTH, SWRAST(ifp)->mi_memwidth);
+	glPixelStorei(GL_UNPACK_SKIP_PIXELS, xbase);
+	glPixelStorei(GL_UNPACK_SKIP_ROWS, ybase);
+
+	glRasterPos2i(xbase, ybase);
+	glDrawPixels(npix, nlines, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid *) ifp->i->if_mem);
+    }
+}
+
+
+
+
+static void
+qt_destroy(struct tinyglinfo *qi)
+{
+    delete qi->mw;
+    delete qi->qapp;
+    free(qi->av[0]);
+    free(qi->av);
+}
+
+
+HIDDEN int
+tinygl_getmem(struct fb *ifp)
+{
+    int pixsize;
+    int size;
+    char *sp = (char *)ifp->i->if_mem;
+
+    errno = 0;
+
+    {
+	/*
+	 * only malloc as much memory as is needed.
+	 */
+	SWRAST(ifp)->mi_memwidth = ifp->i->if_width;
+	pixsize = ifp->i->if_height * ifp->i->if_width * sizeof(struct fb_pixel);
+	size = pixsize + sizeof(struct fb_cmap);
+
+	if (!sp) {
+	    sp = (char *)calloc(1, size);
+	} else {
+	    sp = (char *)bu_realloc(sp, size, "realloc fb memory");
+	    memset(sp, 0, size);
+	}
+	if (sp == 0) {
+	    fb_log("tinygl_getmem: frame buffer memory malloc failed\n");
+	    goto fail;
+	}
+	goto success;
+    }
+
+success:
+    ifp->i->if_mem = sp;
+
+    return 0;
+fail:
+    if ((sp = (char *)calloc(1, size)) == NULL) {
+	fb_log("tinygl_getmem:  malloc failure\n");
+	return -1;
+    }
+    goto success;
+}
+
+
+/**
+ * Given:- the size of the viewport in pixels (vp_width, vp_height)
+ *	 - the size of the framebuffer image (if_width, if_height)
+ *	 - the current view center (if_xcenter, if_ycenter)
+ * 	 - the current zoom (if_xzoom, if_yzoom)
+ * Calculate:
+ *	 - the position of the viewport in image space
+ *		(xscrmin, xscrmax, yscrmin, yscrmax)
+ *	 - the portion of the image which is visible in the viewport
+ *		(xpixmin, xpixmax, ypixmin, ypixmax)
+ */
+void
+fb_clipper(struct fb *ifp)
+{
+    struct fb_clip *clp;
+    int i;
+    double pixels;
+
+    clp = &(SWRAST(ifp)->clip);
+
+    i = SWRAST(ifp)->vp_width/(2*ifp->i->if_xzoom);
+    clp->xscrmin = ifp->i->if_xcenter - i;
+    i = SWRAST(ifp)->vp_width/ifp->i->if_xzoom;
+    clp->xscrmax = clp->xscrmin + i;
+    pixels = (double) i;
+    clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) SWRAST(ifp)->vp_width);
+    clp->oright = clp->oleft + pixels;
+
+    i = SWRAST(ifp)->vp_height/(2*ifp->i->if_yzoom);
+    clp->yscrmin = ifp->i->if_ycenter - i;
+    i = SWRAST(ifp)->vp_height/ifp->i->if_yzoom;
+    clp->yscrmax = clp->yscrmin + i;
+    pixels = (double) i;
+    clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) SWRAST(ifp)->vp_height);
+    clp->otop = clp->obottom + pixels;
+
+    clp->xpixmin = clp->xscrmin;
+    clp->xpixmax = clp->xscrmax;
+    clp->ypixmin = clp->yscrmin;
+    clp->ypixmax = clp->yscrmax;
+
+    if (clp->xpixmin < 0) {
+	clp->xpixmin = 0;
+    }
+
+    if (clp->ypixmin < 0) {
+	clp->ypixmin = 0;
+    }
+
+	if (clp->xpixmax > ifp->i->if_width-1) {
+	    clp->xpixmax = ifp->i->if_width-1;
+	}
+	if (clp->ypixmax > ifp->i->if_height-1) {
+	    clp->ypixmax = ifp->i->if_height-1;
+	}
+    }
+
+int
+tinygl_configureWindow(struct fb *ifp, int width, int height)
+{
+    int getmem = 0;
+
+    if (!SWRAST(ifp)->mi_memwidth)
+	getmem = 1;
+
+    SWRAST(ifp)->vp_width = width;
+    SWRAST(ifp)->vp_height = height;
+
+    ifp->i->if_width = ifp->i->if_max_width = width;
+    ifp->i->if_height = ifp->i->if_max_height = height;
+
+    ifp->i->if_xzoom = 1;
+    ifp->i->if_yzoom = 1;
+    ifp->i->if_xcenter = width/2;
+    ifp->i->if_ycenter = height/2;
+
+    if (!getmem && width == SWRAST(ifp)->win_width &&
+	height == SWRAST(ifp)->win_height)
+	return 1;
+
+    tinygl_getmem(ifp);
+    fb_clipper(ifp);
+
+    SWRAST(ifp)->win_width = width;
+    SWRAST(ifp)->win_height = height;
+
+    dm_make_current(ifp->i->dmp);
+
+    return 0;
+}
+
+
+HIDDEN void
+tinygl_do_event(struct fb *ifp)
+{
+    SWRAST(ifp)->mw->update();
+}
+
+static int
+tinygl_open_existing(struct fb *ifp, int width, int height, struct fb_platform_specific *fb_p)
+{
+    BU_CKMAG(fb_p, FB_SWFB_MAGIC, "tinygl framebuffer");
+
+    // If this really is an existing ifp, may not need to create this container
+    // - tinygl_open may already have allocated it to store Qt window info.
+    if (!ifp->i->pp) {
+	if ((ifp->i->pp = (char *)calloc(1, sizeof(struct tinyglinfo))) == NULL) {
+	    fb_log("fb_tinygl:  tinyglinfo malloc failed\n");
+	    return -1;
+	}
+    }
+
+    ifp->i->dmp = (struct dm *)fb_p->data;
+
+    if (ifp->i->dmp) {
+	ifp->i->dmp->i->fbp = ifp;
+
+	// Since the fb is in the context of a dm, print its debugging output in dm style
+	gl_debug_print(ifp->i->dmp, "FB: qtgl_open_existing", ifp->i->dmp->i->dm_debugLevel);
+    }
+
+    ifp->i->if_width = ifp->i->if_max_width = width;
+    ifp->i->if_height = ifp->i->if_max_height = height;
+
+    SWRAST(ifp)->win_width = SWRAST(ifp)->vp_width = width;
+    SWRAST(ifp)->win_height = SWRAST(ifp)->vp_height = height;
+
+    /* initialize window state variables before calling tinygl_getmem */
+    ifp->i->if_xzoom = 1;	/* for zoom fakeout */
+    ifp->i->if_yzoom = 1;	/* for zoom fakeout */
+    ifp->i->if_xcenter = width/2;
+    ifp->i->if_ycenter = height/2;
+
+    /* Allocate memory */
+    if (!SWRAST(ifp)->mi_memwidth) {
+	if (tinygl_getmem(ifp) < 0)
+	    return -1;
+    }
+
+    fb_clipper(ifp);
+
+    tinygl_configureWindow(ifp, width, height);
+
+    return 0;
+}
+
+static int
+fb_tinygl_open(struct fb *ifp, const char *UNUSED(file), int width, int height)
+{
+    FB_CK_FB(ifp->i);
+
+    if ((ifp->i->pp = (char *)calloc(1, sizeof(struct tinyglinfo))) == NULL) {
+	fb_log("fb_tinygl:  tinyglinfo malloc failed\n");
+	return -1;
+    }
+
+    ifp->i->stand_alone = 1;
+
+    struct tinyglinfo *qi = SWRAST(ifp);
+    qi->av = (char **)calloc(2, sizeof(char *));
+    qi->ac = 1;
+    qi->av[0] = bu_strdup("Frame buffer");
+    qi->av[1] = NULL;
+    FB_CK_FB(ifp->i);
+
+    qi->win_width = qi->vp_width = width;
+    qi->win_height = qi->vp_width = height;
+
+    qi->qapp = new QApplication(qi->ac, qi->av);
+
+    qi->mw = new QtSWWin(ifp);
+
+    BU_GET(qi->mw->canvas->v, struct bview);
+    bv_init(qi->mw->canvas->v);
+    qi->mw->canvas->v->gv_s->gv_fb_mode = 1;
+    qi->mw->canvas->v->gv_width = width;
+    qi->mw->canvas->v->gv_height = height;
+
+
+    qi->mw->canvas->setFixedSize(width, height);
+    qi->mw->adjustSize();
+    qi->mw->setFixedSize(qi->mw->size());
+    qi->mw->show();
+
+    // Do the standard libdm attach to get our rendering backend.
+    const char *acmd = "attach";
+    struct dm *dmp = dm_open((void *)qi->mw->canvas->v, NULL, "tinygl", 1, &acmd);
+    if (!dmp)
+	return -1;
+
+    struct fb_platform_specific fbps;
+    fbps.magic = FB_SWFB_MAGIC;
+    fbps.data = (void *)dmp;
+
+    return tinygl_open_existing(ifp, width, height, &fbps);
+}
+
+HIDDEN struct fb_platform_specific *
+tinygl_get_fbps(uint32_t magic)
+{
+    struct fb_platform_specific *fb_ps = NULL;
+    BU_GET(fb_ps, struct fb_platform_specific);
+    fb_ps->magic = magic;
+    fb_ps->data = NULL;
+    return fb_ps;
+}
+
+
+HIDDEN void
+tinygl_put_fbps(struct fb_platform_specific *fbps)
+{
+    BU_CKMAG(fbps, FB_SWFB_MAGIC, "tinygl framebuffer");
+    BU_PUT(fbps, struct fb_platform_specific);
+    return;
+}
+
+
+HIDDEN int
+tinygl_flush(struct fb *UNUSED(ifp))
+{
+    glFlush();
+    return 0;
+}
+
+
+HIDDEN int
+fb_tinygl_close(struct fb *ifp)
+{
+    struct tinyglinfo *qi = SWRAST(ifp);
+
+    /* if a window was created wait for user input and process events */
+    if (qi->qapp) {
+	return qi->qapp->exec();
+	qt_destroy(qi);
+    }
+
+    return 0;
+}
+
+int
+tinygl_close_existing(struct fb *ifp)
+{
+    struct tinyglinfo *qi = SWRAST(ifp);
+    qi->alive = 0;
+    return 0;
+}
+
+/*
+ * Handle any pending input events
+ */
+HIDDEN int
+tinygl_poll(struct fb *ifp)
+{
+    tinygl_do_event(ifp);
+
+    if (SWRAST(ifp)->alive)
+	return 0;
+    return 1;
+}
+
+
+/*
+ * Free memory resources and close.
+ */
+HIDDEN int
+tinygl_free(struct fb *ifp)
+{
+    if (FB_DEBUG)
+	printf("entering tinygl_free\n");
+
+    /* Close the framebuffer */
+    if (FB_DEBUG)
+	printf("tinygl_free: All done...goodbye!\n");
+
+    if (ifp->i->if_mem != NULL) {
+	/* free up memory associated with image */
+	(void)free(ifp->i->if_mem);
+    }
+
+    if (SWRASTL(ifp) != NULL) {
+	(void)free((char *)SWRASTL(ifp));
+	SWRASTL(ifp) = NULL;
+    }
+
+    return 0;
+}
+
+
+HIDDEN int
+tinygl_clear(struct fb *ifp, unsigned char *pp)
+{
+    struct fb_pixel bg;
+    struct fb_pixel *tinyglp;
+    int cnt;
+    int y;
+
+    if (FB_DEBUG)
+	printf("entering tinygl_clear\n");
+
+    /* Set clear colors */
+    if (pp != RGBPIXEL_NULL) {
+	bg.alpha = 0;
+	bg.red   = (pp)[RED];
+	bg.green = (pp)[GRN];
+	bg.blue  = (pp)[BLU];
+    } else {
+	bg.alpha = 0;
+	bg.red   = 0;
+	bg.green = 0;
+	bg.blue  = 0;
+    }
+
+    /* Flood rectangle in memory */
+    for (y = 0; y < ifp->i->if_height; y++) {
+	tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth+0)*sizeof(struct fb_pixel) ];
+	for (cnt = ifp->i->if_width-1; cnt >= 0; cnt--) {
+	    *tinyglp++ = bg;	/* struct copy */
+	}
+    }
+
+    if (ifp->i->dmp)
+	dm_make_current(ifp->i->dmp);
+
+    if (pp != RGBPIXEL_NULL) {
+	glClearColor(pp[RED]/255.0, pp[GRN]/255.0, pp[BLU]/255.0, 0.0);
+    } else {
+	glClearColor(0, 0, 0, 0);
+    }
+
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    return 0;
+}
+
+
+static int
+tinygl_view(struct fb *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
+{
+    if (FB_DEBUG)
+	printf("entering tinygl_view\n");
+
+    if (xzoom < 1) xzoom = 1;
+    if (yzoom < 1) yzoom = 1;
+    if (ifp->i->if_xcenter == xcenter && ifp->i->if_ycenter == ycenter
+	&& ifp->i->if_xzoom == xzoom && ifp->i->if_yzoom == yzoom)
+	return 0;
+
+    if (xcenter < 0 || xcenter >= ifp->i->if_width)
+	return -1;
+    if (ycenter < 0 || ycenter >= ifp->i->if_height)
+	return -1;
+    if (xzoom >= ifp->i->if_width || yzoom >= ifp->i->if_height)
+	return -1;
+
+    ifp->i->if_xcenter = xcenter;
+    ifp->i->if_ycenter = ycenter;
+    ifp->i->if_xzoom = xzoom;
+    ifp->i->if_yzoom = yzoom;
+
+    if (ifp->i->dmp) {
+	dm_make_current(ifp->i->dmp);
+
+	gl_debug_print(ifp->i->dmp, "FB: qtgl_view", ifp->i->dmp->i->dm_debugLevel);
+    }
+
+    fb_clipper(ifp);
+
+    if (ifp->i->dmp && ifp->i->dmp->i->dm_debugLevel > 3)
+	gl_debug_print(ifp->i->dmp, "FB: qtgl_view after:", ifp->i->dmp->i->dm_debugLevel);
+
+    // TODO - somehow, we need to trigger an update event here for incremental display...
+    dm_set_dirty(ifp->i->dmp, 1);
+    return 0;
+}
+
+
+static int
+tinygl_getview(struct fb *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
+{
+    if (FB_DEBUG)
+	printf("entering tinygl_getview\n");
+
+    *xcenter = ifp->i->if_xcenter;
+    *ycenter = ifp->i->if_ycenter;
+    *xzoom = ifp->i->if_xzoom;
+    *yzoom = ifp->i->if_yzoom;
+
+    return 0;
+}
+
+
+/* read count pixels into pixelp starting at x, y */
+static ssize_t
+tinygl_read(struct fb *ifp, int x, int y, unsigned char *pixelp, size_t count)
+{
+    size_t n;
+    size_t scan_count;	/* # pix on this scanline */
+    unsigned char *cp;
+    ssize_t ret;
+    struct fb_pixel *tinyglp;
+
+    if (FB_DEBUG)
+	printf("entering tinygl_read\n");
+
+    if (x < 0 || x >= ifp->i->if_width ||
+	y < 0 || y >= ifp->i->if_height)
+	return -1;
+
+    ret = 0;
+    cp = (unsigned char *)(pixelp);
+
+    while (count) {
+	if (y >= ifp->i->if_height)
+	    break;
+
+	if (count >= (size_t)(ifp->i->if_width-x))
+	    scan_count = ifp->i->if_width-x;
+	else
+	    scan_count = count;
+
+	tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth+x)*sizeof(struct fb_pixel) ];
+
+	n = scan_count;
+	while (n) {
+	    cp[RED] = tinyglp->red;
+	    cp[GRN] = tinyglp->green;
+	    cp[BLU] = tinyglp->blue;
+	    tinyglp++;
+	    cp += 3;
+	    n--;
+	}
+	ret += scan_count;
+	count -= scan_count;
+	x = 0;
+	/* Advance upwards */
+	if (++y >= ifp->i->if_height)
+	    break;
+    }
+    return ret;
+}
+
+
+/* write count pixels from pixelp starting at xstart, ystart */
+static ssize_t
+tinygl_write(struct fb *ifp, int xstart, int ystart, const unsigned char *pixelp, size_t count)
+{
+    int x;
+    int y;
+    size_t scan_count;  /* # pix on this scanline */
+    size_t pix_count;   /* # pixels to send */
+    ssize_t ret;
+
+    FB_CK_FB(ifp->i);
+
+    if (FB_DEBUG)
+	printf("entering tinygl_write\n");
+
+    /* fast exit cases */
+    pix_count = count;
+    if (pix_count == 0)
+	return 0;	/* OK, no pixels transferred */
+
+    x = xstart;
+    y = ystart;
+
+    if (x < 0 || x >= ifp->i->if_width ||
+	    y < 0 || y >= ifp->i->if_height)
+	return -1;
+
+    ret = 0;
+
+    unsigned char *cp;
+    //int ybase;
+
+    //ybase = ystart;
+    cp = (unsigned char *)(pixelp);
+
+    while (pix_count) {
+	size_t n;
+	struct fb_pixel *tinyglp;
+
+	if (y >= ifp->i->if_height)
+	    break;
+
+	if (pix_count >= (size_t)(ifp->i->if_width-x))
+	    scan_count = (size_t)(ifp->i->if_width-x);
+	else
+	    scan_count = pix_count;
+
+	tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth+x)*sizeof(struct fb_pixel) ];
+
+	n = scan_count;
+	if ((n & 3) != 0) {
+	    /* This code uses 60% of all CPU time */
+	    while (n) {
+		/* alpha channel is always zero */
+		tinyglp->red   = cp[RED];
+		tinyglp->green = cp[GRN];
+		tinyglp->blue  = cp[BLU];
+		tinyglp++;
+		cp += 3;
+		n--;
+	    }
+	} else {
+	    while (n) {
+		/* alpha channel is always zero */
+		tinyglp[0].red   = cp[RED+0*3];
+		tinyglp[0].green = cp[GRN+0*3];
+		tinyglp[0].blue  = cp[BLU+0*3];
+		tinyglp[1].red   = cp[RED+1*3];
+		tinyglp[1].green = cp[GRN+1*3];
+		tinyglp[1].blue  = cp[BLU+1*3];
+		tinyglp[2].red   = cp[RED+2*3];
+		tinyglp[2].green = cp[GRN+2*3];
+		tinyglp[2].blue  = cp[BLU+2*3];
+		tinyglp[3].red   = cp[RED+3*3];
+		tinyglp[3].green = cp[GRN+3*3];
+		tinyglp[3].blue  = cp[BLU+3*3];
+		tinyglp += 4;
+		cp += 3*4;
+		n -= 4;
+	    }
+	}
+	ret += scan_count;
+	pix_count -= scan_count;
+	x = 0;
+	if (++y >= ifp->i->if_height)
+	    break;
+    }
+
+    return ret;
+}
+
+
+/*
+ * The task of this routine is to reformat the pixels into WIN
+ * internal form, and then arrange to have them sent to the screen
+ * separately.
+ */
+HIDDEN int
+tinygl_writerect(struct fb *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
+{
+    int x;
+    int y;
+    unsigned char *cp;
+    struct fb_pixel *tinyglp;
+
+    if (FB_DEBUG)
+	printf("entering tinygl_writerect\n");
+
+    if (width <= 0 || height <= 0)
+	return 0;  /* do nothing */
+    if (xmin < 0 || xmin+width > ifp->i->if_width ||
+	ymin < 0 || ymin+height > ifp->i->if_height)
+	return -1; /* no can do */
+
+    cp = (unsigned char *)(pp);
+    for (y = ymin; y < ymin+height; y++) {
+	tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth+xmin)*sizeof(struct fb_pixel) ];
+	for (x = xmin; x < xmin+width; x++) {
+	    /* alpha channel is always zero */
+	    tinyglp->red   = cp[RED];
+	    tinyglp->green = cp[GRN];
+	    tinyglp->blue  = cp[BLU];
+	    tinyglp++;
+	    cp += 3;
+	}
+    }
+
+    SWRAST(ifp)->mw->update();
+
+    return width*height;
+}
+
+
+/*
+ * The task of this routine is to reformat the pixels into WIN
+ * internal form, and then arrange to have them sent to the screen
+ * separately.
+ */
+HIDDEN int
+tinygl_bwwriterect(struct fb *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
+{
+    int x;
+    int y;
+    unsigned char *cp;
+    struct fb_pixel *tinyglp;
+
+    if (FB_DEBUG)
+	printf("entering tinygl_bwwriterect\n");
+
+    if (width <= 0 || height <= 0)
+	return 0;  /* do nothing */
+    if (xmin < 0 || xmin+width > ifp->i->if_width ||
+	ymin < 0 || ymin+height > ifp->i->if_height)
+	return -1; /* no can do */
+
+    cp = (unsigned char *)(pp);
+    for (y = ymin; y < ymin+height; y++) {
+	tinyglp = (struct fb_pixel *)&ifp->i->if_mem[(y*SWRAST(ifp)->mi_memwidth+xmin)*sizeof(struct fb_pixel) ];
+	for (x = xmin; x < xmin+width; x++) {
+	    int val;
+	    /* alpha channel is always zero */
+	    tinyglp->red   = (val = *cp++);
+	    tinyglp->green = val;
+	    tinyglp->blue  = val;
+	    tinyglp++;
+	}
+    }
+
+    SWRAST(ifp)->mw->update();
+
+    return width*height;
+}
+
+
+HIDDEN int
+tinygl_rmap(struct fb *UNUSED(ifp), ColorMap *UNUSED(cmp))
+{
+    if (FB_DEBUG)
+	printf("entering tinygl_rmap\n");
+#if 0
+    /* Just parrot back the stored colormap */
+    for (i = 0; i < 256; i++) {
+	cmp->cm_red[i]   = CMR(ifp)[i]<<8;
+	cmp->cm_green[i] = CMG(ifp)[i]<<8;
+	cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
+    }
+#endif
+    return 0;
+}
+
+
+HIDDEN int
+tinygl_wmap(struct fb *UNUSED(ifp), const ColorMap *UNUSED(cmp))
+{
+    if (FB_DEBUG)
+	printf("entering tinygl_wmap\n");
+
+    return 0;
+}
+
+
+HIDDEN int
+tinygl_help(struct fb *ifp)
+{
+    fb_log("Description: %s\n", ifp->i->if_type);
+    fb_log("Device: %s\n", ifp->i->if_name);
+    fb_log("Max width height: %d %d\n",
+	   ifp->i->if_max_width,
+	   ifp->i->if_max_height);
+    fb_log("Default width height: %d %d\n",
+	   ifp->i->if_width,
+	   ifp->i->if_height);
+    fb_log("Usage: /dev/tinygl\n");
+
+    return 0;
+}
+
+
+HIDDEN int
+tinygl_setcursor(struct fb *ifp, const unsigned char *UNUSED(bits), int UNUSED(xbits), int UNUSED(ybits), int UNUSED(xorig), int UNUSED(yorig))
+{
+    FB_CK_FB(ifp->i);
+
+    // If it should ever prove desirable to alter the cursor or disable it, here's how it is done:
+    // dynamic_cast<osgViewer::GraphicsWindow*>(camera->getGraphicsContext()))->setCursor(osgViewer::GraphicsWindow::NoCursor);
+
+    return 0;
+}
+
+
+HIDDEN int
+tinygl_cursor(struct fb *UNUSED(ifp), int UNUSED(mode), int UNUSED(x), int UNUSED(y))
+{
+
+    fb_log("tinygl_cursor\n");
+    return 0;
+}
+
+
+int
+tinygl_refresh(struct fb *ifp, int x, int y, int w, int h)
+{
+
+    if (w < 0) {
+	w = -w;
+	x -= w;
+    }
+
+    if (h < 0) {
+	h = -h;
+	y -= h;
+    }
+
+    if (ifp->i->dmp)
+	gl_debug_print(ifp->i->dmp, "FB: qtgl_refresh", ifp->i->dmp->i->dm_debugLevel);
+
+    int mm;
+    glGetIntegerv(GL_MATRIX_MODE, &mm);
+
+    glMatrixMode(GL_PROJECTION);
+    glPushMatrix();
+    glLoadIdentity();
+
+    struct fb_clip *clp;
+    fb_clipper(ifp);
+    clp = &(SWRAST(ifp)->clip);
+    glOrtho(clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
+    glPixelZoom((float) ifp->i->if_xzoom, (float) ifp->i->if_yzoom);
+
+    glMatrixMode(GL_MODELVIEW);
+    glPushMatrix();
+    glLoadIdentity();
+
+    glViewport(0, 0, SWRAST(ifp)->win_width, SWRAST(ifp)->win_height);
+    tinygl_xmit_scanlines(ifp, y, h, x, w);
+    glMatrixMode(GL_PROJECTION);
+    glPopMatrix();
+    glMatrixMode(GL_MODELVIEW);
+    glPopMatrix();
+    glMatrixMode(mm);
+
+    if (ifp->i->dmp && ifp->i->dmp->i->dm_debugLevel > 3)
+	gl_debug_print(ifp->i->dmp, "FB: qtgl_refresh after:", ifp->i->dmp->i->dm_debugLevel);
+
+    dm_set_dirty(ifp->i->dmp, 1);
+    return 0;
+}
+
+
+/* This is the ONLY thing that we normally "export" */
+struct fb_impl tinygl_interface_impl =
+{
+    0,			/* magic number slot */
+    FB_SWFB_MAGIC,
+    fb_tinygl_open,	/* open device */
+    tinygl_open_existing,    /* existing device_open */
+    tinygl_close_existing,    /* existing device_close */
+    tinygl_get_fbps,         /* get platform specific memory */
+    tinygl_put_fbps,         /* free platform specific memory */
+    fb_tinygl_close,	/* close device */
+    tinygl_clear,		/* clear device */
+    tinygl_read,		/* read pixels */
+    tinygl_write,		/* write pixels */
+    tinygl_rmap,		/* read colormap */
+    tinygl_wmap,		/* write colormap */
+    tinygl_view,		/* set view */
+    tinygl_getview,	/* get view */
+    tinygl_setcursor,	/* define cursor */
+    tinygl_cursor,		/* set cursor */
+    fb_sim_getcursor,	/* get cursor */
+    fb_sim_readrect,	/* read rectangle */
+    tinygl_writerect,	/* write rectangle */
+    fb_sim_bwreadrect,
+    tinygl_bwwriterect,	/* write rectangle */
+    tinygl_configureWindow,
+    tinygl_refresh,
+    tinygl_poll,		/* process events */
+    tinygl_flush,		/* flush output */
+    tinygl_free,		/* free resources */
+    tinygl_help,		/* help message */
+    bu_strdup("OSMesa tinygl OpenGL"),	/* device description */
+    FB_XMAXSCREEN,		/* max width */
+    FB_YMAXSCREEN,		/* max height */
+    bu_strdup("/dev/tinygl"),		/* short device name */
+    512,		/* default/current width */
+    512,		/* default/current height */
+    -1,			/* select file desc */
+    -1,			/* file descriptor */
+    1, 1,		/* zoom */
+    256, 256,		/* window center */
+    0, 0, 0,		/* cursor */
+    PIXEL_NULL,		/* page_base */
+    PIXEL_NULL,		/* page_curp */
+    PIXEL_NULL,		/* page_endp */
+    -1,			/* page_no */
+    0,			/* page_dirty */
+    0L,			/* page_curpos */
+    0L,			/* page_pixels */
+    0,			/* debug */
+    50000,		/* refresh rate */
+    NULL,
+    NULL,
+    0,
+    NULL,
+    {0}, /* u1 */
+    {0}, /* u2 */
+    {0}, /* u3 */
+    {0}, /* u4 */
+    {0}, /* u5 */
+    {0}  /* u6 */
+};
+
+extern "C" {
+struct fb tinygl_interface = { &tinygl_interface_impl };
+
+#ifdef DM_PLUGIN
+static const struct fb_plugin finfo = { &tinygl_interface };
+
+extern "C" {
+COMPILER_DLLEXPORT const struct fb_plugin *fb_plugin_info()
+{
+    return &finfo;
+}
+}
+}
+#endif
+
+/* Because class is actually used to access a struct
+ * entry in this file, preserve our redefinition
+ * of class for the benefit of avoiding C++ name
+ * collisions until the end of this file */
+#undef class
+
+/*
+ * Local Variables:
+ * mode: C
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-file-style: "stroustrup"
+ * End:
+ * ex: shiftwidth=4 tabstop=8
+ */
diff --git a/src/libdm/tinygl/tinyglwin.cpp b/src/libdm/tinygl/tinyglwin.cpp
new file mode 100644
index 0000000000..a2f8536aa7
--- /dev/null
+++ b/src/libdm/tinygl/tinyglwin.cpp
@@ -0,0 +1,43 @@
+/*                  S W R A S T W I N . C P P
+ * BRL-CAD
+ *
+ * Copyright (c) 2014-2021 United States Government as represented by
+ * the U.S. Army Research Laboratory.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this file; see the file named COPYING for more
+ * information.
+ */
+/** @file swrastwin.cpp
+ *
+ */
+
+#include "swrastwin.h"
+
+QtSWWin::QtSWWin(struct fb *fbp)
+{
+    canvas = new QtSW(this, fbp);
+    this->setCentralWidget(canvas);
+    canvas->setMinimumSize(1,1);
+}
+
+/*
+ * Local Variables:
+ * mode: C++
+ * tab-width: 8
+ * c-basic-offset: 4
+ * indent-tabs-mode: t
+ * c-file-style: "stroustrup"
+ * End:
+ * ex: shiftwidth=4 tabstop=8
+ */
+
diff --git a/src/libdm/tinygl/tinyglwin.h b/src/libdm/tinygl/tinyglwin.h
new file mode 100644
index 0000000000..8d7563bda5
--- /dev/null
+++ b/src/libdm/tinygl/tinyglwin.h
@@ -0,0 +1,53 @@
+/*                   S W R A S T W I N . H
+ * BRL-CAD
+ *
+ * Copyright (c) 2014-2021 United States Government as represented by
+ * the U.S. Army Research Laboratory.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this file; see the file named COPYING for more
+ * information.
+ */
+/** @file main_window.h
+ *
+ * Defines the toplevel Qt window for a stand-alone swrast dm.
+ *
+ */
+
+#ifndef QTSWRASTWIN_H
+#define QTSWRASTWIN_H
+
+#include <QMainWindow>
+#include "dm.h"
+#include "qtcad/QtSW.h"
+
+class QtSWWin : public QMainWindow
+{
+    Q_OBJECT
+    public:
+	QtSWWin(struct fb *fbp);
+	QtSW *canvas = NULL;
+};
+
+#endif /* QTSWRASTWIN_H */
+
+/*
+ * Local Variables:
+ * mode: C++
+ * tab-width: 8
+ * c-basic-offset: 4
+ * indent-tabs-mode: t
+ * c-file-style: "stroustrup"
+ * End:
+ * ex: shiftwidth=4 tabstop=8
+ */
+
diff --git a/src/libqtcad/QtSW.cpp b/src/libqtcad/QtSW.cpp
index c8a11cc66d..0e4e16edd2 100644
--- a/src/libqtcad/QtSW.cpp
+++ b/src/libqtcad/QtSW.cpp
@@ -47,7 +47,8 @@ QtSW::QtSW(QWidget *parent, struct fb *fbp)
     // If we weren't supplied with a framebuffer, allocate one.
     // We don't open it until we have the dmp.
     if (!ifp) {
-	ifp = fb_raw("swrast");
+	//ifp = fb_raw("swrast");
+	ifp = fb_raw("tinygl");
 	fb_set_standalone(ifp, 0);
     }
 
@@ -90,7 +91,8 @@ void QtSW::paintEvent(QPaintEvent *e)
 
 	    // Do the standard libdm attach to get our rendering backend.
 	    const char *acmd = "attach";
-	    dmp = dm_open((void *)v, NULL, "swrast", 1, &acmd);
+	    //dmp = dm_open((void *)v, NULL, "swrast", 1, &acmd);
+	    dmp = dm_open((void *)v, NULL, "tinygl", 1, &acmd);
 	    if (!dmp)
 		return;
 
diff --git a/src/other/CMakeLists.txt b/src/other/CMakeLists.txt
index 22443bafaf..f2f69305f9 100644
--- a/src/other/CMakeLists.txt
+++ b/src/other/CMakeLists.txt
@@ -189,6 +189,22 @@ mark_as_advanced(OSMESA_INCLUDE_DIRS)
 include("${CMAKE_CURRENT_SOURCE_DIR}/libosmesa.dist")
 CMAKEFILES_IN_DIR(libosmesa_ignore_files libosmesa)
 
+# TINYGL Library
+add_subdirectory(tinygl)
+SetTargetFolder(tinygl "Third Party Libraries")
+SetTargetFolder(tinygl-static "Third Party Libraries")
+SetTargetFolder(tinygl-obj "Third Party Libraries")
+set(TINYGL_LIBRARY tinygl CACHE STRING "Require opennurbs libraries" FORCE)
+set(TINYGL_LIBRARIES tinygl CACHE STRING "Require opennurbs libraries" FORCE)
+set(TINYGL_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/tinygl/include" CACHE STRING "Require tinygl header includes" FORCE)
+set(TINYGL_INCLUDE_DIRS "${BRLCAD_SOURCE_DIR}/src/other/tinygl/include" CACHE STRING "Require tinygl header includes" FORCE)
+mark_as_advanced(TINYGL_LIBRARY)
+mark_as_advanced(TINYGL_LIBRARIES)
+mark_as_advanced(TINYGL_INCLUDE_DIR)
+mark_as_advanced(TINYGL_INCLUDE_DIRS)
+include("${CMAKE_CURRENT_SOURCE_DIR}/tinygl.dist")
+CMAKEFILES_IN_DIR(tinygl_ignore_files tinygl)
+
 # linenoise is used by applications directly
 include(${CMAKE_CURRENT_SOURCE_DIR}/linenoise.dist)
 CMAKEFILES_IN_DIR(linenoise_ignore_files linenoise)
diff --git a/src/other/libosmesa/CMakeLists.txt b/src/other/libosmesa/CMakeLists.txt
index b2033b03c1..eee79012b0 100644
--- a/src/other/libosmesa/CMakeLists.txt
+++ b/src/other/libosmesa/CMakeLists.txt
@@ -48,7 +48,7 @@ add_definitions(-DHAVE_TIMESPEC_GET=1)
 add_definitions(-DUSE_MGL_NAMESPACE)
 
 add_subdirectory(src)
-#add_subdirectory(examples)
+add_subdirectory(examples)
 
 # Local Variables:
 # tab-width: 8
diff --git a/src/other/libosmesa/src/CMakeLists.txt b/src/other/libosmesa/src/CMakeLists.txt
index 7f168df245..8a6ffb167e 100644
--- a/src/other/libosmesa/src/CMakeLists.txt
+++ b/src/other/libosmesa/src/CMakeLists.txt
@@ -11,10 +11,10 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/shader/slang
   ${CMAKE_CURRENT_SOURCE_DIR}/x86-64
   ${CMAKE_CURRENT_SOURCE_DIR}/x86
-# ${CMAKE_CURRENT_SOURCE_DIR}/glu/include
-# ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/internals
-# ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/interface
-# ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/nurbtess
+  ${CMAKE_CURRENT_SOURCE_DIR}/glu/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/internals
+  ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/interface
+  ${CMAKE_CURRENT_SOURCE_DIR}/glu/libnurbs/nurbtess
   ${CMAKE_CURRENT_SOURCE_DIR}
   )
 
@@ -294,8 +294,7 @@ set(glu_srcs
   glu/libnurbs/nurbtess/searchTree.cc
   )
 
-#add_library(osmesa SHARED ${osmesa_srcs} ${glu_srcs})
-add_library(osmesa SHARED ${osmesa_srcs})
+add_library(osmesa SHARED ${osmesa_srcs} ${glu_srcs})
 install(TARGETS osmesa
   RUNTIME DESTINATION ${BIN_DIR}
   LIBRARY DESTINATION ${LIB_DIR}
diff --git a/src/other/libosmesa/src/glapi/dispatch.h b/src/other/libosmesa/src/glapi/dispatch.h
index f0ef0707b4..d073f4a5ea 100644
--- a/src/other/libosmesa/src/glapi/dispatch.h
+++ b/src/other/libosmesa/src/glapi/dispatch.h
@@ -1,3 +1,5 @@
+/* DO NOT EDIT - This file generated automatically by gl_table.py (from Mesa) script */
+
 /*
  * (C) Copyright IBM Corporation 2005
  * All Rights Reserved.
@@ -38,7 +40,7 @@
  */
 
 #define CALL_by_offset(disp, cast, offset, parameters) \
-    if (offset >= 0) (*(cast (GET_by_offset(disp, offset))))(parameters)
+    (*(cast (GET_by_offset(disp, offset)))) parameters
 #define GET_by_offset(disp, offset) \
     (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL
 #define SET_by_offset(disp, offset, fn) \
diff --git a/src/other/libosmesa/src/main/api_arrayelt.c b/src/other/libosmesa/src/main/api_arrayelt.c
index 8b7f574dcd..1899975213 100644
--- a/src/other/libosmesa/src/main/api_arrayelt.c
+++ b/src/other/libosmesa/src/main/api_arrayelt.c
@@ -1286,7 +1286,8 @@ void GLAPIENTRY _ae_loopback_array_elt( GLint elt )
       const GLubyte *src
          = ADD_POINTERS(aa->array->BufferObj->Pointer, aa->array->Ptr)
          + elt * aa->array->StrideB;
-      CALL_by_offset( disp, (array_func), aa->offset, ((const void *) src) );
+      CALL_by_offset( disp, (array_func), aa->offset, 
+		      ((const void *) src) );
    }
 
    if (do_map)
diff --git a/src/other/libosmesa/src/main/dlist.c b/src/other/libosmesa/src/main/dlist.c
index d8ac0feb38..1b2f90ef91 100644
--- a/src/other/libosmesa/src/main/dlist.c
+++ b/src/other/libosmesa/src/main/dlist.c
@@ -725,15 +725,13 @@ _mesa_alloc_instruction(GLcontext *ctx, GLuint opcode, GLuint bytes)
       /* This block is full.  Allocate a new block and chain to it */
       Node *newblock;
       n = ctx->ListState.CurrentBlock + ctx->ListState.CurrentPos;
-      if (n) {
-         n[0].opcode = OPCODE_CONTINUE;
-         newblock = (Node *) _mesa_malloc(sizeof(Node) * BLOCK_SIZE);
-         if (!newblock) {
-            _mesa_error(ctx, GL_OUT_OF_MEMORY, "Building display list");
-            return NULL;
-         }
-         n[1].next = (Node *) newblock;
+      n[0].opcode = OPCODE_CONTINUE;
+      newblock = (Node *) _mesa_malloc(sizeof(Node) * BLOCK_SIZE);
+      if (!newblock) {
+         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Building display list");
+         return NULL;
       }
+      n[1].next = (Node *) newblock;
       ctx->ListState.CurrentBlock = newblock;
       ctx->ListState.CurrentPos = 0;
    }
@@ -741,13 +739,9 @@ _mesa_alloc_instruction(GLcontext *ctx, GLuint opcode, GLuint bytes)
    n = ctx->ListState.CurrentBlock + ctx->ListState.CurrentPos;
    ctx->ListState.CurrentPos += numNodes;
 
-   if (n) {
-      n[0].opcode = (OpCode) opcode;
-
-      return (void *) (n + 1);     /* return ptr to node following opcode */
-   }
+   n[0].opcode = (OpCode) opcode;
 
-   return NULL;
+   return (void *) (n + 1);     /* return ptr to node following opcode */
 }
 
 
diff --git a/src/other/libosmesa/src/main/fbobject.c b/src/other/libosmesa/src/main/fbobject.c
index 8a98747cc1..c5ca56b2dc 100644
--- a/src/other/libosmesa/src/main/fbobject.c
+++ b/src/other/libosmesa/src/main/fbobject.c
@@ -1545,9 +1545,13 @@ _mesa_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
       _mesa_update_state(ctx);
    }
 
+   if (!ctx->ReadBuffer) {
+      /* XXX */
+   }
+
    /* check for complete framebuffers */
-   if (!ctx->DrawBuffer || ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT ||
-       !ctx->ReadBuffer || ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT ||
+       ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
       _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                   "glBlitFramebufferEXT(incomplete draw/read buffers)");
       return;
diff --git a/src/other/libosmesa/src/main/framebuffer.c b/src/other/libosmesa/src/main/framebuffer.c
index caf20359b1..8aeb369508 100644
--- a/src/other/libosmesa/src/main/framebuffer.c
+++ b/src/other/libosmesa/src/main/framebuffer.c
@@ -472,20 +472,26 @@ _mesa_update_framebuffer_visual(struct gl_framebuffer *fb)
 
    if (fb->Attachment[BUFFER_DEPTH].Renderbuffer) {
       fb->Visual.haveDepthBuffer = GL_TRUE;
-      fb->Visual.depthBits = fb->Attachment[BUFFER_DEPTH].Renderbuffer->DepthBits;
+      fb->Visual.depthBits
+         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->DepthBits;
    }
 
    if (fb->Attachment[BUFFER_STENCIL].Renderbuffer) {
       fb->Visual.haveStencilBuffer = GL_TRUE;
-      fb->Visual.stencilBits = fb->Attachment[BUFFER_STENCIL].Renderbuffer->StencilBits;
+      fb->Visual.stencilBits
+         = fb->Attachment[BUFFER_STENCIL].Renderbuffer->StencilBits;
    }
 
    if (fb->Attachment[BUFFER_ACCUM].Renderbuffer) {
       fb->Visual.haveAccumBuffer = GL_TRUE;
-      fb->Visual.accumRedBits = fb->Attachment[BUFFER_ACCUM].Renderbuffer->RedBits;
-      fb->Visual.accumGreenBits = fb->Attachment[BUFFER_ACCUM].Renderbuffer->GreenBits;
-      fb->Visual.accumBlueBits = fb->Attachment[BUFFER_ACCUM].Renderbuffer->BlueBits;
-      fb->Visual.accumAlphaBits = fb->Attachment[BUFFER_ACCUM].Renderbuffer->AlphaBits;
+      fb->Visual.accumRedBits
+         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->RedBits;
+      fb->Visual.accumGreenBits
+         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->GreenBits;
+      fb->Visual.accumBlueBits
+         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->BlueBits;
+      fb->Visual.accumAlphaBits
+         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->AlphaBits;
    }
 
    compute_depth_max(fb);
diff --git a/src/other/libosmesa/src/main/texcompress_s3tc.c b/src/other/libosmesa/src/main/texcompress_s3tc.c
index 9240e5e3cd..4f329cdf59 100644
--- a/src/other/libosmesa/src/main/texcompress_s3tc.c
+++ b/src/other/libosmesa/src/main/texcompress_s3tc.c
@@ -468,7 +468,7 @@ fetch_texel_2d_f_rgb_dxt1( const struct gl_texture_image *texImage,
 }
 
 
-static int
+static void
 fetch_texel_2d_rgba_dxt1( const struct gl_texture_image *texImage,
                           GLint i, GLint j, GLint k, GLchan *texel )
 {
@@ -476,10 +476,9 @@ fetch_texel_2d_rgba_dxt1( const struct gl_texture_image *texImage,
    if (fetch_ext_rgba_dxt1) {
       fetch_ext_rgba_dxt1(texImage->RowStride,
                           (GLubyte *)(texImage)->Data, i, j, texel);
-      return 0;
    }
-   _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
-   return -1;
+   else
+      _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
 }
 
 
@@ -489,8 +488,7 @@ fetch_texel_2d_f_rgba_dxt1( const struct gl_texture_image *texImage,
 {
    /* just sample as GLchan and convert to float here */
    GLchan rgba[4];
-   if (fetch_texel_2d_rgba_dxt1(texImage, i, j, k, rgba))
-      return;
+   fetch_texel_2d_rgba_dxt1(texImage, i, j, k, rgba);
    texel[RCOMP] = CHAN_TO_FLOAT(rgba[RCOMP]);
    texel[GCOMP] = CHAN_TO_FLOAT(rgba[GCOMP]);
    texel[BCOMP] = CHAN_TO_FLOAT(rgba[BCOMP]);
diff --git a/src/other/libosmesa/src/main/texrender.c b/src/other/libosmesa/src/main/texrender.c
index 0b1ab84f58..f738584512 100644
--- a/src/other/libosmesa/src/main/texrender.c
+++ b/src/other/libosmesa/src/main/texrender.c
@@ -297,7 +297,7 @@ delete_texture_wrapper(struct gl_renderbuffer *rb)
  * The new renderbuffer is plugged into the given attachment point.
  * This allows rendering into the texture as if it were a renderbuffer.
  */
-static int
+static void
 wrap_texture(GLcontext *ctx, struct gl_renderbuffer_attachment *att)
 {
    struct texture_renderbuffer *trb;
@@ -309,7 +309,7 @@ wrap_texture(GLcontext *ctx, struct gl_renderbuffer_attachment *att)
    trb = CALLOC_STRUCT(texture_renderbuffer);
    if (!trb) {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "wrap_texture");
-      return -1;
+      return;
    }
 
    /* init base gl_renderbuffer fields */
@@ -326,8 +326,6 @@ wrap_texture(GLcontext *ctx, struct gl_renderbuffer_attachment *att)
 
    /* update attachment point */
    _mesa_reference_renderbuffer(&att->Renderbuffer, &(trb->Base));
-
-   return 0;
 }
 
 
@@ -414,15 +412,12 @@ _mesa_render_texture(GLcontext *ctx,
                      struct gl_framebuffer *fb,
                      struct gl_renderbuffer_attachment *att)
 {
-   int err_check = 0;
    (void) fb;
 
    if (!att->Renderbuffer) {
-      err_check = wrap_texture(ctx, att);
-   }
-   if (!err_check) {
-      update_wrapper(ctx, att);
+      wrap_texture(ctx, att);
    }
+   update_wrapper(ctx, att);
 }
 
 
diff --git a/src/other/libosmesa/src/shader/atifragshader.c b/src/other/libosmesa/src/shader/atifragshader.c
index 498e576382..854c911874 100644
--- a/src/other/libosmesa/src/shader/atifragshader.c
+++ b/src/other/libosmesa/src/shader/atifragshader.c
@@ -290,11 +290,9 @@ _mesa_DeleteFragmentShaderATI(GLuint id)
 
       /* The ID is immediately available for re-use now */
       _mesa_HashRemove(ctx->Shared->ATIShaders, id);
-      if (prog) {
-         prog->RefCount--;
-         if (prog->RefCount <= 0) {
-            _mesa_free(prog);
-         }
+      prog->RefCount--;
+      if (prog->RefCount <= 0) {
+         _mesa_free(prog);
       }
    }
 }
diff --git a/src/other/libosmesa/src/shader/slang/slang_compile.c b/src/other/libosmesa/src/shader/slang/slang_compile.c
index 7f45ec6f35..cb3e5e1e0f 100644
--- a/src/other/libosmesa/src/shader/slang/slang_compile.c
+++ b/src/other/libosmesa/src/shader/slang/slang_compile.c
@@ -1182,10 +1182,8 @@ parse_expression(slang_parse_ctx * C, slang_output_ctx * O,
    C->I++;
 
    slang_operation_destruct(oper);
-   if (ops) {
-      *oper = *ops; /* struct copy */
-      _slang_free(ops);
-   }
+   *oper = *ops; /* struct copy */
+   _slang_free(ops);
 
    return 1;
 }
diff --git a/src/other/libosmesa/src/shader/slang/slang_link.c b/src/other/libosmesa/src/shader/slang/slang_link.c
index d7c263bae1..d4c934bab8 100644
--- a/src/other/libosmesa/src/shader/slang/slang_link.c
+++ b/src/other/libosmesa/src/shader/slang/slang_link.c
@@ -63,8 +63,6 @@ link_varying_vars(struct gl_shader_program *shProg, struct gl_program *prog)
          /* already in list, check size */
          if (var->Size != shProg->Varying->Parameters[j].Size) {
             /* error */
-	    if (map)
-	       free(map);
             return GL_FALSE;
          }
       }
@@ -211,8 +209,6 @@ link_uniform_vars(struct gl_shader_program *shProg, struct gl_program *prog)
             break;
          default:
             _mesa_problem(NULL, "bad parameter type in link_uniform_vars()");
-	    if (map)
-	       free(map);
             return GL_FALSE;
          }
       }
diff --git a/src/other/libosmesa/src/swrast/s_depth.c b/src/other/libosmesa/src/swrast/s_depth.c
index b8623b1949..408174c990 100644
--- a/src/other/libosmesa/src/swrast/s_depth.c
+++ b/src/other/libosmesa/src/swrast/s_depth.c
@@ -1211,7 +1211,6 @@ _swrast_read_depth_span_float( GLcontext *ctx, struct gl_renderbuffer *rb,
    if (!rb) {
       /* really only doing this to prevent FP exceptions later */
       _mesa_bzero(depth, n * sizeof(GLfloat));
-      return;
    }
 
    ASSERT(rb->_BaseFormat == GL_DEPTH_COMPONENT);
@@ -1275,7 +1274,6 @@ _swrast_read_depth_span_uint( GLcontext *ctx, struct gl_renderbuffer *rb,
    if (!rb) {
       /* really only doing this to prevent FP exceptions later */
       _mesa_bzero(depth, n * sizeof(GLfloat));
-      return;
    }
 
    ASSERT(rb->_BaseFormat == GL_DEPTH_COMPONENT);
diff --git a/src/other/libosmesa/src/swrast/s_triangle.c b/src/other/libosmesa/src/swrast/s_triangle.c
index d56bab4dcf..fc40084beb 100644
--- a/src/other/libosmesa/src/swrast/s_triangle.c
+++ b/src/other/libosmesa/src/swrast/s_triangle.c
@@ -1060,7 +1060,7 @@ _swrast_choose_triangle( GLcontext *ctx )
          envMode = ctx->Texture.Unit[0].EnvMode;
 
          /* First see if we can use an optimized 2-D texture function */
-         if (texImg && texObj2D && ctx->Texture._EnabledCoordUnits == 0x1
+         if (ctx->Texture._EnabledCoordUnits == 0x1
              && !ctx->FragmentProgram._Current
              && !ctx->ATIFragmentShader._Enabled
              && ctx->Texture.Unit[0]._ReallyEnabled == TEXTURE_2D_BIT
diff --git a/src/other/libosmesa/src/tnl/t_context.c b/src/other/libosmesa/src/tnl/t_context.c
index 67eff2917a..3017c73cf1 100644
--- a/src/other/libosmesa/src/tnl/t_context.c
+++ b/src/other/libosmesa/src/tnl/t_context.c
@@ -137,11 +137,10 @@ _tnl_InvalidateState( GLcontext *ctx, GLuint new_state )
       RENDERINPUTS_SET( tnl->render_inputs_bitset, _TNL_ATTRIB_COLOR_INDEX );
    }
 
-   if (ctx->Fog.Enabled || ctx->FragmentProgram._Active ||
-       (ctx->FragmentProgram._Current &&
+   if (ctx->Fog.Enabled ||
+       ((ctx->FragmentProgram._Active || ctx->FragmentProgram._Current) &&
         (ctx->FragmentProgram._Current->FogOption != GL_NONE ||
-         (ctx->FragmentProgram._Current->Base.InputsRead & FRAG_BIT_FOGC)))
-       )
+         (ctx->FragmentProgram._Current->Base.InputsRead & FRAG_BIT_FOGC))))
       RENDERINPUTS_SET( tnl->render_inputs_bitset, _TNL_ATTRIB_FOG );
 
    if (ctx->Polygon.FrontMode != GL_FILL || 
diff --git a/src/other/tinygl.dist b/src/other/tinygl.dist
new file mode 100644
index 0000000000..08434a3996
--- /dev/null
+++ b/src/other/tinygl.dist
@@ -0,0 +1,106 @@
+set(tinygl_ignore_files
+CMakeLists.txt
+INTEGRATION
+LICENSE
+LIMITATIONS
+Makefile
+README.md
+Raw_Demos/CMakeLists.txt
+Raw_Demos/Makefile
+Raw_Demos/asciifractal.sh
+Raw_Demos/bigfont.c
+Raw_Demos/char.txt
+Raw_Demos/gears.c
+Raw_Demos/t2i.c
+SDL_Examples/.clang-format
+SDL_Examples/Arnepalette.png
+SDL_Examples/CMakeLists.txt
+SDL_Examples/Makefile
+SDL_Examples/WWGW.mp3
+SDL_Examples/code_format.sh
+SDL_Examples/extrude.obj
+SDL_Examples/game.c
+SDL_Examples/gears.c
+SDL_Examples/helloworld.c
+SDL_Examples/menu.c
+SDL_Examples/model.c
+SDL_Examples/monkey3.obj
+SDL_Examples/quick.sh
+SDL_Examples/tex.jpg
+SDL_Examples/tex_hole.png
+SDL_Examples/tex_old.jpg
+SDL_Examples/texture.c
+SDL_Examples/texture.png
+config.mk
+doc/blend.gif
+doc/capture.gif
+doc/capture2.gif
+doc/helloworld.gif
+doc/menu.gif
+doc/model.gif
+doc/model2.gif
+doc/model2_lit.gif
+doc/model_hole.gif
+doc/model_lit.gif
+doc/specular.gif
+doc/texture_test.png
+include-demo/3dMath.h
+include-demo/api_audio.h
+include-demo/chade.h
+include-demo/chadphys.h
+include-demo/lockstepthread.h
+include-demo/openimgui.h
+include-demo/resweep.h
+include-demo/stb_ds.h
+include-demo/stb_image.h
+include-demo/stb_image_write.h
+include-demo/stringutil.h
+include-demo/tobjparse.h
+include/CMakeLists.txt
+include/TGL/gl.h
+include/zbuffer.h
+include/zfeatures.h
+lib/keep_alive.txt
+src/.clang-format
+src/CMakeLists.txt
+src/LICENSE
+src/Makefile
+src/Makefile_Backup
+src/accum.c
+src/api.c
+src/arrays.c
+src/clear.c
+src/clip.c
+src/code_format.sh
+src/error_check.h
+src/error_check_no_context.h
+src/font8x8_basic.h
+src/get.c
+src/image_util.c
+src/init.c
+src/light.c
+src/list.c
+src/matrix.c
+src/memory.c
+src/misc.c
+src/msghandling.c
+src/msghandling.h
+src/opinfo.h
+src/quick.sh
+src/select.c
+src/specbuf.c
+src/texture.c
+src/vertex.c
+src/zbuffer.c
+src/zgl.h
+src/zline.c
+src/zline.h
+src/zmath.c
+src/zmath.h
+src/zpostprocess.c
+src/zraster.c
+src/ztext.c
+src/ztriangle.c
+src/ztriangle.h
+tgl_minimal.png
+)
diff --git a/src/other/tinygl/CMakeLists.txt b/src/other/tinygl/CMakeLists.txt
new file mode 100644
index 0000000000..3d21734fae
--- /dev/null
+++ b/src/other/tinygl/CMakeLists.txt
@@ -0,0 +1,60 @@
+cmake_minimum_required(VERSION 3.12)
+project(tinygl
+  DESCRIPTION "tinygl: The ultimate portable graphics library"
+  HOMEPAGE_URL "https://github.com/C-Chads/tinygl"
+  LANGUAGES C
+  )
+
+set(CMAKE_C_STANDARD 99)
+set(CMAKE_C_STANDARD_REQUIRED ON)
+set(CMAKE_C_EXTENSIONS OFF)
+
+# Set relative output directory paths, if not already defined
+if (NOT BIN_DIR)
+  set(BIN_DIR bin)
+endif (NOT BIN_DIR)
+if (NOT INCLUDE_DIR)
+  set(INCLUDE_DIR include)
+endif (NOT INCLUDE_DIR)
+if (NOT DEFINED LIB_DIR)
+  set(LIB_DIR lib)
+endif (NOT DEFINED LIB_DIR)
+
+# Check for a math library
+include(CheckLibraryExists)
+check_library_exists(m cos "" HAVE_M_LIBRARY)
+if (HAVE_M_LIBRARY)
+  set(M_LIBRARY m)
+endif (HAVE_M_LIBRARY)
+
+# Options
+option(TINYGL_BUILD_EXAMPLES "Build Examples" OFF)
+option(TINYGL_BUILD_SHARED "Build Shared Library" ON)
+option(TINYGL_BUILD_STATIC "Build Static Library" ON)
+
+# Build main library
+add_subdirectory(src)
+
+# Install logic for headers
+add_subdirectory(include)
+
+# Examples
+if(TINYGL_BUILD_EXAMPLES)
+
+  # These deliberately do not depend on SDL.  TODO - these could be used to
+  # drive a "make test" system to check the correct functioning of the library
+  # after compilation...
+  add_subdirectory(Raw_Demos)
+
+  # Examples that use SDL for interactive display
+  add_subdirectory(SDL_Examples)
+
+endif()
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
+
diff --git a/src/other/tinygl/LICENSE b/src/other/tinygl/LICENSE
new file mode 100644
index 0000000000..75858ca60b
--- /dev/null
+++ b/src/other/tinygl/LICENSE
@@ -0,0 +1,32 @@
+Copyright notice:
+
+ (C) 1997-2021 Fabrice Bellard, Gek (DMHSW), C-Chads
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product and its documentation 
+     *is* required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+If you redistribute modified sources, I would appreciate that you
+include in the files history information documenting your changes.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+For the SDL Examples.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+
+This program uses SDL 1.2, which is licensed under the GNU Lesser General Public Library, version 2.1.
+You can find a copy of this license at https://www.gnu.org/licenses/lgpl-2.1.en.html
diff --git a/src/other/tinygl/README.md b/src/other/tinygl/README.md
new file mode 100644
index 0000000000..6ce9831753
--- /dev/null
+++ b/src/other/tinygl/README.md
@@ -0,0 +1,679 @@
+# TinyGL
+
+![tgl logo](tgl_minimal.png)
+A major overhaul of Fabrice Bellard's TinyGL to be
+more useful as a software rasterizer.
+
+Now with limited multithreading support
+
+## Tightly tweaked and tuned for performance
+
+The library has been tightly tuned using valgrind, perf stat, and other tools.
+
+On a single thread on an i7-6700 (Skylake, 2015),
+the standard "gears" demo runs at a higher framerate than glxgears on Mesa using a Ryzen 3900x (2019)
+(NOTE: TinyGL Compared without SDL overhead)
+
+I think I can safely say, this is the fastest single-threaded FOSS software GL implementation in existence.
+
+It's probably also the most portable
+
+## Safety features
+
+TinyGL contains the following safety features:
+
+1. compiletime options for glGetError() functionality which obviously slows down speed but increases debugging capability.
+
+2. OpenGL 2.0 buffers, for easy memory management (Anything you put in a buffer using glBufferData will be free'd upon glClose())
+
+3. Fully leak checked using Valgrind- The only leaks you'll see are from your system's SDL. the Raw demos have zero leaks.
+
+## Incredibly portable
+
+TinyGL is written in pure C99, and requires very few functions from the C standard library, it doesn't even require malloc and free
+(The calls are aliased to gl_malloc() and gl_free(), which you can replace with your own memory management model if you desire)
+
+## How portable?
+
+* TinyGL still compiles under bellard's Tiny C Compiler.
+
+The SDL examples are now confirmed building with TCC, using TinyCC built from the latest source.
+
+* TinyGL has been compiled for the Nintendo 3DS (proof of concept in another repository)
+
+You can test compiling TinyGL and running it on platforms without SDL by running the RAW DEMOS, which do not require ANYTHING
+Except the C standard library and stdio. You may have to change the destination written to by the raw demos on platforms
+without standard file systems.
+
+These are the C standard library includes used in the RAW DEMOS.
+
+```c
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+```
+If your system supports it, the library can also take advantage of `alignas` to get improved SIMD support,
+which can be disabled in zfeatures. This adds a dependency to `stdalign.h` but greatly increases vertex processing speed.
+
+(This is disabled by default for maximum portability)
+
+If you are unsure if your target platform can support TinyGL, compile it with the buildtime and runtime tests enabled (They are, by default)
+
+if you get a TGL_BUILDT error, then you've failed the buildtime test.
+
+if you try to initialize the library and you get a crash with a print to standard out "TINYGL_FAILED_RUNTIME_COMPAT_TEST" then you've failed the runtime test.
+
+The SDL examples have been tested building on Debian 10 and Windows 10, while tinygl itself has been confirmed to compile on many more platforms.
+
+## Includes a small SIMD-accelerated public domain replacement for GLU
+the "Chad Math Library" has been included (CC0, public domain) for your programming needs.
+
+it is simd accelerated on supported platforms, but it contains ZERO platform-specific code- it relies on an optimizing
+compiler to get vectorized ops. SIMD acceleration is improved by enabling alignas.
+
+NOTE: There are graphical artifacts visible in these gifs which have been corrected in this version of the library.
+
+
+
+Without Polygon Stipple:
+
+![GIF Video of demo](doc/capture.gif)
+
+With Polygon Stipple:
+
+![GIF Video of demo](doc/capture2.gif)
+
+Hello World test:
+
+![model loading demo](doc/helloworld.gif)
+
+Texturing Test: 
+
+![Screenshot of Texture test](doc/texture_test.png)
+
+Model loading tests:
+
+![model loading demo](doc/model2_lit.gif)
+
+![model loading demo](doc/model_lit.gif)
+
+Without lighting: 
+
+![model loading demo](doc/model2.gif)
+
+![model loading demo](doc/model.gif)
+
+This is a demo of the NO_DRAW_COLOR feature. Notice that the object appears to have a hole in it.
+
+![model loading demo](doc/model_hole.gif)
+
+Blending:
+
+![model loading demo](doc/blend.gif)
+
+Specular:
+
+![GIF Video of demo](doc/specular.gif)
+
+OpenIMGUI standard demo:
+
+![OpenIMGUI](doc/menu.gif)
+
+TinyGL 0.8 (c) 1997-2021 Fabrice Bellard, C-Chads, Gek (see License, it's free software)
+
+This is a maintained fork of TinyGL, by the C-Chads.
+It is a small, suckless Software-only partial GL 1.1 implementation.
+
+The original project was by Fabrice Bellard. We have forked it.
+
+The changelog is as such:
+
+* Disabled 8, 15, and 24 bit rendering modes. 16 and 32 are the only supported rendering modes (Coincidentally, they are also the fastest)
+
+* Allowed the fixed texture size to be changed at compile time. It must be a power of 2, but that is the only limitation.
+
+* Removed the entire GLX/NanoGLX part of the library. Not portable and mostly useless.
+
+* Implemented new functions and some more of GL 1.1's prototypes including polygon stipple.
+
+* Triangles can now be lit and textured at the same time!
+
+* Removed unused functions which bloat binary size and lengthen compile times.
+
+* Added support for glDepthMask and glDisable(GL_DEPTH_TEST) as per-GL-spec
+
+* ADDED BLENDING SUPPORT!
+
+* Added glDrawPixels
+
+* Added glPixelZoom
+
+* Added glRasterPos2f,3f,4f,2fv,3fv,4fv
+
+* Added glGetString() for GL_VENDOR, GL_RENDERER, GL_VERSION, and optionally GL_LICENSE
+
+* Added comprehensive, usable glGetError() functionality for debugging.
+
+* Fixed a myriad of bugs and... weirdnesses
+
+* Fixed clientside arrays
+
+* Tuned the triangle rasterizer to near-perfection.
+
+* Tuned the transformations to absolute perfection
+
+* Added glDrawArrays
+
+* Added Buffers (For memory management purposes)
+
+* Added glTexImage1D (... it just resizes it to 2D, but it works!)
+
+* Added glPixelSize (TODO is to implement distance scaling)
+
+* Fixed specular rendering
+
+* Added way more compile time options
+
+* Fixed all the memory leaks.
+
+* added Openmp multithreading and glPostProcess()
+
+* Line rendering now obeys glDepthMask and glDepthTest.
+
+* Implemented glRectf
+
+* Implemented compiletime toggles for GL_SELECT and GL_FEEDBACK which significantly
+boosts performance. Also, implemented GL_FEEDBACK.
+
+* Accept PR from RobLoach to add Cmake support
+
+
+
+Note that this Softrast **is not GL 1.1 compliant** and does not constitute a complete GL implementation.
+
+You *will* have to tweak your code to work with this library. That said, once you have, it will run anywhere that you can get
+C99. TinyGL has very few external dependencies.
+
+
+Notable limitations:
+
+* The only supported texture size and format is decided at compile time. you can set it in zfeatures.h
+
+* A lot of prototypes are missing.
+
+* glPolygonOffset doesn't change anything about how rendering occurs. It does nothing, at the moment. 
+The "implementation specific multiplier" is 0.
+
+* There is no stencil buffer.
+
+* Blending can't use alpha values. the rasterizer has no concept of alpha.
+
+* There is no mipmapping, antialiasing, or any form of texture filtering.
+
+* No edge clamping. S and T are wrapped.
+
+* Display lists can be infinitely nested and doing so will crash TinyGL.
+
+* Lit triangles will use the current material properties, even if they are textured. If the diffuse color is black, then your
+textured triangles will appear black.
+
+* Textured triangles are affected by their vertex colors- the per-vertex color is used as a "mask" for the texture
+on triangles. It is recommended you call glColor3f(1,1,1); before rendering a textured object to get the expected result-
+you only need to make this call once, and it can be before glBegin.
+
+* the X dimension of the rendering window with must be a multiple of 4.
+
+* Line rendering is not blended
+
+* The ARB extension for point sprite size attenuation is not enabled.
+
+* Point smoothing is not implemented, points are always squares of a solid color.
+
+* glCopyTexImage2D only works with the size of texture you decided at compile time.
+
+* <Undocumented limitations that have not been tested>
+
+### HOW DO I USE THIS LIBRARY???
+
+TinyGL is not header only, it is a combination of C files, internal headers, and external headers.
+
+The internal headers are only used while compiling the library,
+
+the external headers (gl.h, zfeatures.h, zbuffer.h) are required to use the library.
+
+You CAN compile the library along with your final program into a single compilation unit without separating out the library.
+
+Doing so is the most likely compiling method for embedded platforms and how I got TinyGL running on the 3DS.
+
+The codebase uses very simple compiler flags to compile- in fact it will compile if you just compile all c files together
+
+in the src/ directory.
+
+You can compile the code yourself without makefiles using these directives:
+
+```sh
+# inside the src directory
+gcc -O3 -c *.c 
+ar rcs libTinyGL.a *.o
+# the library is now compiled
+cp libTinyGL.a ../lib
+cd ..
+cd SDL_Examples/
+# build the menu demo
+gcc -O3 menu.c -o menu -lSDL ../lib/libTinyGL.a -lm
+# gears
+gcc -O3 gears.c -o gears -lSDL ../lib/libTinyGL.a -lm
+```
+
+This is how you use TinyGL in a program:
+
+```c
+//First you have to include
+//(Note that you must either link against libTinyGL.a or compile it in the same compilation unit as your program)
+#include "../include/GL/gl.h"
+#include "../include/zbuffer.h"
+
+/*
+	Somewhere in your program...
+*/
+
+//Next, open a framebuffer.
+//The "0" parameter is where you pass in a framebuffer pointer if you've already made one.
+ZBuffer* frameBuffer = ZB_open(winSizeX, winSizeY, mode, 0);
+
+//Tell TinyGL to initialize on that framebuffer
+glInit(frameBuffer);
+
+//Begin making TinyGL calls!
+
+//When you want to copy to your target screen
+//Pitch is the width of the target in bytes, or bytes per pixel times width;
+ZB_copyFrameBuffer(frameBuffer, screen->pixels, screen->pitch);
+
+
+
+
+//At the end of your application, when you want to clean up.
+ZB_close(frameBuffer);
+glClose();
+
+```
+
+Note that while you... *can* invoke ZB_Resize to resize the framebuffer, you really shouldn't. It isn't tested.
+
+### WHAT ARE THE MINIMUM REQUIREMENTS OF THIS LIBRARY?
+
+SDL 1.2 is required to run most of the demos I've written, but if you don't have SDL you can still check out the library
+by compiling one of the "Raw Demos" which write their output to a file (At the time of writing this, only gears has been added.)
+
+SDL is by no means required to compile or use this library.
+SDL is used as a reasonable means of displaying the output of TinyGL for testing.
+
+(I also included some bonus libraries that work well with SDL in the SDL examples if you want to write games using TinyGL!)
+(Try compiling the demos with -D PLAY_MUSIC if you have mixer!)
+* A c99 compiler
+* 32 bit signed and unsigned integer types
+* 32 bit binary float type (STDC_IEC_559)
+* Some floating point type at least as large as a 32 bit float
+* sin and cos functions in math.h
+* memcpy in string.h
+* assert in assert.h (for debugging only, it can be stubbed)
+* a minimal C stdlib
+* A memory allocator of some sort with some equivalents or replacements for malloc, calloc, and free.
+
+There is no FILE* usage, or I/O outside of 'msghandling.c' so if you want to remove all stdio dependency, just stub out the calls there.
+
+
+### Multithreading support
+
+OpenMP is used on supported platforms to multithread certain operations.
+
+(OpenMP is also used in the math library (zmath.h and zmath.c) to explicitly force certain operations
+to be SIMD accelerated, so it is recommended that you compile the library with OpenMP support!)
+
+
+These are the operations that are accelerated by multithreading:
+
+* glDrawPixels
+
+Every scanline is drawn by a separate thread.
+
+* glPostProcess
+
+Every call of the function pointer is run by a separate thread.
+
+* glCopyTexImage2D
+
+Every scan line is copied by a separate thread.
+
+* ZBCopyBuffer
+
+Every scan line is copied by a separate thread.
+
+Compile the library with -fopenmp to see them in action (default). They are used in the texture demo, make sure to add the argument `-pp`
+
+You do not need a multithreaded processor to use TinyGL!
+
+### Performance Recommendations
+
+```
+it is recommended that for best performance you keep TinyGL on a separate thread from SDL, and to guard TinyGL's buffer with a mutex.
+
+This is not done in the demos but you can test the... thickness of the SDL stack by invoking gears or helloworld with -nosdl
+
+The framerate doubles.
+```
+### NEW FUNCTIONS 
+
+These are functions not in the GL 1.1 spec that i've added to make this library more useful.
+
+These functions cannot be added as opcodes to display lists unless specifically listed.
+
+### glDeleteList
+
+An easier to use version of glDeleteLists. glDeleteLists is also implemented.
+
+### glSetEnableSpecular(int shouldenablespecular);
+
+This function can be added to display lists.
+
+Allows you to configure specular rendering. Turn it off
+if you want to use GL_LIGHTING but don't plan on using
+specular lighting. it will save cycles.
+
+### glGetTexturePixmap(int text, int level, int* xsize, int* ysize)
+
+Allows the user to retrieve the raw pixel data of a texture, for their own modification.
+
+### glDrawText(const unsigned char* text, int x, int y, unsigned int pixel)
+
+This function can be added to display lists as glPlotPixel calls, the text is not saved in a display list.
+
+Is capable of rendering the entire 8 bit latin extended character set (7 bit ascii plus characters 0xa0 and onward...)
+
+You can check how to embed non-standard characters in your strings in the gears demo.
+
+Draws a pre-made 8x8 font to the screen. You can change its displayed size with...
+
+### glTextSize(GLTEXTSIZE mode)
+
+This function can be added to display lists.
+
+Set size of text drawn to the buffer in aforementioned function.
+
+### glPlotPixel(int x, int y, unsigned int pixel)
+
+This function can be added to display lists.
+
+Plot pixel directly to the buffer.
+
+### glGenBuffers, glDeleteBuffers, glBindBuffer (valid target: ARRAY_BUFFER), glBindBufferAsArray
+
+Serverside buffers! Makes it a bit easier to do clientside array stuff at the moment. 
+may be the site of future hardware acceleration.
+
+Please look at the model.c demo to see how to use these functions. They function very similarly to their GL 2.0+ counterparts.
+
+### glPostProcess(GLuint (*postprocess)(GLint x, GLint y, GLuint pixel, GLushort z))
+
+Fast, Multithreaded Postprocessing for TinyGL. 
+
+You simply send in a function pointer (The function's name) and glPostProcess does the heavy lifting
+
+The return value is the pixel (ARGB or 5R6G5B depending on mode).
+
+x and y are the screen coordinataes.
+
+pixel is the current color value of the pixel, ARGB or 5R6G5B depending on mode.
+
+z is TinyGL's internal Z buffer representation. Larger values are considered to be "in front" of smaller ones.
+
+This function is multithreaded on supported platforms for maximum execution speed. It of course still works without multithreading, but
+
+it will not be as fast.
+
+Note that you may have to take special care to prevent race conditions when using multithreading with this function.
+
+### NEW glGet calls!!!
+
+You can query glGetIntegerV with these new definitions
+```c
+	GL_POLYGON_MAX_VERTEX = 0xf001,
+	GL_MAX_BUFFERS = 0xf002,
+	GL_TEXTURE_HASH_TABLE_SIZE = 0xf003,
+	GL_MAX_TEXTURE_LEVELS = 0xf004,
+	GL_MAX_SPECULAR_BUFFERS = 0xf005,
+	GL_MAX_DISPLAY_LISTS = 0xf006,
+	GL_ERROR_CHECK_LEVEL = 0xf007,
+	GL_IS_SPECULAR_ENABLED = 0xf008,
+```
+to query the configuration of TinyGL.
+
+## TOGGLEABLE FEATURES
+
+See `include/zfeatures.h`
+
+This changes too often to maintain documentation here.
+
+The compiletime test is now disabled by default since it may not be "liked" by some obscure compilers...
+you can enable it in GL/gl.h
+
+```c
+//at the top of include/GL/gl.h
+//Enable TinyGL's Compiletime Compatibility Test (Scroll down)
+#define COMPILETIME_TINYGL_COMPAT_TEST 1
+```
+
+## FIXED BUGS FROM THE ORIGINAL!
+
+TinyGL 0.4 by Bellard had incorrect color interpolation and issues with
+GL_FLAT, causing the hello world triangle to look rather...
+wrong. Additionally, per vertex color is just cool.
+
+The whole library was filled with memory leaks and read-past-by-one type errors, and they have been corrected.
+
+## Notorious bugs from the original that have been fixed
+
+* GLParam is a union of float, int, uint, and void* which is assumed to be 32 bit... but isn't on 64 bit systems
+
+* Per vertex color is broken due to a faulty optimization in clip.c
+
+* The conventions for 32 bit color were RGBA for textured triangles and ABGR for non-textured. Now both render as ARGB.
+
+* Little endian was assumed in a thousand places in the code
+
+* Non-normalized position was used for lights at infinity.
+
+* Lack of error checking functionality
+
+* Insert unknown bugs here.
+
+
+  
+## FULLY COMPATIBLE WITH RGBA!
+
+The library is now able to be configured properly for RGBA rendering. Note that the output *is actually ARGB* 
+but adjusting it is easy, see the SDL examples under SDL_EXAMPLES (They require SDL 1.2 and Mixer to compile)
+
+The library is sometimes by default configured for RGBA or 5R6G5B, check include/zfeatures.h and change the values in this table:
+```c
+#define TGL_FEATURE_8_BITS         0
+#define TGL_FEATURE_24_BITS        0
+//These are the only maintained modes.
+#define TGL_FEATURE_16_BITS        1
+#define TGL_FEATURE_32_BITS        0
+```
+
+make sure that only ONE of these values is 1.
+
+
+## ALSO COMPATIBLE WITH 16 BIT 
+
+Todo: add updated benchmarks
+
+
+### OpenIMGUI Standard
+
+TinyGL includes an implementation of the OpenIMGUI standard, visible in SDL_EXAMPLES/menu.c
+
+it is a standards proposal I've created for cross-platform immediate mode GUIs as a replacement
+for common solutions like "imgui" and Nuklear, which have glaring flaws when discussing their portability.
+
+Consider using it!
+
+_______________________________________________________________________________________
+
+# Here is the old description of TinyGL, saved for historical/attribution purposes:
+
+### I do not endorse or promote its contents, they are here for attribution only.
+
+### General Description:
+--------------------
+
+TinyGL is intended to be a very small implementation of a subset of
+OpenGL* for embedded systems or games. It is a software only
+implementation. Only the main OpenGL calls are implemented. All the
+calls I considered not important are simply *not implemented*.
+
+The main strength of TinyGL is that it is fast and simple because it
+has not to be exactly compatible with OpenGL. In particular, the
+texture mapping and the geometrical transformations are very fast.
+
+The main features of TinyGL are:
+
+- Header compatible with OpenGL (the headers are adapted from the very good
+Mesa by Brian Paul et al.)
+
+- Zlib-like licence for easy integration in commercial designs (read
+the LICENCE file).
+
+- Subset of GLX for easy testing with X Window. 
+
+- GLX like API (NGLX) to use it with NanoX in MicroWindows/NanoX.
+
+- Subset of BGLView under BeOS.
+
+- OpenGL like lightening.
+
+- Complete OpenGL selection mode handling for object picking.
+
+- 16 bit Z buffer. 16/24/32 bit RGB rendering. High speed dithering to
+paletted 8 bits if needed. High speed conversion to 24 bit packed
+pixel or 32 bit RGBA if needed.
+
+- Fast Gouraud shadding optimized for 16 bit RGB.
+
+- Fast texture mapping capabilities, with perspective correction and
+texture objects.
+
+- 32 bit float only arithmetic.
+
+- Very small: compiled code size of about 40 kB on x86. The file
+  src/zfeatures.h can be used to remove some unused features from
+  TinyGL.
+
+- C sources for GCC on 32/64 bit architectures. It has been tested
+succesfully on x86-Linux and sparc-Solaris.
+
+Examples:
+---------
+
+I took three simple examples from the Mesa package to test the main
+functions of TinyGL. You can link them to either TinyGL, Mesa or any
+other OpenGL/GLX implementation. You can also compile them with
+Microwindows.
+
+- texobj illustrates the use of texture objects. Its shows the speed
+of TinyGL in this case.
+
+- glutmech comes from the GLUT packages. It is much bigger and slower
+because it uses the lightening. I have just included some GLU
+functions and suppressed the GLUT related code to make it work. It
+shows the display list handling of TinyGL in particular. You can look
+at the source code to learn the keys to move the robot. The key 't'
+toggles between shaded rendering and wire frame.
+
+- You can download and compile the VReng project to see that TinyGL
+has been successfully used in a big project
+(http://www-inf.enst.fr/vreng).
+
+Architecture:
+-------------
+
+TinyGL is made up four main modules:
+
+- Mathematical routines (zmath).
+
+- OpenGL-like emulation (zgl).
+
+- Z buffer and rasterisation (zbuffer).
+
+- GLX interface (zglx).
+
+To use TinyGL in an embedded system, you should look at the GLX layer
+and modify it to suit your need. Adding a more user friendly
+developper layer (as in Mesa) may be useful.
+
+Notes - limitations:
+--------------------
+
+- See the file 'LIMITATIONS' to see the current functions supported by the API.
+
+- The multithreading could be easily implemented since no global state
+is maintainted. The library gets the current context with a function
+which can be modified.
+
+- The lightening is not very fast. I supposed that in most games the
+lightening is computed by the 3D engine.
+
+- Some changes are needed for 64 bit pointers for the handling of
+arrays of float with the GLParam union.
+
+- List sharing is partialy supported in the source, but not by the
+current TinyGLX implementation (is it really useful ?).
+
+- No user clipping planes are supported.
+
+- No color index mode (no longer useful !)
+
+- The mipmapping is not implemented.
+
+- The perspecture correction in the mapping code does not use W but
+1/Z. In any 'normal scene' it should work.
+
+- The resizing of the viewport in TinyGLX ensures that the width and
+the height are multiples of 4. This is not optimal because some pixels
+of the window may not be refreshed.
+
+Why ?
+-----
+
+TinyGL was developped as a student project for a Virtual Reality
+network system called VReng (see the VReng home page at
+http://www-inf.enst.fr/vreng).
+
+At that time (January 1997), my initial project was to write my own 3D
+rasterizer based on some old sources I wrote. But I realized that it
+would be better to use OpenGL to work on any platform. My problem was
+that I wanted to use texture mapping which was (and is still) quite
+slower on many software OpenGL implementation. I could have modified
+Mesa to suit my needs, but I really wanted to use my old sources for
+that project. 
+
+I finally decided to use the same syntax as OpenGL but with my own
+libraries, thinking that later it could ease the porting of VReng to
+OpenGL.
+
+Now VReng is at last compatible with OpenGL, and I managed to patch
+TinyGL so that VReng can still work with it without any modifications.
+
+Since TinyGL may be useful for some people, especially in the world of
+embedded designs, I decided to release it 'as is', otherwise, it would
+have been lost on my hard disk !
+
+------------------------------------------------------------------------------
+* OpenGL(R) is a registered trademark of Silicon Graphics, Inc.
+------------------------------------------------------------------------------
+Fabrice Bellard.
diff --git a/src/other/tinygl/include/CMakeLists.txt b/src/other/tinygl/include/CMakeLists.txt
new file mode 100644
index 0000000000..7acf6b4610
--- /dev/null
+++ b/src/other/tinygl/include/CMakeLists.txt
@@ -0,0 +1,8 @@
+set(zhdrs
+	zbuffer.h
+	zfeatures.h
+	)
+
+install(FILES ${zhdrs} DESTINATION ${INCLUDE_DIR})
+
+install(FILES GL/gl.h DESTINATION ${INCLUDE_DIR}/TGL)
diff --git a/src/other/tinygl/include/TGL/gl.h b/src/other/tinygl/include/TGL/gl.h
new file mode 100644
index 0000000000..ad3b32a6ca
--- /dev/null
+++ b/src/other/tinygl/include/TGL/gl.h
@@ -0,0 +1,1186 @@
+#ifndef GL_H
+#define GL_H
+
+/* Uncomment the following to prefix the OpenGL
+ * function names with t to avoid conflicts with
+ * system OpenGL definitions */
+#define TGL_PREFIX 1
+
+/*
+ * The following constants come from Mesa
+ */
+#define COMPILETIME_TINYGL_COMPAT_TEST 0
+
+#define GL_VERSION_1_1 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+	/* Boolean values */
+	GL_FALSE			= 0,
+	GL_TRUE				= 1,
+
+	/* Data types */
+	GL_BYTE				= 0x1400,
+	GL_UNSIGNED_BYTE		= 0x1401,
+	GL_SHORT			= 0x1402,
+	GL_UNSIGNED_SHORT		= 0x1403,
+	GL_INT				= 0x1404,
+	GL_UNSIGNED_INT			= 0x1405,
+	GL_FLOAT			= 0x1406,
+	GL_DOUBLE			= 0x140A,
+	GL_2_BYTES			= 0x1407,
+	GL_3_BYTES			= 0x1408,
+	GL_4_BYTES			= 0x1409,
+	GL_UNSIGNED_SHORT_5_6_5 = 0x140A,
+	GL_UNSIGNED_INT_8_8_8_8 = 0x140B,
+
+	/* Primitives */
+	GL_LINES			= 0x0001,
+	GL_POINTS			= 0x0000,
+	GL_LINE_STRIP			= 0x0003,
+	GL_LINE_LOOP			= 0x0002,
+	GL_TRIANGLES			= 0x0004,
+	GL_TRIANGLE_STRIP		= 0x0005,
+	GL_TRIANGLE_FAN			= 0x0006,
+	GL_QUADS			= 0x0007,
+	GL_QUAD_STRIP			= 0x0008,
+	GL_POLYGON			= 0x0009,
+	GL_EDGE_FLAG			= 0x0B43,
+
+	/* Necessary for glBufferData */
+	GL_STATIC_DRAW          = 0x88E4,	
+	/* Vertex Arrays */
+	GL_VERTEX_ARRAY			= 0x8074,
+	GL_VERTEX_BUFFER		= 0x8074,
+	GL_NORMAL_ARRAY			= 0x8075,
+	GL_NORMAL_BUFFER		= 0x8075,
+	GL_COLOR_ARRAY			= 0x8076,
+	GL_COLOR_BUFFER			= 0x8076,
+	GL_INDEX_ARRAY			= 0x8077,
+	GL_TEXTURE_COORD_ARRAY		= 0x8078,
+	GL_TEXTURE_COORD_BUFFER		= 0x8078,
+	GL_EDGE_FLAG_ARRAY		= 0x8079,
+	GL_VERTEX_ARRAY_SIZE		= 0x807A,
+	GL_VERTEX_ARRAY_TYPE		= 0x807B,
+	GL_VERTEX_ARRAY_STRIDE		= 0x807C,
+	GL_VERTEX_ARRAY_COUNT		= 0x807D,
+	GL_NORMAL_ARRAY_TYPE		= 0x807E,
+	GL_NORMAL_ARRAY_STRIDE		= 0x807F,
+	GL_NORMAL_ARRAY_COUNT		= 0x8080,
+	GL_COLOR_ARRAY_SIZE		= 0x8081,
+	GL_COLOR_ARRAY_TYPE		= 0x8082,
+	GL_COLOR_ARRAY_STRIDE		= 0x8083,
+	GL_COLOR_ARRAY_COUNT		= 0x8084,
+	GL_INDEX_ARRAY_TYPE		= 0x8085,
+	GL_INDEX_ARRAY_STRIDE		= 0x8086,
+	GL_INDEX_ARRAY_COUNT		= 0x8087,
+	GL_TEXTURE_COORD_ARRAY_SIZE	= 0x8088,
+	GL_TEXTURE_COORD_ARRAY_TYPE	= 0x8089,
+	GL_TEXTURE_COORD_ARRAY_STRIDE	= 0x808A,
+	GL_TEXTURE_COORD_ARRAY_COUNT	= 0x808B,
+	GL_EDGE_FLAG_ARRAY_STRIDE	= 0x808C,
+	GL_EDGE_FLAG_ARRAY_COUNT	= 0x808D,
+	GL_VERTEX_ARRAY_POINTER		= 0x808E,
+	GL_NORMAL_ARRAY_POINTER		= 0x808F,
+	GL_COLOR_ARRAY_POINTER		= 0x8090,
+	GL_INDEX_ARRAY_POINTER		= 0x8091,
+	GL_TEXTURE_COORD_ARRAY_POINTER	= 0x8092,
+	GL_EDGE_FLAG_ARRAY_POINTER	= 0x8093,
+        GL_V2F				= 0x2A20,
+	GL_V3F				= 0x2A21,
+	GL_C4UB_V2F			= 0x2A22,
+	GL_C4UB_V3F			= 0x2A23,
+	GL_C3F_V3F			= 0x2A24,
+	GL_N3F_V3F			= 0x2A25,
+	GL_C4F_N3F_V3F			= 0x2A26,
+	GL_T2F_V3F			= 0x2A27,
+	GL_T4F_V4F			= 0x2A28,
+	GL_T2F_C4UB_V3F			= 0x2A29,
+	GL_T2F_C3F_V3F			= 0x2A2A,
+	GL_T2F_N3F_V3F			= 0x2A2B,
+	GL_T2F_C4F_N3F_V3F		= 0x2A2C,
+	GL_T4F_C4F_N3F_V4F		= 0x2A2D,
+
+	/* Matrix Mode */
+	GL_MATRIX_MODE			= 0x0BA0,
+	GL_MODELVIEW			= 0x1700,
+	GL_PROJECTION			= 0x1701,
+	GL_TEXTURE			= 0x1702,
+
+	/* Points */
+	GL_POINT_SMOOTH			= 0x0B10,
+	GL_POINT_SIZE			= 0x0B11,
+	GL_POINT_SIZE_GRANULARITY 	= 0x0B13,
+	GL_POINT_SIZE_RANGE		= 0x0B12,
+
+	/* Lines */
+	GL_LINE_SMOOTH			= 0x0B20,
+	GL_LINE_STIPPLE			= 0x0B24,
+	GL_LINE_STIPPLE_PATTERN		= 0x0B25,
+	GL_LINE_STIPPLE_REPEAT		= 0x0B26,
+	GL_LINE_WIDTH			= 0x0B21,
+	GL_LINE_WIDTH_GRANULARITY	= 0x0B23,
+	GL_LINE_WIDTH_RANGE		= 0x0B22,
+
+	/* Polygons */
+	GL_POINT			= 0x1B00,
+	GL_LINE				= 0x1B01,
+	GL_FILL				= 0x1B02,
+	GL_CCW				= 0x0901,
+	GL_CW				= 0x0900,
+	GL_FRONT			= 0x0404,
+	GL_BACK				= 0x0405,
+	GL_CULL_FACE			= 0x0B44,
+	GL_CULL_FACE_MODE		= 0x0B45,
+	GL_POLYGON_SMOOTH		= 0x0B41,
+	GL_POLYGON_STIPPLE		= 0x0B42,
+	GL_FRONT_FACE			= 0x0B46,
+	GL_POLYGON_MODE			= 0x0B40,
+	GL_POLYGON_OFFSET_FACTOR	= 0x3038,
+	GL_POLYGON_OFFSET_UNITS		= 0x2A00,
+	GL_POLYGON_OFFSET_POINT		= 0x2A01,
+	GL_POLYGON_OFFSET_LINE		= 0x2A02,
+	GL_POLYGON_OFFSET_FILL		= 0x8037,
+
+	/* Display Lists */
+	GL_COMPILE			= 0x1300,
+	GL_COMPILE_AND_EXECUTE		= 0x1301,
+	GL_LIST_BASE			= 0x0B32,
+	GL_LIST_INDEX			= 0x0B33,
+	GL_LIST_MODE			= 0x0B30,
+
+	/*TinyGL Extension queries, they all start with 0xf*/
+	GL_POLYGON_MAX_VERTEX = 0xf001,
+	GL_MAX_BUFFERS = 0xf002,
+	GL_TEXTURE_HASH_TABLE_SIZE = 0xf003,
+	GL_MAX_TEXTURE_LEVELS = 0xf004,
+	GL_MAX_SPECULAR_BUFFERS = 0xf005,
+	GL_MAX_DISPLAY_LISTS = 0xf006,
+	GL_ERROR_CHECK_LEVEL = 0xf007,
+	GL_IS_SPECULAR_ENABLED = 0xf008,
+	
+	/* Depth buffer */
+	GL_NEVER			= 0x0200,
+	GL_LESS				= 0x0201,
+	GL_GEQUAL			= 0x0206,
+	GL_LEQUAL			= 0x0203,
+	GL_GREATER			= 0x0204,
+	GL_NOTEQUAL			= 0x0205,
+	GL_EQUAL			= 0x0202,
+	GL_ALWAYS			= 0x0207,
+	GL_DEPTH_TEST			= 0x0B71,
+	GL_DEPTH_BITS			= 0x0D56,
+	GL_DEPTH_CLEAR_VALUE		= 0x0B73,
+	GL_DEPTH_FUNC			= 0x0B74,
+	GL_DEPTH_RANGE			= 0x0B70,
+	GL_DEPTH_WRITEMASK		= 0x0B72,
+	GL_DEPTH_COMPONENT		= 0x1902,
+
+	/* Lighting */
+	GL_LIGHTING			= 0x0B50,
+	GL_LIGHT0			= 0x4000,
+	GL_LIGHT1			= 0x4001,
+	GL_LIGHT2			= 0x4002,
+	GL_LIGHT3			= 0x4003,
+	GL_LIGHT4			= 0x4004,
+	GL_LIGHT5			= 0x4005,
+	GL_LIGHT6			= 0x4006,
+	GL_LIGHT7			= 0x4007,
+	GL_LIGHT8			= 0x4008,
+	GL_LIGHT9			= 0x4009,
+	GL_LIGHT10			= 0x400A,
+	GL_LIGHT11			= 0x400B,
+	GL_LIGHT12			= 0x400C,
+	GL_LIGHT13			= 0x400D,
+	GL_LIGHT14			= 0x400E,
+	GL_LIGHT15			= 0x400F,
+	GL_SPOT_EXPONENT		= 0x1205,
+	GL_SPOT_CUTOFF			= 0x1206,
+	GL_CONSTANT_ATTENUATION		= 0x1207,
+	GL_LINEAR_ATTENUATION		= 0x1208,
+	GL_QUADRATIC_ATTENUATION	= 0x1209,
+	GL_AMBIENT			= 0x1200,
+	GL_DIFFUSE			= 0x1201,
+	GL_SPECULAR			= 0x1202,
+	GL_SHININESS			= 0x1601,
+	GL_EMISSION			= 0x1600,
+	GL_POSITION			= 0x1203,
+	GL_SPOT_DIRECTION		= 0x1204,
+	GL_AMBIENT_AND_DIFFUSE		= 0x1602,
+	GL_COLOR_INDEXES		= 0x1603,
+	GL_LIGHT_MODEL_TWO_SIDE		= 0x0B52,
+	GL_LIGHT_MODEL_LOCAL_VIEWER	= 0x0B51,
+	GL_LIGHT_MODEL_AMBIENT		= 0x0B53,
+	GL_FRONT_AND_BACK		= 0x0408,
+	GL_SHADE_MODEL			= 0x0B54,
+	GL_FLAT				= 0x1D00,
+	GL_SMOOTH			= 0x1D01,
+	GL_COLOR_MATERIAL		= 0x0B57,
+	GL_COLOR_MATERIAL_FACE		= 0x0B55,
+	GL_COLOR_MATERIAL_PARAMETER	= 0x0B56,
+	GL_NORMALIZE			= 0x0BA1,
+
+	/* User clipping planes */
+	GL_CLIP_PLANE0			= 0x3000,
+	GL_CLIP_PLANE1			= 0x3001,
+	GL_CLIP_PLANE2			= 0x3002,
+	GL_CLIP_PLANE3			= 0x3003,
+	GL_CLIP_PLANE4			= 0x3004,
+	GL_CLIP_PLANE5			= 0x3005,
+
+	/* Accumulation buffer */
+	GL_ACCUM_RED_BITS		= 0x0D58,
+	GL_ACCUM_GREEN_BITS		= 0x0D59,
+	GL_ACCUM_BLUE_BITS		= 0x0D5A,
+	GL_ACCUM_ALPHA_BITS		= 0x0D5B,
+	GL_ACCUM_CLEAR_VALUE		= 0x0B80,
+	GL_ACCUM			= 0x0100,
+	GL_ADD				= 0x0104,
+	GL_LOAD				= 0x0101,
+	GL_MULT				= 0x0103,
+	GL_RETURN			= 0x0102,
+
+	/* Alpha testing */
+	GL_ALPHA_TEST			= 0x0BC0,
+	GL_ALPHA_TEST_REF		= 0x0BC2,
+	GL_ALPHA_TEST_FUNC		= 0x0BC1,
+
+	/* Blending */
+	GL_BLEND			= 0x0BE2,
+	GL_BLEND_SRC			= 0x0BE1,
+	GL_BLEND_DST			= 0x0BE0,
+	GL_ZERO				= 0,
+	GL_ONE				= 1,
+	GL_SRC_COLOR			= 0x0300,
+	GL_ONE_MINUS_SRC_COLOR		= 0x0301,
+	GL_DST_COLOR			= 0x0306,
+	GL_ONE_MINUS_DST_COLOR		= 0x0307,
+	GL_SRC_ALPHA			= 0x0302,
+	GL_ONE_MINUS_SRC_ALPHA		= 0x0303,
+	GL_DST_ALPHA			= 0x0304,
+	GL_ONE_MINUS_DST_ALPHA		= 0x0305,
+	GL_SRC_ALPHA_SATURATE		= 0x0308,
+	GL_CONSTANT_COLOR		= 0x8001,
+	GL_ONE_MINUS_CONSTANT_COLOR	= 0x8002,
+	GL_CONSTANT_ALPHA		= 0x8003,
+	GL_ONE_MINUS_CONSTANT_ALPHA	= 0x8004,
+
+	/* Render Mode */
+	GL_FEEDBACK			= 0x1C01,
+	GL_RENDER			= 0x1C00,
+	GL_SELECT			= 0x1C02,
+
+	/* Feedback */
+	GL_2D				= 0x0600,
+	GL_3D				= 0x0601,
+	GL_3D_COLOR			= 0x0602,
+	GL_3D_COLOR_TEXTURE		= 0x0603,
+	GL_4D_COLOR_TEXTURE		= 0x0604,
+	GL_POINT_TOKEN			= 0x0701,
+	GL_LINE_TOKEN			= 0x0702,
+	GL_LINE_RESET_TOKEN		= 0x0707,
+	GL_POLYGON_TOKEN		= 0x0703,
+	GL_BITMAP_TOKEN			= 0x0704,
+	GL_DRAW_PIXEL_TOKEN		= 0x0705,
+	GL_COPY_PIXEL_TOKEN		= 0x0706,
+	GL_PASS_THROUGH_TOKEN		= 0x0700,
+
+	/* Fog */
+	GL_FOG				= 0x0B60,
+	GL_FOG_MODE			= 0x0B65,
+	GL_FOG_DENSITY			= 0x0B62,
+	GL_FOG_COLOR			= 0x0B66,
+	GL_FOG_INDEX			= 0x0B61,
+	GL_FOG_START			= 0x0B63,
+	GL_FOG_END			= 0x0B64,
+	GL_LINEAR			= 0x2601,
+	GL_EXP				= 0x0800,
+	GL_EXP2				= 0x0801,
+
+	/* Logic Ops */
+	GL_LOGIC_OP			= 0x0BF1,
+	GL_LOGIC_OP_MODE		= 0x0BF0,
+	GL_CLEAR			= 0x1500,
+	GL_SET				= 0x150F,
+	GL_COPY				= 0x1503,
+	GL_COPY_INVERTED		= 0x150C,
+	GL_NOOP				= 0x1505,
+	GL_INVERT			= 0x150A,
+	GL_AND				= 0x1501,
+	GL_NAND				= 0x150E,
+	GL_OR				= 0x1507,
+	GL_NOR				= 0x1508,
+	GL_XOR				= 0x1506,
+	GL_EQUIV			= 0x1509,
+	GL_AND_REVERSE			= 0x1502,
+	GL_AND_INVERTED			= 0x1504,
+	GL_OR_REVERSE			= 0x150B,
+	GL_OR_INVERTED			= 0x150D,
+
+	/* Stencil */
+	GL_STENCIL_TEST			= 0x0B90,
+	GL_STENCIL_WRITEMASK		= 0x0B98,
+	GL_STENCIL_BITS			= 0x0D57,
+	GL_STENCIL_FUNC			= 0x0B92,
+	GL_STENCIL_VALUE_MASK		= 0x0B93,
+	GL_STENCIL_REF			= 0x0B97,
+	GL_STENCIL_FAIL			= 0x0B94,
+	GL_STENCIL_PASS_DEPTH_PASS	= 0x0B96,
+	GL_STENCIL_PASS_DEPTH_FAIL	= 0x0B95,
+	GL_STENCIL_CLEAR_VALUE		= 0x0B91,
+	GL_STENCIL_INDEX		= 0x1901,
+	GL_KEEP				= 0x1E00,
+	GL_REPLACE			= 0x1E01,
+	GL_INCR				= 0x1E02,
+	GL_DECR				= 0x1E03,
+
+	/* Buffers, Pixel Drawing/Reading */
+	GL_NONE				= 0,
+	GL_LEFT				= 0x0406,
+	GL_RIGHT			= 0x0407,
+	/*GL_FRONT			= 0x0404, */
+	/*GL_BACK			= 0x0405, */
+	/*GL_FRONT_AND_BACK		= 0x0408, */
+	GL_FRONT_LEFT			= 0x0400,
+	GL_FRONT_RIGHT			= 0x0401,
+	GL_BACK_LEFT			= 0x0402,
+	GL_BACK_RIGHT			= 0x0403,
+	GL_AUX0				= 0x0409,
+	GL_AUX1				= 0x040A,
+	GL_AUX2				= 0x040B,
+	GL_AUX3				= 0x040C,
+	GL_COLOR_INDEX			= 0x1900,
+	GL_RED				= 0x1903,
+	GL_GREEN			= 0x1904,
+	GL_BLUE				= 0x1905,
+	GL_ALPHA			= 0x1906,
+	GL_LUMINANCE			= 0x1909,
+	GL_LUMINANCE_ALPHA		= 0x190A,
+	GL_ALPHA_BITS			= 0x0D55,
+	GL_RED_BITS			= 0x0D52,
+	GL_GREEN_BITS			= 0x0D53,
+	GL_BLUE_BITS			= 0x0D54,
+	GL_INDEX_BITS			= 0x0D51,
+	GL_SUBPIXEL_BITS		= 0x0D50,
+	GL_AUX_BUFFERS			= 0x0C00,
+	GL_READ_BUFFER			= 0x0C02,
+	GL_DRAW_BUFFER			= 0x0C01,
+	GL_DOUBLEBUFFER			= 0x0C32,
+	GL_STEREO			= 0x0C33,
+	GL_BITMAP			= 0x1A00,
+	GL_COLOR			= 0x1800,
+	GL_DEPTH			= 0x1801,
+	GL_STENCIL			= 0x1802,
+	GL_DITHER			= 0x0BD0,
+	GL_RGB				= 0x1907,
+	GL_RGBA				= 0x1908,
+
+	/* Implementation limits */
+	GL_MAX_LIST_NESTING		= 0x0B31,
+	GL_MAX_ATTRIB_STACK_DEPTH	= 0x0D35,
+	GL_MAX_MODELVIEW_STACK_DEPTH	= 0x0D36,
+	GL_MAX_NAME_STACK_DEPTH		= 0x0D37,
+	GL_MAX_PROJECTION_STACK_DEPTH	= 0x0D38,
+	GL_MAX_TEXTURE_STACK_DEPTH	= 0x0D39,
+	GL_MAX_EVAL_ORDER		= 0x0D30,
+	GL_MAX_LIGHTS			= 0x0D31,
+	GL_MAX_CLIP_PLANES		= 0x0D32,
+	GL_MAX_TEXTURE_SIZE		= 0x0D33,
+	GL_MAX_PIXEL_MAP_TABLE		= 0x0D34,
+	GL_MAX_VIEWPORT_DIMS		= 0x0D3A,
+	GL_MAX_CLIENT_ATTRIB_STACK_DEPTH= 0x0D3B,
+
+	/* Gets */
+	GL_ATTRIB_STACK_DEPTH		= 0x0BB0,
+	GL_COLOR_CLEAR_VALUE		= 0x0C22,
+	GL_COLOR_WRITEMASK		= 0x0C23,
+	GL_CURRENT_INDEX		= 0x0B01,
+	GL_CURRENT_COLOR		= 0x0B00,
+	GL_CURRENT_NORMAL		= 0x0B02,
+	GL_CURRENT_RASTER_COLOR		= 0x0B04,
+	GL_CURRENT_RASTER_DISTANCE	= 0x0B09,
+	GL_CURRENT_RASTER_INDEX		= 0x0B05,
+	GL_CURRENT_RASTER_POSITION	= 0x0B07,
+	GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
+	GL_CURRENT_RASTER_POSITION_VALID = 0x0B08,
+	GL_CURRENT_TEXTURE_COORDS	= 0x0B03,
+	GL_INDEX_CLEAR_VALUE		= 0x0C20,
+	GL_INDEX_MODE			= 0x0C30,
+	GL_INDEX_WRITEMASK		= 0x0C21,
+	GL_MODELVIEW_MATRIX		= 0x0BA6,
+	GL_MODELVIEW_STACK_DEPTH	= 0x0BA3,
+	GL_NAME_STACK_DEPTH		= 0x0D70,
+	GL_PROJECTION_MATRIX		= 0x0BA7,
+	GL_PROJECTION_STACK_DEPTH	= 0x0BA4,
+	GL_RENDER_MODE			= 0x0C40,
+	GL_RGBA_MODE			= 0x0C31,
+	GL_TEXTURE_MATRIX		= 0x0BA8,
+	GL_TEXTURE_STACK_DEPTH		= 0x0BA5,
+	GL_VIEWPORT			= 0x0BA2,
+
+
+	/* Evaluators */
+	GL_AUTO_NORMAL			= 0x0D80,
+	GL_MAP1_COLOR_4			= 0x0D90,
+	GL_MAP1_GRID_DOMAIN		= 0x0DD0,
+	GL_MAP1_GRID_SEGMENTS		= 0x0DD1,
+	GL_MAP1_INDEX			= 0x0D91,
+	GL_MAP1_NORMAL			= 0x0D92,
+	GL_MAP1_TEXTURE_COORD_1		= 0x0D93,
+	GL_MAP1_TEXTURE_COORD_2		= 0x0D94,
+	GL_MAP1_TEXTURE_COORD_3		= 0x0D95,
+	GL_MAP1_TEXTURE_COORD_4		= 0x0D96,
+	GL_MAP1_VERTEX_3		= 0x0D97,
+	GL_MAP1_VERTEX_4		= 0x0D98,
+	GL_MAP2_COLOR_4			= 0x0DB0,
+	GL_MAP2_GRID_DOMAIN		= 0x0DD2,
+	GL_MAP2_GRID_SEGMENTS		= 0x0DD3,
+	GL_MAP2_INDEX			= 0x0DB1,
+	GL_MAP2_NORMAL			= 0x0DB2,
+	GL_MAP2_TEXTURE_COORD_1		= 0x0DB3,
+	GL_MAP2_TEXTURE_COORD_2		= 0x0DB4,
+	GL_MAP2_TEXTURE_COORD_3		= 0x0DB5,
+	GL_MAP2_TEXTURE_COORD_4		= 0x0DB6,
+	GL_MAP2_VERTEX_3		= 0x0DB7,
+	GL_MAP2_VERTEX_4		= 0x0DB8,
+	GL_COEFF			= 0x0A00,
+	GL_DOMAIN			= 0x0A02,
+	GL_ORDER			= 0x0A01,
+
+	/* Hints */
+	GL_FOG_HINT			= 0x0C54,
+	GL_LINE_SMOOTH_HINT		= 0x0C52,
+	GL_PERSPECTIVE_CORRECTION_HINT	= 0x0C50,
+	GL_POINT_SMOOTH_HINT		= 0x0C51,
+	GL_POLYGON_SMOOTH_HINT		= 0x0C53,
+	GL_DONT_CARE			= 0x1100,
+	GL_FASTEST			= 0x1101,
+	GL_NICEST			= 0x1102,
+
+	/* Scissor box */
+	GL_SCISSOR_TEST			= 0x0C11,
+	GL_SCISSOR_BOX			= 0x0C10,
+
+	/* Pixel Mode / Transfer */
+	GL_MAP_COLOR			= 0x0D10,
+	GL_MAP_STENCIL			= 0x0D11,
+	GL_INDEX_SHIFT			= 0x0D12,
+	GL_INDEX_OFFSET			= 0x0D13,
+	GL_RED_SCALE			= 0x0D14,
+	GL_RED_BIAS			= 0x0D15,
+	GL_GREEN_SCALE			= 0x0D18,
+	GL_GREEN_BIAS			= 0x0D19,
+	GL_BLUE_SCALE			= 0x0D1A,
+	GL_BLUE_BIAS			= 0x0D1B,
+	GL_ALPHA_SCALE			= 0x0D1C,
+	GL_ALPHA_BIAS			= 0x0D1D,
+	GL_DEPTH_SCALE			= 0x0D1E,
+	GL_DEPTH_BIAS			= 0x0D1F,
+	GL_PIXEL_MAP_S_TO_S_SIZE	= 0x0CB1,
+	GL_PIXEL_MAP_I_TO_I_SIZE	= 0x0CB0,
+	GL_PIXEL_MAP_I_TO_R_SIZE	= 0x0CB2,
+	GL_PIXEL_MAP_I_TO_G_SIZE	= 0x0CB3,
+	GL_PIXEL_MAP_I_TO_B_SIZE	= 0x0CB4,
+	GL_PIXEL_MAP_I_TO_A_SIZE	= 0x0CB5,
+	GL_PIXEL_MAP_R_TO_R_SIZE	= 0x0CB6,
+	GL_PIXEL_MAP_G_TO_G_SIZE	= 0x0CB7,
+	GL_PIXEL_MAP_B_TO_B_SIZE	= 0x0CB8,
+	GL_PIXEL_MAP_A_TO_A_SIZE	= 0x0CB9,
+	GL_PIXEL_MAP_S_TO_S		= 0x0C71,
+	GL_PIXEL_MAP_I_TO_I		= 0x0C70,
+	GL_PIXEL_MAP_I_TO_R		= 0x0C72,
+	GL_PIXEL_MAP_I_TO_G		= 0x0C73,
+	GL_PIXEL_MAP_I_TO_B		= 0x0C74,
+	GL_PIXEL_MAP_I_TO_A		= 0x0C75,
+	GL_PIXEL_MAP_R_TO_R		= 0x0C76,
+	GL_PIXEL_MAP_G_TO_G		= 0x0C77,
+	GL_PIXEL_MAP_B_TO_B		= 0x0C78,
+	GL_PIXEL_MAP_A_TO_A		= 0x0C79,
+	GL_PACK_ALIGNMENT		= 0x0D05,
+	GL_PACK_LSB_FIRST		= 0x0D01,
+	GL_PACK_ROW_LENGTH		= 0x0D02,
+	GL_PACK_SKIP_PIXELS		= 0x0D04,
+	GL_PACK_SKIP_ROWS		= 0x0D03,
+	GL_PACK_SWAP_BYTES		= 0x0D00,
+	GL_UNPACK_ALIGNMENT		= 0x0CF5,
+	GL_UNPACK_LSB_FIRST		= 0x0CF1,
+	GL_UNPACK_ROW_LENGTH		= 0x0CF2,
+	GL_UNPACK_SKIP_PIXELS		= 0x0CF4,
+	GL_UNPACK_SKIP_ROWS		= 0x0CF3,
+	GL_UNPACK_SWAP_BYTES		= 0x0CF0,
+	GL_ZOOM_X			= 0x0D16,
+	GL_ZOOM_Y			= 0x0D17,
+
+	/* Texture mapping */
+	GL_TEXTURE_ENV			= 0x2300,
+	GL_TEXTURE_ENV_MODE		= 0x2200,
+	GL_TEXTURE_1D			= 0x0DE0,
+	GL_TEXTURE_2D			= 0x0DE1,
+	GL_TEXTURE_WRAP_S		= 0x2802,
+	GL_TEXTURE_WRAP_T		= 0x2803,
+	GL_TEXTURE_MAG_FILTER		= 0x2800,
+	GL_TEXTURE_MIN_FILTER		= 0x2801,
+	GL_TEXTURE_ENV_COLOR		= 0x2201,
+	GL_TEXTURE_GEN_S		= 0x0C60,
+	GL_TEXTURE_GEN_T		= 0x0C61,
+	GL_TEXTURE_GEN_MODE		= 0x2500,
+	GL_TEXTURE_BORDER_COLOR		= 0x1004,
+	GL_TEXTURE_WIDTH		= 0x1000,
+	GL_TEXTURE_HEIGHT		= 0x1001,
+	GL_TEXTURE_BORDER		= 0x1005,
+	GL_TEXTURE_COMPONENTS		= 0x1003,
+	GL_NEAREST_MIPMAP_NEAREST	= 0x2700,
+	GL_NEAREST_MIPMAP_LINEAR	= 0x2702,
+	GL_LINEAR_MIPMAP_NEAREST	= 0x2701,
+	GL_LINEAR_MIPMAP_LINEAR		= 0x2703,
+	GL_OBJECT_LINEAR		= 0x2401,
+	GL_OBJECT_PLANE			= 0x2501,
+	GL_EYE_LINEAR			= 0x2400,
+	GL_EYE_PLANE			= 0x2502,
+	GL_SPHERE_MAP			= 0x2402,
+	GL_DECAL			= 0x2101,
+	GL_MODULATE			= 0x2100,
+	GL_NEAREST			= 0x2600,
+	GL_REPEAT			= 0x2901,
+	GL_CLAMP			= 0x2900,
+	GL_S				= 0x2000,
+	GL_T				= 0x2001,
+	GL_R				= 0x2002,
+	GL_Q				= 0x2003,
+	GL_TEXTURE_GEN_R		= 0x0C62,
+	GL_TEXTURE_GEN_Q		= 0x0C63,
+
+	GL_PROXY_TEXTURE_1D		= 0x8063,
+	GL_PROXY_TEXTURE_2D		= 0x8064,
+	GL_TEXTURE_PRIORITY		= 0x8066,
+	GL_TEXTURE_RESIDENT		= 0x8067,
+	GL_TEXTURE_1D_BINDING		= 0x8068,
+	GL_TEXTURE_2D_BINDING		= 0x8069,
+
+	/* Internal texture formats */
+	GL_ALPHA4			= 0x803B,
+	GL_ALPHA8			= 0x803C,
+	GL_ALPHA12			= 0x803D,
+	GL_ALPHA16			= 0x803E,
+	GL_LUMINANCE4			= 0x803F,
+	GL_LUMINANCE8			= 0x8040,
+	GL_LUMINANCE12			= 0x8041,
+	GL_LUMINANCE16			= 0x8042,
+	GL_LUMINANCE4_ALPHA4		= 0x8043,
+	GL_LUMINANCE6_ALPHA2		= 0x8044,
+	GL_LUMINANCE8_ALPHA8		= 0x8045,
+	GL_LUMINANCE12_ALPHA4		= 0x8046,
+	GL_LUMINANCE12_ALPHA12		= 0x8047,
+	GL_LUMINANCE16_ALPHA16		= 0x8048,
+	GL_INTENSITY			= 0x8049,
+	GL_INTENSITY4			= 0x804A,
+	GL_INTENSITY8			= 0x804B,
+	GL_INTENSITY12			= 0x804C,
+	GL_INTENSITY16			= 0x804D,
+	GL_R3_G3_B2			= 0x2A10,
+	GL_RGB4				= 0x804F,
+	GL_RGB5				= 0x8050,
+	GL_RGB8				= 0x8051,
+	GL_RGB10			= 0x8052,
+	GL_RGB12			= 0x8053,
+	GL_RGB16			= 0x8054,
+	GL_RGBA2			= 0x8055,
+	GL_RGBA4			= 0x8056,
+	GL_RGB5_A1			= 0x8057,
+	GL_RGBA8			= 0x8058,
+	GL_RGB10_A2			= 0x8059,
+	GL_RGBA12			= 0x805A,
+	GL_RGBA16			= 0x805B,
+
+	/* Utility */
+	GL_VENDOR			= 0x1F00,
+	GL_RENDERER			= 0x1F01,
+	GL_VERSION			= 0x1F02,
+	GL_EXTENSIONS			= 0x1F03,
+	GL_LICENSE			= 0x1F04,
+
+	/* Errors */
+	GL_NO_ERROR				= 0x0,
+	GL_INVALID_VALUE		= 0x0501,
+	GL_INVALID_ENUM			= 0x0500,
+	GL_INVALID_OPERATION		= 0x0502,
+	GL_STACK_OVERFLOW		= 0x0503,
+	GL_STACK_UNDERFLOW		= 0x0504,
+	GL_OUT_OF_MEMORY		= 0x0505,
+
+	/*
+	 * 1.0 Extensions
+	 */
+        /* GL_EXT_blend_minmax and GL_EXT_blend_color */
+	GL_CONSTANT_COLOR_EXT		= 0x8001,
+	GL_ONE_MINUS_CONSTANT_COLOR_EXT	= 0x8002,
+	GL_CONSTANT_ALPHA_EXT		= 0x8003,
+	GL_ONE_MINUS_CONSTANT_ALPHA_EXT	= 0x8004,
+	GL_BLEND_EQUATION_EXT		= 0x8009,
+	GL_BLEND_EQUATION			= 0x8009,
+	GL_MIN_EXT			= 0x8007,
+	GL_MAX_EXT			= 0x8008,
+	GL_FUNC_ADD_EXT			= 0x8006,
+	GL_FUNC_ADD			= 0x8006,
+	GL_FUNC_SUBTRACT_EXT		= 0x800A,
+	GL_FUNC_SUBTRACT		= 0x800A,
+	GL_FUNC_REVERSE_SUBTRACT_EXT	= 0x800B,
+	GL_FUNC_REVERSE_SUBTRACT	= 0x800B,
+	GL_BLEND_COLOR_EXT		= 0x8005,
+
+	/* GL_EXT_polygon_offset */
+        GL_POLYGON_OFFSET_EXT           = 0x8037,
+        GL_POLYGON_OFFSET_FACTOR_EXT    = 0x8038,
+        GL_POLYGON_OFFSET_BIAS_EXT      = 0x8039,
+	/* GL */
+		GL_ARRAY_BUFFER                 = 0x8892,
+	/* GL_EXT_vertex_array */
+	GL_VERTEX_ARRAY_EXT		= 0x8074,
+	GL_NORMAL_ARRAY_EXT		= 0x8075,
+	GL_COLOR_ARRAY_EXT		= 0x8076,
+	GL_INDEX_ARRAY_EXT		= 0x8077,
+	GL_TEXTURE_COORD_ARRAY_EXT	= 0x8078,
+	GL_EDGE_FLAG_ARRAY_EXT		= 0x8079,
+	GL_VERTEX_ARRAY_SIZE_EXT	= 0x807A,
+	GL_VERTEX_ARRAY_TYPE_EXT	= 0x807B,
+	GL_VERTEX_ARRAY_STRIDE_EXT	= 0x807C,
+	GL_VERTEX_ARRAY_COUNT_EXT	= 0x807D,
+	GL_NORMAL_ARRAY_TYPE_EXT	= 0x807E,
+	GL_NORMAL_ARRAY_STRIDE_EXT	= 0x807F,
+	GL_NORMAL_ARRAY_COUNT_EXT	= 0x8080,
+	GL_COLOR_ARRAY_SIZE_EXT		= 0x8081,
+	GL_COLOR_ARRAY_TYPE_EXT		= 0x8082,
+	GL_COLOR_ARRAY_STRIDE_EXT	= 0x8083,
+	GL_COLOR_ARRAY_COUNT_EXT	= 0x8084,
+	GL_INDEX_ARRAY_TYPE_EXT		= 0x8085,
+	GL_INDEX_ARRAY_STRIDE_EXT	= 0x8086,
+	GL_INDEX_ARRAY_COUNT_EXT	= 0x8087,
+	GL_TEXTURE_COORD_ARRAY_SIZE_EXT	= 0x8088,
+	GL_TEXTURE_COORD_ARRAY_TYPE_EXT	= 0x8089,
+	GL_TEXTURE_COORD_ARRAY_STRIDE_EXT= 0x808A,
+	GL_TEXTURE_COORD_ARRAY_COUNT_EXT= 0x808B,
+	GL_EDGE_FLAG_ARRAY_STRIDE_EXT	= 0x808C,
+	GL_EDGE_FLAG_ARRAY_COUNT_EXT	= 0x808D,
+	GL_VERTEX_ARRAY_POINTER_EXT	= 0x808E,
+	GL_NORMAL_ARRAY_POINTER_EXT	= 0x808F,
+	GL_COLOR_ARRAY_POINTER_EXT	= 0x8090,
+	GL_INDEX_ARRAY_POINTER_EXT	= 0x8091,
+	GL_TEXTURE_COORD_ARRAY_POINTER_EXT= 0x8092,
+	GL_EDGE_FLAG_ARRAY_POINTER_EXT	= 0x8093
+
+};
+
+typedef enum {
+	GL_TEXT_SIZE8x8 = 1,
+	GL_TEXT_SIZE16x16 = 2,
+	GL_TEXT_SIZE24x24 = 3,
+	GL_TEXT_SIZE32x32 = 4,
+	GL_TEXT_SIZE40x40 = 5,
+	GL_TEXT_SIZE48x48 = 6,
+	GL_TEXT_SIZE56x56 = 7,
+	GL_TEXT_SIZE64x64 = 8,
+	GL_TEXT_SIZE72x72 = 9,
+	GL_TEXT_SIZE80x80 = 10,
+	GL_TEXT_SIZE88x88 = 11,
+	GL_TEXT_SIZE96x96 = 12,
+	GL_TEXT_SIZE104x104 = 13,
+	GL_TEXT_SIZE112x112 = 14,
+	GL_TEXT_SIZE120x120 = 15,
+	GL_TEXT_SIZE128x128 = 16,
+	GL_MAX_TEXT_SIZE = 16
+} GLTEXTSIZE;
+enum {
+	GL_CURRENT_BIT		= 0x00000001,
+	GL_POINT_BIT		= 0x00000002,
+	GL_LINE_BIT		= 0x00000004,
+	GL_POLYGON_BIT		= 0x00000008,
+	GL_POLYGON_STIPPLE_BIT	= 0x00000010,
+	GL_PIXEL_MODE_BIT	= 0x00000020,
+	GL_LIGHTING_BIT		= 0x00000040,
+	GL_FOG_BIT		= 0x00000080,
+	GL_DEPTH_BUFFER_BIT	= 0x00000100,
+	GL_ACCUM_BUFFER_BIT	= 0x00000200,
+	GL_STENCIL_BUFFER_BIT	= 0x00000400,
+	GL_VIEWPORT_BIT		= 0x00000800,
+	GL_TRANSFORM_BIT	= 0x00001000,
+	GL_ENABLE_BIT		= 0x00002000,
+	GL_COLOR_BUFFER_BIT	= 0x00004000,
+	GL_HINT_BIT		= 0x00008000,
+	GL_EVAL_BIT		= 0x00010000,
+	GL_LIST_BIT		= 0x00020000,
+	GL_TEXTURE_BIT		= 0x00040000,
+	GL_SCISSOR_BIT		= 0x00080000,
+	GL_ALL_ATTRIB_BITS	= 0x000fffff
+};
+
+/* some types */
+
+
+typedef void		GLvoid;
+typedef unsigned char	GLboolean;
+typedef signed char	GLbyte;		/* 1-byte signed */
+typedef short		GLshort;	/* 2-byte signed */
+typedef int		GLint;		/* 4-byte signed */
+typedef GLint	GLenum; /* Same as GLint */
+typedef unsigned char	GLubyte;	/* 1-byte unsigned */
+typedef unsigned short	GLushort;	/* 2-byte unsigned */
+typedef unsigned int	GLuint;		/* 4-byte unsigned */
+typedef float		GLfloat;	/* single precision float */
+typedef double		GLdouble;	/* double precision float */
+typedef GLint 		GLsizei; /* Same as GLint */
+
+
+#if COMPILETIME_TINYGL_COMPAT_TEST == 1
+/*
+Test to ensure that these types are the correct size
+If you get an "array is negative" error, simply change
+the typedefs above to types which match the sizes tested for here.
+Note that this library NEEDS a 4-byte float type (IEEE 754) so
+if you don't have one, TinyGL is incompatible.
+*/
+extern char TGL_BUILDT_GLbyte[ 1-2*(sizeof(GLbyte) != 1)];
+#ifdef __STDC_IEC_559__
+#if __STDC_IEC_559__ == 0
+#error C99 Compiler Using Non-Compliant Float Type! Compatibility not guaranteed.
+#endif
+#else
+#warning "Cannot test __STDC_IEC_559__, it is not defined."
+#endif
+extern char TGL_BUILDT_GLshort[ 1-2*(sizeof(GLshort) != 2)];
+extern char TGL_BUILDT_GLint[ 1-2*(sizeof(GLint) != 4)];
+extern char TGL_BUILDT_GLuint[ 1-2*(sizeof(GLuint) != 4)];
+extern char TGL_BUILDT_GLfloat[ 1-2*(sizeof(GLfloat) != 4)];
+extern char TGL_BUILDT_GLubyte[ 1-2*(sizeof(GLubyte) != 1)];
+extern char TGL_BUILDT_GLushort[ 1-2*(sizeof(GLushort) != 2)];
+
+extern char TGL_BUILDT_LshiftGLint[ 1-2*(((GLint)255<<8) != 65280)];
+extern char TGL_BUILDT_RshiftGLint[ 1-2*((GLint)65280>>8 != 255)];
+extern char TGL_BUILDT_RshiftGLint2[ 1-2*( ((GLint)-1)>>14  != -1 )];
+extern char TGL_BUILDT_LshiftGLuint[ 1-2*(((GLuint)255<<8) != 65280)];
+extern char TGL_BUILDT_RshiftGLuint[ 1-2*((GLuint)65280>>8 != 255)];
+
+extern char TGL_BUILDT_LshiftGLushort[ 1-2*(((GLushort)255<<8) != 65280)];
+extern char TGL_BUILDT_RshiftGLushort[ 1-2*((GLushort)65280>>8 != 255)];
+
+extern char TGL_BUILDT_LshiftGLshort[ 1-2*(((GLshort)255<<8) != 65280)];
+extern char TGL_BUILDT_RshiftGLshort[ 1-2*((GLshort)65280>>8 != -1)];
+
+#undef T
+#endif
+
+#ifdef TGL_PREFIX
+#  define TGL_PREFIX_STR t
+#  define TGL_CONCAT2(a, b) a ## b
+#  define TGL_CONCAT(a, b) TGL_CONCAT2(a,b)
+#  define TGL_ADD_PREFIX(b) TGL_CONCAT(TGL_PREFIX_STR,b)
+
+#  define glEnable		TGL_ADD_PREFIX(glEnable)
+#  define glDisable		TGL_ADD_PREFIX(glDisable)
+#  define glShadeModel		TGL_ADD_PREFIX(glShadeModel)
+#  define glCullFace		TGL_ADD_PREFIX(glCullFace)
+#  define glPolygonMode		TGL_ADD_PREFIX(glPolygonMode)
+#  define glBegin		TGL_ADD_PREFIX(glBegin)
+#  define glEnd			TGL_ADD_PREFIX(glEnd)
+#  define glRectf		TGL_ADD_PREFIX(glRectf)
+#  define glDrawBuffer		TGL_ADD_PREFIX(glDrawBuffer)
+#  define glReadBuffer		TGL_ADD_PREFIX(glReadBuffer)
+#  define glReadPixels		TGL_ADD_PREFIX(glReadPixels)
+#  define glDrawArrays		TGL_ADD_PREFIX(glDrawArrays)
+#  define glSetEnableSpecular	TGL_ADD_PREFIX(glSetEnableSpecular)
+#  define glGetTexturePixmap	TGL_ADD_PREFIX(glGetTexturePixmap)
+#  define glDrawText		TGL_ADD_PREFIX(glDrawText)
+#  define glTextSize		TGL_ADD_PREFIX(glTextSize)
+#  define glPlotPixel		TGL_ADD_PREFIX(glPlotPixel)
+#  define glEdgeFlag		TGL_ADD_PREFIX(glEdgeFlag)
+#  define glMatrixMode		TGL_ADD_PREFIX(glMatrixMode)
+#  define glLoadMatrixf		TGL_ADD_PREFIX(glLoadMatrixf)
+#  define glLoadIdentity	TGL_ADD_PREFIX(glLoadIdentity)
+#  define glMultMatrixf		TGL_ADD_PREFIX(glMultMatrixf)
+#  define glPushMatrix		TGL_ADD_PREFIX(glPushMatrix)
+#  define glPopMatrix		TGL_ADD_PREFIX(glPopMatrix)
+#  define glRotatef		TGL_ADD_PREFIX(glRotatef)
+#  define glTranslatef		TGL_ADD_PREFIX(glTranslatef)
+#  define glScalef		TGL_ADD_PREFIX(glScalef)
+#  define glViewport		TGL_ADD_PREFIX(glViewport)
+#  define glFrustum		TGL_ADD_PREFIX(glFrustum)
+#  define glGenLists		TGL_ADD_PREFIX(glGenLists)
+#  define glIsList		TGL_ADD_PREFIX(glIsList)
+#  define glNewList		TGL_ADD_PREFIX(glNewList)
+#  define glEndList		TGL_ADD_PREFIX(glEndList)
+#  define glCallList		TGL_ADD_PREFIX(glCallList)
+#  define glCallLists		TGL_ADD_PREFIX(glCallLists)
+#  define glListBase		TGL_ADD_PREFIX(glListBase)
+#  define glDeleteList		TGL_ADD_PREFIX(glDeleteList)
+#  define glDeleteLists		TGL_ADD_PREFIX(glDeleteLists)
+#  define glClear		TGL_ADD_PREFIX(glClear)
+#  define glClearColor		TGL_ADD_PREFIX(glClearColor)
+#  define glClearDepth		TGL_ADD_PREFIX(glClearDepth)
+#  define glFeedbackBuffer	TGL_ADD_PREFIX(glFeedbackBuffer)
+#  define glPassThrough		TGL_ADD_PREFIX(glPassThrough)
+#  define glRenderMode		TGL_ADD_PREFIX(glRenderMode)
+#  define glSelectBuffer	TGL_ADD_PREFIX(glSelectBuffer)
+#  define glInitNames		TGL_ADD_PREFIX(glInitNames)
+#  define glPushName		TGL_ADD_PREFIX(glPushName)
+#  define glPopName		TGL_ADD_PREFIX(glPopName)
+#  define glLoadName		TGL_ADD_PREFIX(glLoadName)
+#  define glGenTextures		TGL_ADD_PREFIX(glGenTextures)
+#  define glDeleteTextures	TGL_ADD_PREFIX(glDeleteTextures)
+#  define glBindTexture		TGL_ADD_PREFIX(glBindTexture)
+#  define glTexImage2D		TGL_ADD_PREFIX(glTexImage2D)
+#  define glTexImage1D		TGL_ADD_PREFIX(glTexImage1D)
+#  define glCopyTexImage2D	TGL_ADD_PREFIX(glCopyTexImage2D)
+#  define glTexEnvi		TGL_ADD_PREFIX(glTexEnvi)
+#  define glTexParameteri	TGL_ADD_PREFIX(glTexParameteri)
+#  define glAreTexturesResident	TGL_ADD_PREFIX(glAreTexturesResident)
+#  define glIsTexture		TGL_ADD_PREFIX(glIsTexture)
+#  define glMaterialfv		TGL_ADD_PREFIX(glMaterialfv)
+#  define glMaterialf		TGL_ADD_PREFIX(glMaterialf)
+#  define glColorMaterial	TGL_ADD_PREFIX(glColorMaterial)
+#  define glLightfv		TGL_ADD_PREFIX(glLightfv)
+#  define glLightf		TGL_ADD_PREFIX(glLightf)
+#  define glLightModeli		TGL_ADD_PREFIX(glLightModeli)
+#  define glLightModelfv	TGL_ADD_PREFIX(glLightModelfv)
+#  define glFlush		TGL_ADD_PREFIX(glFlush)
+#  define glFinish		TGL_ADD_PREFIX(glFinish)
+#  define glHint		TGL_ADD_PREFIX(glHint)
+#  define glGetIntegerv		TGL_ADD_PREFIX(glGetIntegerv)
+#  define glGetFloatv		TGL_ADD_PREFIX(glGetFloatv)
+#  define glGetString		TGL_ADD_PREFIX(glGetString)
+#  define glGetError		TGL_ADD_PREFIX(glGetError)
+#  define glFrontFace		TGL_ADD_PREFIX(glFrontFace)
+#  define glEnableClientState	TGL_ADD_PREFIX(glEnableClientState)
+#  define glDisableClientState	TGL_ADD_PREFIX(glDisableClientState)
+#  define glArrayElement	TGL_ADD_PREFIX(glArrayElement)
+#  define glVertexPointer	TGL_ADD_PREFIX(glVertexPointer)
+#  define glColorPointer	TGL_ADD_PREFIX(glColorPointer)
+#  define glNormalPointer	TGL_ADD_PREFIX(glNormalPointer)
+#  define glTexCoordPointer	TGL_ADD_PREFIX(glTexCoordPointer)
+#  define glGenBuffers		TGL_ADD_PREFIX(glGenBuffers)
+#  define glDeleteBuffers	TGL_ADD_PREFIX(glDeleteBuffers)
+#  define glBindBuffer		TGL_ADD_PREFIX(glBindBuffer)
+#  define glIsBuffer		TGL_ADD_PREFIX(glIsBuffer)
+#  define glMapBuffer		TGL_ADD_PREFIX(glMapBuffer)
+#  define glBufferData		TGL_ADD_PREFIX(glBufferData)
+#  define glBindBufferAsArray	TGL_ADD_PREFIX(glBindBufferAsArray)
+#  define glPolygonOffset	TGL_ADD_PREFIX(glPolygonOffset)
+#  define glBlendFunc		TGL_ADD_PREFIX(glBlendFunc)
+#  define glBlendEquation	TGL_ADD_PREFIX(glBlendEquation)
+#  define glDepthMask		TGL_ADD_PREFIX(glDepthMask)
+#  define glPointSize		TGL_ADD_PREFIX(glPointSize)
+#  define glRasterPos2f		TGL_ADD_PREFIX(glRasterPos2f)
+#  define glRasterPos3f		TGL_ADD_PREFIX(glRasterPos3f)
+#  define glRasterPos4f		TGL_ADD_PREFIX(glRasterPos4f)
+#  define glRasterPos2fv	TGL_ADD_PREFIX(glRasterPos2fv)
+#  define glRasterPos3fv	TGL_ADD_PREFIX(glRasterPos3fv)
+#  define glRasterPos4fv	TGL_ADD_PREFIX(glRasterPos4fv)
+#  define glDrawPixels		TGL_ADD_PREFIX(glDrawPixels)
+#  define glPixelZoom		TGL_ADD_PREFIX(glPixelZoom)
+#  define glPostProcess		TGL_ADD_PREFIX(glPostProcess)
+#  define glPolygonStipple	TGL_ADD_PREFIX(glPolygonStipple)
+#  define glDebug		TGL_ADD_PREFIX(glDebug)
+#  define glInit		TGL_ADD_PREFIX(glInit)
+#  define glClose		TGL_ADD_PREFIX(glClose)
+#  define glVertex2f		TGL_ADD_PREFIX(glVertex2f)
+#  define glVertex2d		TGL_ADD_PREFIX(glVertex2d)
+#  define glVertex2fv		TGL_ADD_PREFIX(glVertex2fv)
+#  define glVertex2dv		TGL_ADD_PREFIX(glVertex2dv)
+#  define glVertex3f		TGL_ADD_PREFIX(glVertex3f)
+#  define glVertex3d		TGL_ADD_PREFIX(glVertex3d)
+#  define glVertex3fv		TGL_ADD_PREFIX(glVertex3fv)
+#  define glVertex3dv		TGL_ADD_PREFIX(glVertex3dv)
+#  define glVertex4f		TGL_ADD_PREFIX(glVertex4f)
+#  define glVertex4d		TGL_ADD_PREFIX(glVertex4d)
+#  define glVertex4fv		TGL_ADD_PREFIX(glVertex4fv)
+#  define glVertex4dv		TGL_ADD_PREFIX(glVertex4dv)
+#  define glColor3f		TGL_ADD_PREFIX(glColor3f)
+#  define glColor3d		TGL_ADD_PREFIX(glColor3d)
+#  define glColor3fv		TGL_ADD_PREFIX(glColor3fv)
+#  define glColor3dv		TGL_ADD_PREFIX(glColor3dv)
+#  define glColor4f		TGL_ADD_PREFIX(glColor4f)
+#  define glColor4d		TGL_ADD_PREFIX(glColor4d)
+#  define glColor4fv		TGL_ADD_PREFIX(glColor4fv)
+#  define glColor4dv		TGL_ADD_PREFIX(glColor4dv)
+#  define glNormal3f		TGL_ADD_PREFIX(glNormal3f)
+#  define glNormal3d		TGL_ADD_PREFIX(glNormal3d)
+#  define glNormal3fv		TGL_ADD_PREFIX(glNormal3fv)
+#  define glNormal3dv		TGL_ADD_PREFIX(glNormal3dv)
+#  define glTexCoord1f		TGL_ADD_PREFIX(glTexCoord1f)
+#  define glTexCoord1d		TGL_ADD_PREFIX(glTexCoord1d)
+#  define glTexCoord1fv		TGL_ADD_PREFIX(glTexCoord1fv)
+#  define glTexCoord1dv		TGL_ADD_PREFIX(glTexCoord1dv)
+#  define glTexCoord2f		TGL_ADD_PREFIX(glTexCoord2f)
+#  define glTexCoord2d		TGL_ADD_PREFIX(glTexCoord2d)
+#  define glTexCoord2fv		TGL_ADD_PREFIX(glTexCoord2fv)
+#  define glTexCoord2dv		TGL_ADD_PREFIX(glTexCoord2dv)
+#  define glTexCoord3f		TGL_ADD_PREFIX(glTexCoord3f)
+#  define glTexCoord3d		TGL_ADD_PREFIX(glTexCoord3d)
+#  define glTexCoord3fv		TGL_ADD_PREFIX(glTexCoord3fv)
+#  define glTexCoord3dv		TGL_ADD_PREFIX(glTexCoord3dv)
+#  define glTexCoord4f		TGL_ADD_PREFIX(glTexCoord4f)
+#  define glTexCoord4d		TGL_ADD_PREFIX(glTexCoord4d)
+#  define glTexCoord4fv		TGL_ADD_PREFIX(glTexCoord4fv)
+#  define glTexCoord4dv		TGL_ADD_PREFIX(glTexCoord4dv)
+#endif
+
+/* functions */
+
+void glEnable(GLint code);
+void glDisable(GLint code);
+
+
+void glShadeModel(GLint mode);
+void glCullFace(GLint mode);
+void glPolygonMode(GLint face,GLint mode);
+
+void glBegin(GLint type);
+void glEnd(void);
+void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
+void glDrawBuffer(GLenum mode);
+void glReadBuffer(GLenum mode);
+void glReadPixels(	GLint x,
+					GLint y,
+					GLsizei width,
+					GLsizei height,
+					GLenum format,
+					GLenum type,
+					void * data);
+void glDrawArrays(	GLenum mode,
+ 					GLint first,
+ 					GLsizei count);
+
+void glSetEnableSpecular(GLint s); 
+void* glGetTexturePixmap(GLint text, GLint level, GLint* xsize, GLint* ysize); 
+void glDrawText(const GLubyte* text, GLint x, GLint y, GLuint pixel); 
+void glTextSize(GLTEXTSIZE mode); 
+void glPlotPixel(GLint x, GLint y, GLuint pixel); 
+
+void glVertex2f(GLfloat ,GLfloat);
+void glVertex2d(GLdouble ,GLdouble);
+void glVertex2fv(GLfloat *);
+void glVertex2dv(GLdouble *);
+
+void glVertex3f(GLfloat ,GLfloat ,GLfloat);
+void glVertex3d(GLdouble ,GLdouble ,GLdouble);
+void glVertex3fv(GLfloat *);
+void glVertex3dv(GLdouble *);
+
+void glVertex4f(GLfloat ,GLfloat ,GLfloat, GLfloat );
+void glVertex4d(GLdouble ,GLdouble ,GLdouble, GLdouble );
+void glVertex4fv(GLfloat *);
+void glVertex4dv(GLdouble *);
+
+void glColor3f(GLfloat ,GLfloat ,GLfloat);
+void glColor3d(GLdouble ,GLdouble ,GLdouble);
+void glColor3fv(GLfloat *);
+void glColor3dv(GLdouble *);
+
+void glColor4f(GLfloat ,GLfloat ,GLfloat, GLfloat );
+void glColor4d(GLdouble ,GLdouble ,GLdouble, GLdouble );
+void glColor4fv(GLfloat *);
+void glColor4dv(GLdouble *);
+
+void glNormal3f(GLfloat ,GLfloat ,GLfloat);
+void glNormal3d(GLdouble ,GLdouble ,GLdouble);
+void glNormal3fv(GLfloat *);
+void glNormal3dv(GLdouble *);
+
+void glTexCoord1f(GLfloat);
+void glTexCoord1d(GLdouble);
+void glTexCoord1fv(GLfloat *);
+void glTexCoord1dv(GLdouble *);
+
+void glTexCoord2f(GLfloat ,GLfloat);
+void glTexCoord2d(GLdouble ,GLdouble);
+void glTexCoord2fv(GLfloat *);
+void glTexCoord2dv(GLdouble *);
+
+void glTexCoord3f(GLfloat ,GLfloat ,GLfloat);
+void glTexCoord3d(GLdouble ,GLdouble ,GLdouble);
+void glTexCoord3fv(GLfloat *);
+void glTexCoord3dv(GLdouble *);
+
+void glTexCoord4f(GLfloat ,GLfloat ,GLfloat, GLfloat );
+void glTexCoord4d(GLdouble ,GLdouble ,GLdouble, GLdouble );
+void glTexCoord4fv(GLfloat *);
+void glTexCoord4dv(GLdouble *);
+
+
+void glEdgeFlag(GLint flag);
+
+/* matrix */
+void glMatrixMode(GLint mode);
+void glLoadMatrixf(const GLfloat *m);
+void glLoadIdentity(void);
+void glMultMatrixf(const GLfloat *m);
+void glPushMatrix(void);
+void glPopMatrix(void);
+void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+void glTranslatef(GLfloat x, GLfloat y, GLfloat z);
+void glScalef(GLfloat x,GLfloat y,GLfloat z);
+
+void glViewport(GLint x,GLint y,GLint width,GLint height);
+void glFrustum(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,
+               GLdouble near,GLdouble far);
+
+/* lists */
+GLuint glGenLists(GLint range);
+GLint glIsList(GLuint list);
+void glNewList(GLuint list,GLint mode);
+void glEndList(void);
+void glCallList(GLuint list);
+void glCallLists(	GLsizei n,
+				 	GLenum type,
+				 	const GLuint* lists);
+void glListBase(GLint n);
+void glDeleteList(GLuint list);
+void glDeleteLists(GLuint list, GLuint range);
+/* clear */
+void glClear(GLint mask);
+void glClearColor(GLfloat r,GLfloat g,GLfloat b,GLfloat a);
+void glClearDepth(GLdouble depth);
+
+/* Feedback */
+void glFeedbackBuffer(GLint size, GLenum type, GLfloat* buf);
+void glPassThrough(GLfloat token);
+
+/* selection */
+GLint glRenderMode(GLint mode);
+void glSelectBuffer(GLint size,GLuint *buf);
+
+void glInitNames(void);
+void glPushName(GLuint name);
+void glPopName(void);
+void glLoadName(GLuint name);
+
+/* textures */
+void glGenTextures(GLint n, GLuint *textures);
+void glDeleteTextures(GLint n, const GLuint *textures);
+void glBindTexture(GLint target,GLint texture);
+void glTexImage2D( GLint target, GLint level, GLint components,
+		    GLint width, GLint height, GLint border,
+                    GLint format, GLint type, void *pixels);
+
+void glTexImage1D( GLint target, GLint level, GLint components,
+		    		GLint width, GLint border,
+                    GLint format, GLint type, void *pixels);
+void glCopyTexImage2D(	GLenum target,
+					 	GLint level,
+					 	GLenum internalformat,
+					 	GLint x,
+					 	GLint y,
+					 	GLsizei width,
+					 	GLsizei height,
+					 	GLint border);
+void glTexEnvi(GLint target,GLint pname,GLint param);
+
+void glTexParameteri(GLint target,GLint pname,GLint param);
+
+GLboolean glAreTexturesResident(	GLsizei n,
+								 	const GLuint * textures,
+								 	GLboolean * residences);
+GLboolean glIsTexture(	GLuint texture);
+/* lighting */
+
+void glMaterialfv(GLint mode,GLint type,GLfloat *v);
+void glMaterialf(GLint mode,GLint type,GLfloat v);
+void glColorMaterial(GLint mode,GLint type);
+
+void glLightfv(GLint light,GLint type,GLfloat *v);
+void glLightf(GLint light,GLint type,GLfloat v);
+void glLightModeli(GLint pname,GLint param);
+void glLightModelfv(GLint pname,GLfloat *param);
+
+/* misc */
+
+void glFlush(void);
+void glFinish(void);
+void glHint(GLint target,GLint mode);
+void glGetIntegerv(GLint pname,GLint *params);
+void glGetFloatv(GLint pname, GLfloat *v);
+const GLubyte* glGetString(GLenum name);
+GLenum glGetError();
+void glFrontFace(GLint mode);
+
+/* opengl 1.2 arrays */
+void glEnableClientState(GLenum array);
+void glDisableClientState(GLenum array);
+void glArrayElement(GLint i);
+void glVertexPointer(GLint size, GLenum type, GLsizei stride, 
+                     const GLvoid *pointer);
+void glColorPointer(GLint size, GLenum type, GLsizei stride, 
+                     const GLvoid *pointer);
+void glNormalPointer(GLenum type, GLsizei stride, 
+                      const GLvoid *pointer);
+void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, 
+                       const GLvoid *pointer);
+/* opengl 2.0 buffers */
+void glGenBuffers(	GLsizei n,
+ 					GLuint * buffers);
+void glDeleteBuffers(	GLsizei n,
+					 	const GLuint * buffers);
+void glBindBuffer(	GLenum target,
+ 					GLuint buffer);
+GLboolean glIsBuffer(	GLuint buffer);
+void *glMapBuffer(	GLenum target,
+				 	GLenum access);
+void glBufferData(	GLenum target,
+				 	GLsizei size,
+				 	const void * data,
+				 	GLenum usage);
+
+void glBindBufferAsArray(GLenum target, GLuint buffer, GLenum type, GLint size, GLint stride);
+
+/* opengl 1.2 polygon offset */
+void glPolygonOffset(GLfloat factor, GLfloat units);
+void glBlendFunc(GLint, GLint);
+void glBlendEquation(GLenum mode);
+void glDepthMask(GLint);
+
+/* Point Size */
+void glPointSize(GLfloat);
+
+/* Raster rendering */
+void glRasterPos2f(GLfloat, GLfloat);
+void glRasterPos3f(GLfloat, GLfloat, GLfloat);
+void glRasterPos4f(GLfloat, GLfloat, GLfloat, GLfloat);
+
+void glRasterPos2fv(GLfloat* v);
+void glRasterPos3fv(GLfloat* v);
+void glRasterPos4fv(GLfloat* v);
+void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, void* data);
+void glPixelZoom(GLfloat x, GLfloat y);
+
+/* PostProcessing pass implementation */
+void glPostProcess(GLuint (*postprocess)(GLint x, GLint y, GLuint pixel, GLushort z));
+/* not implemented, just added to compile  */
+  /*
+
+  
+inline void glLineWidth(GLfloat) {}
+inline void glDepthFunc(GLint) {}
+
+inline void glTexEnvf(GLint, GLint, GLint) {}
+inline void glOrtho(GLfloat,GLfloat,GLfloat,GLfloat,GLfloat,GLfloat){}
+inline void glVertex2i(GLint,GLint) {}
+inline void glDepthMask(GLint) {}
+inline void glFogi(GLint, GLint) {}
+inline void glFogfv(GLint, const GLfloat*) {}
+inline void glFogf(GLint, GLfloat) {}
+inline void glTexParameterf(GLint, GLint, GLint) {};
+  */
+void glPolygonStipple(void* a);
+/* non compatible functions */
+
+void glDebug(GLint mode);
+
+void glInit(void *zbuffer);
+void glClose(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/other/tinygl/include/zbuffer.h b/src/other/tinygl/include/zbuffer.h
new file mode 100644
index 0000000000..1b8d83a432
--- /dev/null
+++ b/src/other/tinygl/include/zbuffer.h
@@ -0,0 +1,354 @@
+#ifndef _tgl_zbuffer_h_
+#define _tgl_zbuffer_h_
+
+/*
+ * Z buffer
+ */
+
+#include "zfeatures.h"
+#include "TGL/gl.h"
+
+
+#define ZB_Z_BITS 16
+
+#define ZB_POINT_Z_FRAC_BITS 14
+
+
+
+
+
+#define ZB_POINT_S_MIN ( (1<<ZB_POINT_S_FRAC_BITS) )
+#define ZB_POINT_S_MAX ( (1<<(1+TGL_FEATURE_TEXTURE_POW2+ZB_POINT_S_FRAC_BITS))-ZB_POINT_S_MIN )
+#define ZB_POINT_T_MIN ( (1<<ZB_POINT_T_FRAC_BITS) )
+#define ZB_POINT_T_MAX ( (1<<(1+TGL_FEATURE_TEXTURE_POW2+ZB_POINT_T_FRAC_BITS))-ZB_POINT_T_MIN )
+#define ZB_POINT_S_VALUE (ZB_POINT_S_FRAC_BITS + 4)
+#define ZB_POINT_T_VALUE (ZB_POINT_T_FRAC_BITS - 4)
+#define ZB_S_MASK ((TGL_FEATURE_TEXTURE_DIM-1)<<(ZB_POINT_S_FRAC_BITS+1))
+#define ZB_T_MASK ((TGL_FEATURE_TEXTURE_DIM-1)<<(ZB_POINT_T_FRAC_BITS+1))
+
+#if ZB_POINT_T_FRAC_BITS == (ZB_POINT_S_FRAC_BITS + TGL_FEATURE_TEXTURE_POW2)
+#define ST_TO_TEXTURE_BYTE_OFFSET(s,t) ( ((s & ZB_S_MASK) | (t & ZB_T_MASK)) >> (ZB_POINT_S_VALUE-PSZSH))
+#else
+#define ST_TO_TEXTURE_BYTE_OFFSET(s,t) ( ((s & ZB_S_MASK)>>(ZB_POINT_S_VALUE-PSZSH)) | ((t & ZB_T_MASK)>>(ZB_POINT_T_VALUE-PSZSH))  )
+#endif
+
+/*The corrected mult mask prevents a bug relating to color interp. it's also why the color bit depth is so damn high.*/
+#define COLOR_MULT_MASK (0xff0000)
+#define COLOR_CORRECTED_MULT_MASK (0xfe0000)
+#define COLOR_MASK 		(0xffffff)
+#define COLOR_MIN_MULT (0x00ffff)
+#define COLOR_SHIFT		16
+
+#define COLOR_R_GET32(r) ((r) & 0xff0000)
+#define COLOR_G_GET32(g) ((g>>8) & 0xff00)
+#define COLOR_B_GET32(b) ((b >>16)&0xff)
+
+#define COLOR_R_GET16(r) ((r>>8) & 0xF800)
+#define COLOR_G_GET16(g) ((((g)) >> 13) & 0x07E0)
+#define COLOR_B_GET16(b) (((b) >> 19) & 31)
+
+#if TGL_FEATURE_RENDER_BITS == 32
+#define RGB_TO_PIXEL(r,g,b) \
+  ( COLOR_R_GET32(r) | COLOR_G_GET32(g) | COLOR_B_GET32(b) )
+#elif TGL_FEATURE_RENDER_BITS == 16
+#define RGB_TO_PIXEL(r,g,b) \
+	( COLOR_R_GET16(r) | COLOR_G_GET16(g) | COLOR_B_GET16(b)  )
+#endif
+/*This is how textures are sampled. if you want to do some sort of fancy texture filtering,*/
+/*you do it here.*/
+#define TEXTURE_SAMPLE(texture, s, t)														\
+ (*(PIXEL*)( (GLbyte*)texture + 															\
+ ST_TO_TEXTURE_BYTE_OFFSET(s,t) 								\
+ ))
+/* display modes */
+#define ZB_MODE_5R6G5B  1  /* true color 16 bits */
+#define ZB_MODE_INDEX   2  /* color index 8 bits */
+#define ZB_MODE_RGBA    3  /* 32 bit ABGR mode */
+#define ZB_MODE_RGB24   4  /* 24 bit rgb mode */
+#define ZB_NB_COLORS    225 /* number of colors for 8 bit display */
+
+
+
+#define TGL_CLAMPI(imp) ( (imp>0)?((imp>COLOR_MASK)?COLOR_MASK:imp):0   )
+
+
+
+
+#if TGL_FEATURE_RENDER_BITS == 32
+
+/* 32 bit mode */
+
+#define GET_REDDER(p) ((p & 0xff0000))
+#define GET_GREENER(p) ((p & 0xff00)<<8)
+#define GET_BLUEER(p) ((p & 0xff)<<16)
+/*These never change, DO NOT CHANGE THESE BASED ON COLOR INTERP BIT DEPTH*/
+#define GET_RED(p) ((p>>16)&0xff)
+#define GET_GREEN(p) ((p>>8)&0xff)
+#define GET_BLUE(p) (p&0xff)
+typedef GLuint PIXEL;
+#define PSZB 4
+#define PSZSH 5
+
+#elif TGL_FEATURE_RENDER_BITS == 16
+
+/* 16 bit mode */
+#define GET_REDDER(p) ((p & 0xF800)<<8)
+#define GET_GREENER(p) ((p & 0x07E0)<<13)
+#define GET_BLUEER(p) ((p & 31)<<19)
+/*DO NOT CHANGE THESE BASED ON COLOR INTERP BITDEPTH*/
+#define GET_RED(p) ((p & 0xF800)>>8)
+#define GET_GREEN(p) ((p & 0x07E0)>>3)
+#define GET_BLUE(p) ((p & 31)<<3)
+
+
+typedef GLushort PIXEL;
+#define PSZB 2 
+#define PSZSH 4 
+
+
+#else
+#error "wrong TGL_FEATURE_RENDER_BITS"
+#endif
+
+#if TGL_FEATURE_LIT_TEXTURES == 1
+#define RGB_MIX_FUNC(rr, gg, bb, tpix) \
+	RGB_TO_PIXEL( \
+		((rr * GET_RED(tpix))>>8),\
+		((gg * GET_GREEN(tpix))>>8),\
+		((bb * GET_BLUE(tpix))>>8)\
+	)
+#else
+#define RGB_MIX_FUNC(rr, gg, bb, tpix)(tpix)
+#endif
+
+
+
+#define TGL_NO_BLEND_FUNC(source, dest){dest = source;}
+#define TGL_NO_BLEND_FUNC_RGB(rr, gg, bb, dest){dest = RGB_TO_PIXEL(rr,gg,bb);}
+
+#if TGL_FEATURE_BLEND == 1
+#define TGL_BLEND_VARS GLuint zbblendeq = zb->blendeq; GLuint sfactor = zb->sfactor; GLuint dfactor = zb->dfactor;
+
+/*SORCERY to achieve 32 bit signed integer clamping*/
+
+
+#define TGL_BLEND_SWITCH_CASE(sr,sg,sb,dr,dg,db,dest) 									\
+		switch(zbblendeq){															\
+			case GL_FUNC_ADD:															\
+			default:																	\
+				sr+=dr;sg+=dg;sb+=db;													\
+				sr = TGL_CLAMPI(sr);													\
+				sg = TGL_CLAMPI(sg);													\
+				sb = TGL_CLAMPI(sb);													\
+				dest = RGB_TO_PIXEL(sr,sg,sb);											\
+			break;																		\
+			case GL_FUNC_SUBTRACT:														\
+				sr-=dr;sg-=dg;sb-=db;													\
+				sr = TGL_CLAMPI(sr);													\
+				sg = TGL_CLAMPI(sg);													\
+				sb = TGL_CLAMPI(sb);													\
+				dest = RGB_TO_PIXEL(sr,sg,sb);											\
+			break;																		\
+			case GL_FUNC_REVERSE_SUBTRACT:												\
+				sr=dr-sr;sg=dg-sg;sb=db-sb;												\
+				sr = TGL_CLAMPI(sr);													\
+				sg = TGL_CLAMPI(sg);													\
+				sb = TGL_CLAMPI(sb);													\
+				dest = RGB_TO_PIXEL(sr,sg,sb);											\
+			break;																		\
+			  																			\
+		}
+
+
+
+
+#define TGL_BLEND_FUNC(source, dest){													\
+	{																					\
+	GLuint sr, sg, sb, dr, dg, db;														\
+	{	GLuint temp = source;																\
+	sr = GET_REDDER(temp); sg = GET_GREENER(temp); sb = GET_BLUEER(temp);						\
+	temp = dest;																			\
+	dr = GET_REDDER(temp); dg = GET_GREENER(temp); db = GET_BLUEER(temp);}						\
+		/*printf("\nShould never reach this point!");*/									\
+		switch(sfactor){															\
+			case GL_ONE:																\
+			default:																	\
+			break;																		\
+			case GL_ONE_MINUS_SRC_COLOR:												\
+			sr = ~sr & COLOR_MASK;															\
+			sg = ~sg & COLOR_MASK;															\
+			sb = ~sb & COLOR_MASK;															\
+			break;																		\
+			case GL_ZERO:																\
+			sr=0;sg=0;sb=0;break;														\
+			break;																		\
+		}																				\
+		switch(dfactor){															\
+				case GL_ONE:															\
+				default:																\
+				break;																	\
+				case GL_ONE_MINUS_DST_COLOR:											\
+				dr = ~dr & COLOR_MASK;														\
+				dg = ~dg & COLOR_MASK;														\
+				db = ~db & COLOR_MASK;														\
+				break;																	\
+				case GL_ZERO:															\
+				dr=0;dg=0;db=0;break;													\
+				break;																	\
+			}																			\
+		TGL_BLEND_SWITCH_CASE(sr,sg,sb,dr,dg,db,dest)									\
+	}																					\
+} 
+
+#define TGL_BLEND_FUNC_RGB(rr, gg, bb, dest){											\
+	{																					\
+		GLint sr = rr & COLOR_MASK, sg = gg & COLOR_MASK, sb = bb & COLOR_MASK, dr, dg, db;			\
+		{GLuint temp = dest;																\
+		dr = GET_REDDER(temp); dg = GET_GREENER(temp); db = GET_BLUEER(temp);}					\
+	/*printf("\nShould never reach this point!");*/										\
+		switch(sfactor){																\
+			case GL_ONE:																\
+			default:																	\
+			break;																		\
+			case GL_ONE_MINUS_SRC_COLOR:												\
+			sr = ~sr & COLOR_MASK;															\
+			sg = ~sg & COLOR_MASK;															\
+			sb = ~sb & COLOR_MASK;															\
+			break;																		\
+			case GL_ZERO:																\
+			sr=0;sg=0;sb=0;break;														\
+			break;																		\
+		}																				\
+		switch(dfactor){															\
+				case GL_ONE:															\
+				default:																\
+				break;																	\
+				case GL_ONE_MINUS_DST_COLOR:											\
+				dr = ~dr & COLOR_MASK;														\
+				dg = ~dg & COLOR_MASK;														\
+				db = ~db & COLOR_MASK;														\
+				break;																	\
+				case GL_ZERO:															\
+				dr=0;dg=0;db=0;break;													\
+				break;																	\
+		}																				\
+		TGL_BLEND_SWITCH_CASE(sr,sg,sb,dr,dg,db,dest)									\
+	}																					\
+} 
+
+#else
+#define TGL_BLEND_VARS /* a comment */
+#define TGL_BLEND_FUNC(source, dest){dest = source;}
+#define TGL_BLEND_FUNC_RGB(rr, gg, bb, dest){dest = RGB_TO_PIXEL(rr,gg,bb);}
+#endif
+
+
+typedef struct {
+
+    
+    
+    GLushort *zbuf;
+    PIXEL *pbuf;
+    PIXEL *current_texture;
+    
+
+	/* point size*/
+    GLfloat pointsize;
+
+
+
+
+
+    /* opengl polygon stipple*/
+
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+    GLubyte stipplepattern[TGL_POLYGON_STIPPLE_BYTES];
+    GLuint dostipple;
+#endif
+	GLenum blendeq, sfactor, dfactor;
+    GLint enable_blend;
+    GLint xsize,ysize;
+    GLint linesize; /* line size, in bytes */
+    /* depth */
+    GLint depth_test;
+    GLint depth_write;
+    GLubyte frame_buffer_allocated;
+} ZBuffer;
+
+typedef struct {
+  GLint x,y,z;     /* integer coordinates in the zbuffer */
+  GLint s,t;       /* coordinates for the mapping */
+  GLint r,g,b;     /* color indexes */
+  
+  GLfloat sz,tz;   /* temporary coordinates for mapping */
+} ZBufferPoint;
+
+/* zbuffer.c */
+
+ZBuffer *ZB_open(int xsize,int ysize,int mode,
+
+
+
+		 void *frame_buffer);
+
+
+void ZB_close(ZBuffer *zb);
+
+void ZB_resize(ZBuffer *zb,void *frame_buffer,GLint xsize,GLint ysize);
+void ZB_clear(ZBuffer *zb,GLint clear_z,GLint z,
+	      GLint clear_color,GLint r,GLint g,GLint b);
+/* linesize is in BYTES */
+void ZB_copyFrameBuffer(ZBuffer *zb,void *buf,GLint linesize);
+
+/* zdither.c */
+
+/*
+void ZB_initDither(ZBuffer *zb,GLint nb_colors,
+		   unsigned char *color_indexes,GLint *color_table);
+void ZB_closeDither(ZBuffer *zb);
+void ZB_ditherFrameBuffer(ZBuffer *zb,unsigned char *dest,
+			  GLint linesize);
+*/
+/* zline.c */
+
+void ZB_plot(ZBuffer *zb,ZBufferPoint *p);
+void ZB_line(ZBuffer *zb,ZBufferPoint *p1,ZBufferPoint *p2);
+void ZB_line_z(ZBuffer * zb, ZBufferPoint * p1, ZBufferPoint * p2);
+
+/* ztriangle.c */
+
+void ZB_setTexture(ZBuffer *zb, PIXEL *texture);
+
+void ZB_fillTriangleFlat(ZBuffer *zb,
+		 ZBufferPoint *p1,ZBufferPoint *p2,ZBufferPoint *p3);
+
+void ZB_fillTriangleFlatNOBLEND(ZBuffer *zb,
+		 ZBufferPoint *p1,ZBufferPoint *p2,ZBufferPoint *p3);
+
+
+void ZB_fillTriangleSmooth(ZBuffer *zb,
+		   ZBufferPoint *p1,ZBufferPoint *p2,ZBufferPoint *p3);
+
+void ZB_fillTriangleSmoothNOBLEND(ZBuffer *zb,
+		   ZBufferPoint *p1,ZBufferPoint *p2,ZBufferPoint *p3);
+/*
+This function goes unused and is removed by Gek.
+void ZB_fillTriangleMapping(ZBuffer *zb,
+		    ZBufferPoint *p1,ZBufferPoint *p2,ZBufferPoint *p3);
+*/
+void ZB_fillTriangleMappingPerspective(ZBuffer *zb,
+                    ZBufferPoint *p0,ZBufferPoint *p1,ZBufferPoint *p2);
+
+
+void ZB_fillTriangleMappingPerspectiveNOBLEND(ZBuffer *zb,
+                    ZBufferPoint *p0,ZBufferPoint *p1,ZBufferPoint *p2);
+
+typedef void (*ZB_fillTriangleFunc)(ZBuffer  *,
+	    ZBufferPoint *,ZBufferPoint *,ZBufferPoint *);
+
+/* memory.c */
+extern void gl_free(void *p);
+extern void *gl_malloc(GLint size);
+extern void *gl_zalloc(GLint size);
+
+#endif /* _tgl_zbuffer_h_ */
diff --git a/src/other/tinygl/include/zfeatures.h b/src/other/tinygl/include/zfeatures.h
new file mode 100644
index 0000000000..3c086d168a
--- /dev/null
+++ b/src/other/tinygl/include/zfeatures.h
@@ -0,0 +1,142 @@
+#ifndef _tgl_features_h_
+#define _tgl_features_h_
+/* It is possible to enable/disable (compile time) features in this
+   header file. */
+/*
+Enables setting the error flags when there's an error, so you can check it with glGetError
+Disabling this has slight performance gains.
+*/
+#define TGL_FEATURE_ERROR_CHECK 0
+/*
+Strict out-of-memory checking. All OpenGL function calls are invalidated (ALL OF THEM) if a GL_OUT_OF_MEMORY error occurs.
+This means that TinyGL has to constantly check all gl_malloc() attempts for errors and the state of the error state variable.
+The checks slow down the renderer so it is not recommended , but
+it's in the GL spec that this should occur.
+*/
+#define TGL_FEATURE_STRICT_OOM_CHECKS 0
+
+/*
+Swap between using the inline'd malloc(), calloc(), and free() in zbuffer.h, or
+a replacement gl_malloc(), gl_zalloc(), and gl_free() in memory.c
+*/
+#define TGL_FEATURE_CUSTOM_MALLOC 0
+
+/*
+Use Fast Inverse Square Root. Toggleable because it's actually slower on some platforms,
+And because some systems may have float types which are incompatible with it.
+*/
+#define TGL_FEATURE_FISR 0
+
+#define TGL_FEATURE_ARRAYS         1
+
+#define TGL_FEATURE_DISPLAYLISTS   1
+
+#define TGL_FEATURE_LIT_TEXTURES   1
+/*Enable the patternized "discard"-ing of pixels.*/
+#define TGL_FEATURE_POLYGON_STIPPLE 0
+/*Enable the use of GL_SELECT and GL_FEEDBACK*/
+#define TGL_FEATURE_ALT_RENDERMODES 0
+/*
+Enable the rendering of large polygons (in terms of vertex count)
+Also enabled the rendering of line loops.
+the maximum number of vertices in a polygon is defined in zgl.h
+*/
+#define TGL_FEATURE_GL_POLYGON      0
+
+#define TGL_FEATURE_BLEND 			1
+
+#define TGL_FEATURE_BLEND_DRAW_PIXELS 0
+/*The width of textures as a power of 2. The default is 8, or 256x256 textures.*/
+#define TGL_FEATURE_TEXTURE_POW2	8
+#define TGL_FEATURE_TEXTURE_DIM		(1<<TGL_FEATURE_TEXTURE_POW2)
+
+/*A stipple pattern is 128 bytes in size.*/
+#define TGL_POLYGON_STIPPLE_BYTES 128
+/*A stipple pattern is 2^5 (32) bits wide.*/
+#define TGL_POLYGON_STIPPLE_POW2_WIDTH 5
+#define TGL_POLYGON_STIPPLE_MASK_X 31
+#define TGL_POLYGON_STIPPLE_MASK_Y 31
+
+/*Use lookup tables for calculating specular light.*/
+#define TGL_FEATURE_SPECULAR_BUFFERS 0
+
+/*Prevent ZB_copyFrameBuffer from copying certain colors.*/
+#define TGL_FEATURE_NO_COPY_COLOR 0
+/*Don't draw (texture mapped) pixels whose color is the NO_DRAW_COLOR*/
+#define TGL_FEATURE_NO_DRAW_COLOR 1
+/*Regardless of the current clear color, always clear using the NO_COPY_COLOR*/
+#define TGL_FEATURE_FORCE_CLEAR_NO_COPY_COLOR 0
+#define TGL_NO_COPY_COLOR 0xff00ff
+#define TGL_NO_DRAW_COLOR 0xff00ff
+/* solid debug pink.*/
+#define TGL_COLOR_MASK 0x00ffffff
+/* mask to check for while drawing/copying.*/
+
+
+
+
+#define TGL_FEATURE_MULTITHREADED_DRAWPIXELS	1
+
+#define TGL_FEATURE_MULTITHREADED_COPY_TEXIMAGE_2D 1
+
+#define TGL_FEATURE_MULTITHREADED_ZB_COPYBUFFER 0
+
+/*
+!!!!!WARNING!!!!!
+TGL_FEATURE_ALIGNAS assumes that the implementation's malloc (AND REALLOC) are 16-byte aligned.
+
+Disabled by default for compatibility- you should only enable this if you KNOW that the target ALWAYS
+returns 16-byte aligned pointers.
+*/
+
+#define TGL_FEATURE_ALIGNAS 0
+/*
+Optimization hint- cost of branching.
+0- branching has zero cost, avoid extraneous code.
+1- Branching has some cost, allow some extraneous code
+2- Branching has extreme cost, allow a lot of extraneous code. Modern processors work best on this setting.
+*/
+#define TGL_OPTIMIZATION_HINT_BRANCH_COST 2
+
+
+#ifdef __TINYC__
+#undef TGL_FEATURE_ALIGNAS
+#define TGL_FEATURE_ALIGNAS 0
+#endif
+
+
+#if TGL_FEATURE_ALIGNAS == 1
+#include <stdalign.h>
+#define TGL_ALIGN alignas(16)
+#else
+#define TGL_ALIGN /*a comment*/
+#endif
+
+
+#define TGL_FEATURE_16_BITS        0
+#define TGL_FEATURE_32_BITS        1
+
+#if TGL_FEATURE_32_BITS == 1
+#define TGL_FEATURE_RENDER_BITS    32
+
+#elif TGL_FEATURE_16_BITS == 1
+#define TGL_FEATURE_RENDER_BITS    16
+
+#else
+#error "Unsupported TGL_FEATURE_XX_BITS"
+
+#endif
+
+/*The fraction bits in the fixed point values used for S and T in interpolatiion.*/
+#define ZB_POINT_S_FRAC_BITS 10
+#define ZB_POINT_T_FRAC_BITS (ZB_POINT_S_FRAC_BITS + TGL_FEATURE_TEXTURE_POW2)
+
+/*Test the compatibility of the target platform at glInit() time.*/
+#define TGL_FEATURE_TINYGL_RUNTIME_COMPAT_TEST 1
+
+#define TINYGL_VERSION 1.0
+
+#endif 
+/* _tgl_features_h_ */
+
+
diff --git a/src/other/tinygl/lib/keep_alive.txt b/src/other/tinygl/lib/keep_alive.txt
new file mode 100644
index 0000000000..73256ff3a7
--- /dev/null
+++ b/src/other/tinygl/lib/keep_alive.txt
@@ -0,0 +1 @@
+hey git could you not delete this folder thanks
diff --git a/src/other/tinygl/src/.clang-format b/src/other/tinygl/src/.clang-format
new file mode 100644
index 0000000000..bc3fbd28f7
--- /dev/null
+++ b/src/other/tinygl/src/.clang-format
@@ -0,0 +1,118 @@
+---
+Language:        Cpp
+# BasedOnStyle:  LLVM
+AccessModifierOffset: -2
+AlignAfterOpenBracket: Align
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Right
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: All
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: MultiLine
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:   
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   false
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      false
+  AfterExternBlock: false
+  BeforeCatch:     false
+  BeforeElse:      false
+  IndentBraces:    false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: false
+BreakInheritanceList: BeforeColon
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeColon
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: true
+ColumnLimit:     160
+CommentPragmas:  '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 4
+ContinuationIndentWidth: 4
+Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: true
+ForEachMacros:   
+  - foreach
+  - Q_FOREACH
+  - BOOST_FOREACH
+IncludeBlocks:   Preserve
+IncludeCategories: 
+  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
+    Priority:        2
+  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
+    Priority:        3
+  - Regex:           '.*'
+    Priority:        1
+IncludeIsMainRegex: '(Test)?$'
+IndentCaseLabels: false
+IndentPPDirectives: None
+IndentWidth:     4
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: true
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBinPackProtocolList: Auto
+ObjCBlockIndentWidth: 4
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyBreakTemplateDeclaration: 10
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 60
+PointerAlignment: Left
+ReflowComments:  true
+SortIncludes:    true
+SortUsingDeclarations: true
+SpaceAfterCStyleCast: false
+SpaceAfterTemplateKeyword: true
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeCpp11BracedList: false
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpaceBeforeParens: ControlStatements
+SpaceBeforeRangeBasedForLoopColon: true
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles:  false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        Cpp11
+TabWidth:        4
+UseTab:          Always
+...
+
diff --git a/src/other/tinygl/src/CMakeLists.txt b/src/other/tinygl/src/CMakeLists.txt
new file mode 100644
index 0000000000..821cf0c6d9
--- /dev/null
+++ b/src/other/tinygl/src/CMakeLists.txt
@@ -0,0 +1,61 @@
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+
+set(tinygl_srcs
+  accum.c
+  api.c
+  arrays.c
+  clear.c
+  clip.c
+  get.c
+  image_util.c
+  init.c
+  light.c
+  list.c
+  matrix.c
+  memory.c
+  misc.c
+  msghandling.c
+  select.c
+  specbuf.c
+  texture.c
+  vertex.c
+  zbuffer.c
+  zline.c
+  zmath.c
+  zpostprocess.c
+  zraster.c
+  ztext.c
+  ztriangle.c
+  )
+
+if(TINYGL_BUILD_SHARED)
+  add_library(tinygl SHARED ${tinygl_srcs})
+  target_include_directories(tinygl PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/../include)
+  install(TARGETS tinygl
+    RUNTIME DESTINATION ${BIN_DIR}
+    LIBRARY DESTINATION ${LIB_DIR}
+    ARCHIVE DESTINATION ${LIB_DIR})
+  if(NOT MSVC)
+    target_compile_options(tinygl PRIVATE -O3 -DNDEBUG -pedantic -march=native -Wall -Wno-unused-function)
+  endif(NOT MSVC)
+endif(TINYGL_BUILD_SHARED)
+
+if(TINYGL_BUILD_STATIC)
+  add_library(tinygl-static STATIC ${tinygl_srcs})
+  target_include_directories(tinygl-static PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/../include)
+  install(TARGETS tinygl-static
+    RUNTIME DESTINATION ${BIN_DIR}
+    LIBRARY DESTINATION ${LIB_DIR}
+    ARCHIVE DESTINATION ${LIB_DIR})
+  if(NOT MSVC)
+    target_compile_options(tinygl-static PRIVATE -O3 -DNDEBUG -pedantic -march=native -Wall -Wno-unused-function)
+  endif(NOT MSVC)
+endif(TINYGL_BUILD_STATIC)
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
+
diff --git a/src/other/tinygl/src/LICENSE b/src/other/tinygl/src/LICENSE
new file mode 100644
index 0000000000..9c49e49a43
--- /dev/null
+++ b/src/other/tinygl/src/LICENSE
@@ -0,0 +1,22 @@
+Copyright notice:
+
+ (C) 1997-2021 Fabrice Bellard, Gek (DMHSW), C-Chads
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product and its documentation 
+     *is* required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+If you redistribute modified sources, I would appreciate that you
+include in the files history information documenting your changes.
diff --git a/src/other/tinygl/src/Makefile b/src/other/tinygl/src/Makefile
new file mode 100644
index 0000000000..3a6904a2e4
--- /dev/null
+++ b/src/other/tinygl/src/Makefile
@@ -0,0 +1,21 @@
+include ../config.mk
+
+OBJS= api.o list.o vertex.o init.o matrix.o texture.o \
+      misc.o clear.o light.o clip.o select.o get.o \
+      zbuffer.o zline.o ztriangle.o \
+      zmath.o image_util.o msghandling.o \
+      arrays.o specbuf.o memory.o ztext.o zraster.o accum.o zpostprocess.o
+
+
+INCLUDES = -I./include
+LIB = libTinyGL.a
+
+all: $(LIB)
+
+$(LIB): $(OBJS)
+	rm -f $(LIB)
+	ar rcs $(LIB) $(OBJS)
+clean:
+	rm -f *~ *.o *.a
+.c.o:
+	$(CC) $(CFLAGS_LIB) -c $*.c
diff --git a/src/other/tinygl/src/Makefile_Backup b/src/other/tinygl/src/Makefile_Backup
new file mode 100644
index 0000000000..33c25e3c51
--- /dev/null
+++ b/src/other/tinygl/src/Makefile_Backup
@@ -0,0 +1,40 @@
+include ../config.mk
+
+OBJS= api.o list.o vertex.o init.o matrix.o texture.o \
+      misc.o clear.o light.o clip.o select.o get.o \
+      zbuffer.o zline.o ztriangle.o \
+      zmath.o image_util.o msghandling.o \
+      arrays.o specbuf.o memory.o ztext.o zraster.o accum.o
+
+
+INCLUDES = -I./include
+LIB = libTinyGL.a
+
+all: $(LIB)
+#	mv $(LIB) ../lib/
+
+$(LIB): $(OBJS)
+	rm -f $(LIB)
+	ar rcs $(LIB) $(OBJS)
+	
+#SDL_Examples:
+#	cd SDL_Examples && $(MAKE) && cd ..
+clean:
+	rm -f *~ *.o *.a
+#	cd SDL_Examples && $(MAKE) clean && cd ..
+.c.o:
+	$(CC) $(CFLAGS) $(INCLUDES) -c $*.c
+
+clip.o: zgl.h ../include/zfeatures.h
+vertex.o: zgl.h ../include/zfeatures.h
+light.o: zgl.h ../include/zfeatures.h
+matrix.o: zgl.h ../include/zfeatures.h
+list.o: zgl.h opinfo.h ../include/zfeatures.h
+arrays.c: zgl.h ../include/zfeatures.h
+specbuf.o: zgl.h ../include/zfeatures.h
+glx.o: zgl.h ../include/zfeatures.h
+nglx.o: zgl.h ../include/zfeatures.h
+zline.o: zgl.h ../include/zfeatures.h zline.h
+
+ztriangle.o: ztriangle.c ztriangle.h zgl.h ../include/zfeatures.h
+	$(CC) $(CFLAGS) -Wno-uninitialized $(INCLUDES) -c $*.c
diff --git a/src/other/tinygl/src/accum.c b/src/other/tinygl/src/accum.c
new file mode 100644
index 0000000000..57fd83c83c
--- /dev/null
+++ b/src/other/tinygl/src/accum.c
@@ -0,0 +1,2 @@
+#include "zgl.h"
+
diff --git a/src/other/tinygl/src/api.c b/src/other/tinygl/src/api.c
new file mode 100644
index 0000000000..efa4184a2a
--- /dev/null
+++ b/src/other/tinygl/src/api.c
@@ -0,0 +1,670 @@
+#include "zgl.h"
+
+void gl_add_op(GLParam* p) {
+        GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+#include "error_check.h"
+#endif
+        GLint op;
+        op = p[0].op;
+        if (c->exec_flag) {
+                op_table_func[op](p);
+#if TGL_FEATURE_ERROR_CHECK == 1
+#include "error_check.h"
+#endif
+        }
+        if (c->compile_flag) {
+                gl_compile_op(p);
+#if TGL_FEATURE_ERROR_CHECK == 1
+#include "error_check.h"
+#endif
+        }
+}
+
+/* glVertex */
+
+void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+	GLParam p[5];
+#include "error_check_no_context.h"
+	p[0].op = OP_Vertex;
+	p[1].f = x;
+	p[2].f = y;
+	p[3].f = z;
+	p[4].f = w;
+
+	gl_add_op(p);
+}
+
+void glVertex2f(GLfloat x, GLfloat y) { glVertex4f(x, y, 0, 1); }
+
+void glVertex3f(GLfloat x, GLfloat y, GLfloat z) { glVertex4f(x, y, z, 1); }
+
+void glVertex3fv(GLfloat* v) { glVertex4f(v[0], v[1], v[2], 1); }
+
+/* glNormal */
+
+void glNormal3f(GLfloat x, GLfloat y, GLfloat z) {
+	GLParam p[4];
+#include "error_check_no_context.h"
+	p[0].op = OP_Normal;
+	p[1].f = x;
+	p[2].f = y;
+	p[3].f = z;
+	gl_add_op(p);
+}
+
+void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
+	glBegin(GL_QUADS);
+	glVertex2f(x1, y1);
+	glVertex2f(x2, y1);
+	glVertex2f(x2, y2);
+	glVertex2f(x1, y2);
+	glEnd();
+}
+
+void glNormal3fv(GLfloat* v) { glNormal3f(v[0], v[1], v[2]); }
+
+/* glColor */
+
+void glColor4f(GLfloat r, GLfloat g, GLfloat b, GLfloat a) {
+	GLParam p[8];
+#include "error_check_no_context.h"
+	p[0].op = OP_Color;
+	p[1].f = r;
+	p[2].f = g;
+	p[3].f = b;
+	p[4].f = a;
+	p[5].ui = (((GLuint)(r * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+	p[6].ui = (((GLuint)(g * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+	p[7].ui = (((GLuint)(b * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+	gl_add_op(p);
+}
+
+void glColor4fv(GLfloat* v) {
+	GLParam p[8];
+#include "error_check_no_context.h"
+	p[0].op = OP_Color;
+	p[1].f = v[0];
+	p[2].f = v[1];
+	p[3].f = v[2];
+	p[4].f = v[3];
+	p[5].ui = (((GLuint)(v[0] * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+	p[6].ui = (((GLuint)(v[1] * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+	p[7].ui = (((GLuint)(v[2] * COLOR_CORRECTED_MULT_MASK) + COLOR_MIN_MULT) & COLOR_MASK);
+
+	gl_add_op(p);
+}
+
+void glColor3f(GLfloat x, GLfloat y, GLfloat z) { glColor4f(x, y, z, 1); }
+
+void glColor3fv(GLfloat* v) { glColor4f(v[0], v[1], v[2], 1); }
+
+/* TexCoord */
+
+void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
+	GLParam p[5];
+#include "error_check_no_context.h"
+	p[0].op = OP_TexCoord;
+	p[1].f = s;
+	p[2].f = t;
+	p[3].f = r;
+	p[4].f = q;
+
+	gl_add_op(p);
+}
+
+void glTexCoord2f(GLfloat s, GLfloat t) { glTexCoord4f(s, t, 0, 1); }
+
+void glTexCoord2fv(GLfloat* v) { glTexCoord4f(v[0], v[1], 0, 1); }
+
+void glEdgeFlag(GLint flag) {
+	GLParam p[2];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (flag != GL_TRUE && flag != GL_FALSE)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+		p[0].op = OP_EdgeFlag;
+	p[1].i = flag;
+
+	gl_add_op(p);
+}
+
+/* misc */
+
+void glShadeModel(GLint mode) {
+	GLParam p[2];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (mode != GL_FLAT && mode != GL_SMOOTH)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	if (mode != GL_FLAT && mode != GL_SMOOTH)
+		return;
+#endif
+		p[0].op = OP_ShadeModel;
+	p[1].i = mode;
+
+	gl_add_op(p);
+}
+
+void glCullFace(GLint mode) {
+	GLParam p[2];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(mode == GL_BACK || mode == GL_FRONT || mode == GL_FRONT_AND_BACK))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	/* assert(mode == GL_BACK || mode == GL_FRONT || mode == GL_FRONT_AND_BACK);*/
+	/* Assume it's alrgiht.*/
+#endif
+		p[0].op = OP_CullFace;
+	p[1].i = mode;
+
+	gl_add_op(p);
+}
+
+void glFrontFace(GLint mode) {
+	GLParam p[2];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(mode == GL_CCW || mode == GL_CW))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	/* if(!(mode == GL_CCW || mode == GL_CW)) return;*/
+#endif
+		mode = (mode != GL_CCW);
+
+	p[0].op = OP_FrontFace;
+	p[1].i = mode;
+
+	gl_add_op(p);
+}
+
+void glPolygonMode(GLint face, GLint mode) {
+	GLParam p[3];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!((face == GL_BACK || face == GL_FRONT || face == GL_FRONT_AND_BACK) && (mode == GL_POINT || mode == GL_LINE || mode == GL_FILL)))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	/* assert(face == GL_BACK || face == GL_FRONT || face == GL_FRONT_AND_BACK);*/
+	/* assert(mode == GL_POINT || mode == GL_LINE || mode == GL_FILL);*/
+#endif
+		p[0].op = OP_PolygonMode;
+	p[1].i = face;
+	p[2].i = mode;
+
+	gl_add_op(p);
+}
+
+void glDepthMask(GLint i) {
+#include "error_check_no_context.h"
+	gl_get_context()->zb->depth_write = (i == GL_TRUE);
+}
+/* glEnable / glDisable */
+/* TODO go to glopEnableDisable and add error checking there on values there.*/
+void glEnable(GLint cap) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_EnableDisable;
+	p[1].i = cap;
+	p[2].i = 1;
+
+	gl_add_op(p);
+}
+
+void glDisable(GLint cap) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_EnableDisable;
+	p[1].i = cap;
+	p[2].i = 0;
+
+	gl_add_op(p);
+}
+
+/* glBegin / glEnd */
+
+void glBegin(GLint mode) {
+	GLParam p[2];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+	p[0].op = OP_Begin;
+	p[1].i = mode;
+#if TGL_FEATURE_ERROR_CHECK == 1
+	
+	if (mode != GL_POINTS && mode != GL_LINES && mode != GL_LINE_LOOP && mode != GL_LINE_STRIP &&
+#if TGL_FEATURE_GL_POLYGON == 1
+		mode != GL_POLYGON &&
+#endif
+		mode != GL_TRIANGLES && mode != GL_TRIANGLE_FAN && mode != GL_TRIANGLE_STRIP && mode != GL_QUADS && mode != GL_QUAD_STRIP)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+		gl_add_op(p);
+}
+
+void glEnd(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_End;
+
+	gl_add_op(p);
+}
+
+/* matrix */
+
+void glMatrixMode(GLint mode) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_MatrixMode;
+	p[1].i = mode;
+
+	gl_add_op(p);
+}
+
+void glLoadMatrixf(const GLfloat* m) {
+	GLParam p[17];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_LoadMatrix;
+	for (i = 0; i < 16; i++)
+		p[i + 1].f = m[i];
+
+	gl_add_op(p);
+}
+
+void glLoadIdentity(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_LoadIdentity;
+
+	gl_add_op(p);
+}
+
+void glMultMatrixf(const GLfloat* m) {
+	GLParam p[17];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_MultMatrix;
+	for (i = 0; i < 16; i++)
+		p[i + 1].f = m[i];
+
+	gl_add_op(p);
+}
+
+void glPushMatrix(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_PushMatrix;
+
+	gl_add_op(p);
+}
+
+void glPopMatrix(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_PopMatrix;
+
+	gl_add_op(p);
+}
+
+void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
+	GLParam p[5];
+#include "error_check_no_context.h"
+	p[0].op = OP_Rotate;
+	p[1].f = angle;
+	p[2].f = x;
+	p[3].f = y;
+	p[4].f = z;
+
+	gl_add_op(p);
+}
+
+void glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
+	GLParam p[4];
+#include "error_check_no_context.h"
+	p[0].op = OP_Translate;
+	p[1].f = x;
+	p[2].f = y;
+	p[3].f = z;
+
+	gl_add_op(p);
+}
+
+void glScalef(GLfloat x, GLfloat y, GLfloat z) {
+	GLParam p[4];
+#include "error_check_no_context.h"
+	p[0].op = OP_Scale;
+	p[1].f = x;
+	p[2].f = y;
+	p[3].f = z;
+
+	gl_add_op(p);
+}
+
+void glViewport(GLint x, GLint y, GLint width, GLint height) {
+	GLParam p[5];
+#include "error_check_no_context.h"
+	p[0].op = OP_Viewport;
+	p[1].i = x;
+	p[2].i = y;
+	p[3].i = width;
+	p[4].i = height;
+
+	gl_add_op(p);
+}
+
+void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble farv) {
+	GLParam p[7];
+#include "error_check_no_context.h"
+	p[0].op = OP_Frustum;
+	p[1].f = left;
+	p[2].f = right;
+	p[3].f = bottom;
+	p[4].f = top;
+	p[5].f = near;
+	p[6].f = farv;
+
+	gl_add_op(p);
+}
+
+/* lightening */
+
+void glMaterialfv(GLint mode, GLint type, GLfloat* v) {
+	GLParam p[7];
+	GLint i, n;
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(mode == GL_FRONT || mode == GL_BACK || mode == GL_FRONT_AND_BACK))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	/* assert(mode == GL_FRONT || mode == GL_BACK || mode == GL_FRONT_AND_BACK);*/
+#endif
+		p[0].op = OP_Material;
+	p[1].i = mode;
+	p[2].i = type;
+	n = 4;  /* This appears to be a hack... to avoid a jump instruction? What the hell?*/
+	if (type == GL_SHININESS)
+		n = 1;
+	for (i = 0; i < 4; i++)
+		p[3 + i].f = v[i];
+	for (i = n; i < 4; i++)
+		p[3 + i].f = 0;
+
+	gl_add_op(p);
+}
+
+void glMaterialf(GLint mode, GLint type, GLfloat v) {
+	GLParam p[7];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_Material;
+	p[1].i = mode;
+	p[2].i = type;
+	p[3].f = v;
+	for (i = 0; i < 3; i++)
+		p[4 + i].f = 0;
+
+	gl_add_op(p);
+}
+
+void glColorMaterial(GLint mode, GLint type) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_ColorMaterial;
+	p[1].i = mode;
+	p[2].i = type;
+
+	gl_add_op(p);
+}
+
+void glLightfv(GLint light, GLint type, GLfloat* v) {
+	GLParam p[7];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_Light;
+	p[1].i = light;
+	p[2].i = type;
+	/* TODO: 3 components ? */
+	for (i = 0; i < 4; i++)
+		p[3 + i].f = v[i];
+
+	gl_add_op(p);
+}
+
+void glLightf(GLint light, GLint type, GLfloat v) {
+	GLParam p[7];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_Light;
+	p[1].i = light;
+	p[2].i = type;
+	p[3].f = v;
+	for (i = 0; i < 3; i++)
+		p[4 + i].f = 0;
+
+	gl_add_op(p);
+}
+
+void glLightModeli(GLint pname, GLint param) {
+	GLParam p[6];
+#include "error_check_no_context.h"
+	p[0].op = OP_LightModel;
+	p[1].i = pname;
+	p[2].f = (GLfloat)param;
+	p[3].f = 0;
+	p[4].f = 0;
+	p[5].f = 0;
+	gl_add_op(p);
+}
+
+void glLightModelfv(GLint pname, GLfloat* param) {
+	GLParam p[6];
+	GLint i;
+#include "error_check_no_context.h"
+	p[0].op = OP_LightModel;
+	p[1].i = pname;
+	for (i = 0; i < 4; i++)
+		p[2 + i].f = param[i];
+
+	gl_add_op(p);
+}
+
+/* clear */
+
+void glClear(GLint mask) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_Clear;
+	p[1].i = mask;
+
+	gl_add_op(p);
+}
+
+void glClearColor(GLfloat r, GLfloat g, GLfloat b, GLfloat a) {
+	GLParam p[5];
+#include "error_check_no_context.h"
+	p[0].op = OP_ClearColor;
+	p[1].f = r;
+	p[2].f = g;
+	p[3].f = b;
+	p[4].f = a;
+
+	gl_add_op(p);
+}
+
+void glClearDepth(GLdouble depth) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_ClearDepth;
+	p[1].f = depth;
+
+	gl_add_op(p);
+}
+
+/* textures */
+void glTexImage2D(GLint target, GLint level, GLint components, GLint width, GLint height, GLint border, GLint format, GLint type, void* pixels) {
+	GLParam p[10];
+#include "error_check_no_context.h"
+	p[0].op = OP_TexImage2D;
+	p[1].i = target;
+	p[2].i = level;
+	p[3].i = components;
+	p[4].i = width;
+	p[5].i = height;
+	p[6].i = border;
+	p[7].i = format;
+	p[8].i = type;
+	p[9].p = pixels;
+
+	gl_add_op(p);
+}
+
+void glTexImage1D(GLint target, GLint level, GLint components, GLint width, GLint border, GLint format, GLint type, void* pixels) {
+	GLParam p[10];
+#include "error_check_no_context.h"
+	p[0].op = OP_TexImage1D;
+	p[1].i = target;
+	p[2].i = level;
+	p[3].i = components;
+	p[4].i = width;
+	p[5].i = border;
+	p[6].i = format;
+	p[7].i = type;
+	p[8].p = pixels;
+	gl_add_op(p);
+}
+
+void glBindTexture(GLint target, GLint texture) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_BindTexture;
+	p[1].i = target;
+	p[2].i = texture;
+
+	gl_add_op(p);
+}
+
+void glTexEnvi(GLint target, GLint pname, GLint param) {
+
+#include "error_check_no_context.h"
+
+
+
+
+
+
+
+
+
+}
+
+void glTexParameteri(GLint target, GLint pname, GLint param) {
+
+#include "error_check_no_context.h"
+
+
+
+
+
+
+
+
+
+
+}
+
+/*
+void glPixelStorei(GLint pname, GLint param) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_PixelStore;
+	p[1].i = pname;
+	p[2].i = param;
+
+	gl_add_op(p);
+}
+*/
+/* selection */
+
+void glInitNames(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_InitNames;
+
+	gl_add_op(p);
+}
+
+void glPushName(GLuint name) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_PushName;
+	p[1].i = name;
+
+	gl_add_op(p);
+}
+
+void glPopName(void) {
+	GLParam p[1];
+#include "error_check_no_context.h"
+	p[0].op = OP_PopName;
+
+	gl_add_op(p);
+}
+
+void glLoadName(GLuint name) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_LoadName;
+	p[1].i = name;
+
+	gl_add_op(p);
+}
+
+void glPolygonOffset(GLfloat factor, GLfloat units) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_PolygonOffset;
+	p[1].f = factor;
+	p[2].f = units;
+	gl_add_op(p);
+}
+
+/* Special Functions */
+
+void glCallList(GLuint list) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_CallList;
+	p[1].i = list;
+
+	gl_add_op(p);
+}
+void glFlush(void) { /* nothing to do */
+}
+
+void glHint(GLint target, GLint mode) {
+#include "error_check_no_context.h"
+}
+
+/* Non standard functions */
+
+void glDebug(GLint mode) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	c->print_flag = mode;
+}
diff --git a/src/other/tinygl/src/arrays.c b/src/other/tinygl/src/arrays.c
new file mode 100644
index 0000000000..a815926744
--- /dev/null
+++ b/src/other/tinygl/src/arrays.c
@@ -0,0 +1,513 @@
+#include "zgl.h"
+
+#include "msghandling.h"
+
+
+
+static GLint free_buffer(GLint handle) {
+	GLContext* c = gl_get_context();
+	GLSharedState* s = &(c->shared_state);
+	if (handle == 0 || handle > MAX_BUFFERS)
+		return 1; 
+
+	handle--;
+	if (s->buffers[handle]) { 
+		if (c->boundarraybuffer == (handle + 1))
+			c->boundarraybuffer = 0;
+		if (s->buffers[handle]->data) 
+		{
+			void* d = s->buffers[handle]->data;
+			gl_free(s->buffers[handle]->data); 
+			
+			if (c->vertex_array == d) {
+				c->vertex_array = NULL;
+				c->client_states &= ~VERTEX_ARRAY;
+			}
+			if (c->color_array == d) {
+				c->color_array = NULL;
+				c->client_states &= ~COLOR_ARRAY;
+			}
+			if (c->normal_array == d) {
+				c->normal_array = NULL;
+				c->client_states &= ~NORMAL_ARRAY;
+			}
+			if (c->texcoord_array == d) {
+				c->texcoord_array = NULL;
+				c->client_states &= ~TEXCOORD_ARRAY;
+			}
+		}
+		gl_free(s->buffers[handle]); 
+		s->buffers[handle] = NULL;   
+		return 0;
+	} else {
+		return 0;
+	}
+}
+static GLint check_buffer(GLint handle) { 
+	GLContext* c = gl_get_context();
+	GLSharedState* s = &(c->shared_state);
+	if (handle == 0 || handle > MAX_BUFFERS)
+		return 2;
+	handle--;
+	if (s->buffers[handle])
+		return 1;
+	return 0;
+}
+GLboolean glIsBuffer(GLuint buffer) {
+	if (check_buffer(buffer) == 1)
+		return GL_TRUE;
+	return GL_FALSE;
+}
+
+static GLint create_buffer(GLint handle) {
+	GLContext* c = gl_get_context();
+	GLSharedState* s = &(c->shared_state);
+	if (handle == 0 || handle > MAX_BUFFERS)
+		return 1;
+	handle--;
+	if (s->buffers[handle])
+		free_buffer(handle + 1);
+
+	s->buffers[handle] = gl_zalloc(sizeof(GLBuffer));
+
+	if (!(s->buffers[handle])) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#define RETVAL 1
+#include "error_check.h"
+#else
+		gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+	}
+	s->buffers[handle]->data = NULL;
+	s->buffers[handle]->size = 0;
+	return 0;
+}
+
+void glGenBuffers(GLsizei n, GLuint* buffers) {
+	GLint i;
+#include "error_check.h"
+	if (n > MAX_BUFFERS)
+		goto error;
+
+	{
+		GLint n_left = n;
+		GLuint names[MAX_BUFFERS];
+		for (i = 1; i <= MAX_BUFFERS && n_left > 0; i++)
+			if (!check_buffer(i))
+				names[(n_left--) - 1] = i;
+
+		if (n_left)
+			goto error; 
+		for (i = 0; i < n; i++) {
+			create_buffer(names[i]);
+
+
+#include "error_check.h"
+			buffers[i] = names[i];
+		}
+	}
+	return;
+error:
+	for (i = 0; i < n; i++)
+		buffers[i] = 0;
+	return;
+}
+void glDeleteBuffers(GLsizei n, const GLuint* buffers) {
+	GLint i;
+#include "error_check.h"
+	for (i = 0; i < n; i++)
+		free_buffer(buffers[i]);
+}
+
+
+void glBindBuffer(GLenum target, GLuint buffer) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	if (buffer == 0 || check_buffer(buffer) == 1) {
+		if (target == GL_ARRAY_BUFFER)
+			c->boundarraybuffer = buffer;
+	}
+	return;
+}
+
+void glBindBufferAsArray(GLenum target, GLuint buffer,
+						 GLenum type,	
+						 GLint size,	 
+						 GLint stride) { 
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	if (target != GL_VERTEX_BUFFER && target != GL_NORMAL_BUFFER && target != GL_COLOR_BUFFER && target != GL_TEXTURE_COORD_BUFFER) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	if (buffer == 0)
+		switch (target) {
+		case GL_VERTEX_BUFFER:
+			glDisableClientState(GL_VERTEX_ARRAY);
+			glVertexPointer(size, type, stride, NULL);
+			c->boundvertexbuffer = buffer;
+			return;
+			break;
+		case GL_NORMAL_BUFFER:
+			glDisableClientState(GL_NORMAL_ARRAY);
+			glNormalPointer(type, stride, NULL);
+			c->boundnormalbuffer = buffer;
+			return;
+			break;
+		case GL_COLOR_BUFFER:
+			glDisableClientState(GL_COLOR_ARRAY);
+			glColorPointer(size, type, stride, NULL);
+			c->boundcolorbuffer = buffer;
+			return;
+			break;
+		case GL_TEXTURE_COORD_BUFFER:
+			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+			glTexCoordPointer(size, type, stride, NULL);
+			c->boundtexcoordbuffer = buffer;
+			return;
+			break;
+		default:
+			return;
+		}
+	if (check_buffer(buffer) != 1 || type != GL_FLOAT) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+		tgl_warning("\ncheck_buffer failed on buffer, or incorrect type\n");
+		return;
+#endif
+	}
+	GLBuffer* buf = c->shared_state.buffers[buffer - 1];
+	if (!buf || (buf->data == NULL) || (buf->size == 0)) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+		tgl_warning("\nbuffer was null, buffer data was null, or buffer size was 0\n");
+		return;
+#endif
+	}
+	switch (target) {
+	case GL_VERTEX_BUFFER:
+		glEnableClientState(GL_VERTEX_ARRAY);
+		glVertexPointer(size, type, stride, buf->data);
+		c->boundvertexbuffer = buffer;
+		break;
+	case GL_NORMAL_BUFFER:
+		glEnableClientState(GL_NORMAL_ARRAY);
+		glNormalPointer(type, stride, buf->data);
+		c->boundnormalbuffer = buffer;
+		break;
+	case GL_COLOR_BUFFER:
+		glEnableClientState(GL_COLOR_ARRAY);
+		glColorPointer(size, type, stride, buf->data);
+		c->boundcolorbuffer = buffer;
+		break;
+	case GL_TEXTURE_COORD_BUFFER:
+		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+		glTexCoordPointer(size, type, stride, buf->data);
+		c->boundtexcoordbuffer = buffer;
+		break;
+
+	default:
+		return;
+	}
+	return;
+}
+
+void* glMapBuffer(GLenum target, GLenum access) {
+	GLContext* c = gl_get_context();
+#define RETVAL NULL
+#include "error_check.h"
+	GLint handle = 0;
+	if (target == GL_ARRAY_BUFFER)
+		handle = c->boundarraybuffer;
+	if (target == GL_VERTEX_BUFFER)
+		handle = c->boundvertexbuffer;
+	if (target == GL_TEXTURE_COORD_BUFFER)
+		handle = c->boundtexcoordbuffer;
+	if (target == GL_NORMAL_BUFFER)
+		handle = c->boundnormalbuffer;
+	if (target == GL_COLOR_BUFFER)
+		handle = c->boundcolorbuffer;
+	{
+		if (check_buffer(handle) == 1)
+			return c->shared_state.buffers[handle - 1]->data;
+	}
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define RETVAL NULL
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	return NULL;
+#endif
+}
+void glBufferData(GLenum target, GLsizei size, const void* data,
+				  GLenum usage) 
+{
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	GLint handle = 0;
+	GLBuffer* buf = NULL;
+	if (target == GL_ARRAY_BUFFER)
+		handle = c->boundarraybuffer;
+	if (target == GL_VERTEX_BUFFER)
+		handle = c->boundvertexbuffer;
+	if (target == GL_TEXTURE_COORD_BUFFER)
+		handle = c->boundtexcoordbuffer;
+	if (target == GL_NORMAL_BUFFER)
+		handle = c->boundnormalbuffer;
+	if (target == GL_COLOR_BUFFER)
+		handle = c->boundcolorbuffer;
+	if (check_buffer(handle) == 1)
+		buf = c->shared_state.buffers[handle - 1];
+	else {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	if (buf->data)
+		gl_free(buf->data);
+	buf->data = NULL;
+	buf->size = 0;
+	if (size == 0)
+		return; 
+	buf->data = gl_malloc(size);
+	buf->size = size;
+	if (!(buf->data)) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+		gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+	}
+	if (data != NULL)
+		memcpy(buf->data, data, size);
+}
+
+void glopArrayElement(GLParam* param) {
+	GLint i;
+	GLContext* c = gl_get_context();
+	GLint states = c->client_states;
+	GLint idx = param[1].i;
+
+	if (states & COLOR_ARRAY) {
+		GLParam p[5];
+		GLint size = c->color_array_size;
+		i = idx * (size + c->color_array_stride);
+		p[1].f = c->color_array[i];
+		p[2].f = c->color_array[i + 1];
+		p[3].f = c->color_array[i + 2];
+		p[4].f = (size > 3) ? c->color_array[i + 3] : 1.0f;
+		glopColor(p);
+	}
+	if (states & NORMAL_ARRAY) {
+		i = idx * (3 + c->normal_array_stride);
+		c->current_normal.X = c->normal_array[i];
+		c->current_normal.Y = c->normal_array[i + 1];
+		c->current_normal.Z = c->normal_array[i + 2];
+		
+	}
+	if (states & TEXCOORD_ARRAY) {
+		GLint size = c->texcoord_array_size;
+		i = idx * (size + c->texcoord_array_stride);
+		c->current_tex_coord.X = c->texcoord_array[i];
+		c->current_tex_coord.Y = c->texcoord_array[i + 1];
+		c->current_tex_coord.Z = (size > 2) ? c->texcoord_array[i + 2] : 0.0f;
+		c->current_tex_coord.W = (size > 3) ? c->texcoord_array[i + 3] : 1.0f;
+	}
+	if (states & VERTEX_ARRAY) {
+		GLParam p[5];
+		GLint size = c->vertex_array_size;
+		i = idx * (size + c->vertex_array_stride);
+		p[1].f = c->vertex_array[i];
+		p[2].f = c->vertex_array[i + 1];
+		p[3].f = (size > 2) ? c->vertex_array[i + 2] : 0.0f;
+		p[4].f = (size > 3) ? c->vertex_array[i + 3] : 1.0f;
+		glopVertex(p);
+	}
+}
+
+void glArrayElement(GLint i) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_ArrayElement;
+	p[1].i = i;
+	gl_add_op(p);
+}
+
+void glDrawArrays(GLenum mode, GLint first, GLsizei count) {
+	GLint i;
+	GLint end;
+	
+#include "error_check_no_context.h"
+	end = first + count;
+	glBegin(mode);
+	for (i = first; i < end; i++)
+		glArrayElement(i);
+	glEnd();
+}
+
+void glopEnableClientState(GLParam* p) { gl_get_context()->client_states |= p[1].i; }
+
+void glEnableClientState(GLenum array) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_EnableClientState;
+
+	switch (array) {
+	case GL_VERTEX_ARRAY:
+		p[1].i = VERTEX_ARRAY;
+		break;
+	case GL_NORMAL_ARRAY:
+		p[1].i = NORMAL_ARRAY;
+		break;
+	case GL_COLOR_ARRAY:
+		p[1].i = COLOR_ARRAY;
+		break;
+	case GL_TEXTURE_COORD_ARRAY:
+		p[1].i = TEXCOORD_ARRAY;
+		break;
+	default:
+		break;
+	}
+	gl_add_op(p);
+}
+
+void glopDisableClientState(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->client_states &= p[1].i;
+}
+
+void glDisableClientState(GLenum array) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_DisableClientState;
+
+	switch (array) {
+	case GL_VERTEX_ARRAY:
+		p[1].i = ~VERTEX_ARRAY;
+		break;
+	case GL_NORMAL_ARRAY:
+		p[1].i = ~NORMAL_ARRAY;
+		break;
+	case GL_COLOR_ARRAY:
+		p[1].i = ~COLOR_ARRAY;
+		break;
+	case GL_TEXTURE_COORD_ARRAY:
+		p[1].i = ~TEXCOORD_ARRAY;
+		break;
+	default:
+		break;
+	}
+	gl_add_op(p);
+}
+
+void glopVertexPointer(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->vertex_array_size = p[1].i;
+	c->vertex_array_stride = p[2].i;
+	c->vertex_array = p[3].p;
+}
+
+void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) {
+	GLParam p[4];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (type != GL_FLOAT)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	if (type != GL_FLOAT)
+		return;
+#endif
+		p[0].op = OP_VertexPointer;
+	p[1].i = size;
+	p[2].i = stride;
+	p[3].p = (void*)pointer;
+	gl_add_op(p);
+}
+
+void glopColorPointer(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->color_array_size = p[1].i;
+	c->color_array_stride = p[2].i;
+	c->color_array = p[3].p;
+}
+
+void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) {
+	GLParam p[4];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (type != GL_FLOAT)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	/* assert(type == GL_FLOAT);*/
+#endif
+		p[0].op = OP_ColorPointer;
+	p[1].i = size;
+	p[2].i = stride;
+	p[3].p = (void*)pointer;
+	gl_add_op(p);
+}
+
+void glopNormalPointer(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->normal_array_stride = p[1].i;
+	c->normal_array = p[2].p;
+}
+
+void glNormalPointer(GLenum type, GLsizei stride, const GLvoid* pointer) {
+	GLParam p[3];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (type != GL_FLOAT)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+
+#endif
+		p[0].op = OP_NormalPointer;
+	p[1].i = stride;
+	p[2].p = (void*)pointer;
+	gl_add_op(p);
+}
+
+void glopTexCoordPointer(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->texcoord_array_size = p[1].i;
+	c->texcoord_array_stride = p[2].i;
+	c->texcoord_array = p[3].p;
+}
+
+void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) {
+	GLParam p[4];
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (type != GL_FLOAT)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+
+#endif
+		p[0].op = OP_TexCoordPointer;
+	p[1].i = size;
+	p[2].i = stride;
+	p[3].p = (void*)pointer;
+	gl_add_op(p);
+}
diff --git a/src/other/tinygl/src/clear.c b/src/other/tinygl/src/clear.c
new file mode 100644
index 0000000000..f8e40567d6
--- /dev/null
+++ b/src/other/tinygl/src/clear.c
@@ -0,0 +1,26 @@
+#include "zgl.h"
+
+void glopClearColor(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->clear_color.v[0] = p[1].f;
+	c->clear_color.v[1] = p[2].f;
+	c->clear_color.v[2] = p[3].f;
+	c->clear_color.v[3] = p[4].f;
+}
+void glopClearDepth(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->clear_depth = p[1].f;
+}
+
+void glopClear(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint mask = p[1].i;
+	GLint z = 0;
+	GLint r = (GLint)(c->clear_color.v[0] * COLOR_MULT_MASK);
+	GLint g = (GLint)(c->clear_color.v[1] * COLOR_MULT_MASK);
+	GLint b = (GLint)(c->clear_color.v[2] * COLOR_MULT_MASK);
+
+	/* TODO : correct value of Z */
+
+	ZB_clear(c->zb, mask & GL_DEPTH_BUFFER_BIT, z, mask & GL_COLOR_BUFFER_BIT, r, g, b);
+}
diff --git a/src/other/tinygl/src/clip.c b/src/other/tinygl/src/clip.c
new file mode 100644
index 0000000000..bbc9f7bed9
--- /dev/null
+++ b/src/other/tinygl/src/clip.c
@@ -0,0 +1,474 @@
+#include "msghandling.h"
+#include "zgl.h"
+/* fill triangle profile */
+/* #define PROFILE */
+
+#define CLIP_XMIN (1 << 0)
+#define CLIP_XMAX (1 << 1)
+#define CLIP_YMIN (1 << 2)
+#define CLIP_YMAX (1 << 3)
+#define CLIP_ZMIN (1 << 4)
+#define CLIP_ZMAX (1 << 5)
+
+static void gl_transform_to_viewport_clip_c(GLVertex* v) { /* MARK: NOT_INLINED_IN_OG*/
+	GLContext* c = gl_get_context();
+	/* coordinates */
+	{
+		GLfloat winv = 1.0 / v->pc.W;
+		v->zp.x = (GLint)(v->pc.X * winv * c->viewport.scale.X + c->viewport.trans.X);
+		v->zp.y = (GLint)(v->pc.Y * winv * c->viewport.scale.Y + c->viewport.trans.Y);
+		v->zp.z = (GLint)(v->pc.Z * winv * c->viewport.scale.Z + c->viewport.trans.Z);
+	}
+	/* color */
+	v->zp.r = (GLint)(v->color.v[0] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+	v->zp.g = (GLint)(v->color.v[1] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+	v->zp.b = (GLint)(v->color.v[2] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+
+	/* texture */
+
+	if (c->texture_2d_enabled) {
+		v->zp.s = (GLint)(v->tex_coord.X * (ZB_POINT_S_MAX - ZB_POINT_S_MIN) + ZB_POINT_S_MIN); 
+		v->zp.t = (GLint)(v->tex_coord.Y * (ZB_POINT_T_MAX - ZB_POINT_T_MIN) + ZB_POINT_T_MIN); 
+	}
+}
+
+
+
+#define clip_funcdef(name, sign, dir, dir1, dir2)                                                                                                              \
+	static GLfloat name(V4* c, V4* a, V4* b) {                                                                                                                 \
+		GLfloat t, dX, dY, dZ, dW, den;                                                                                                                        \
+		dX = (b->X - a->X);                                                                                                                                    \
+		dY = (b->Y - a->Y);                                                                                                                                    \
+		dZ = (b->Z - a->Z);                                                                                                                                    \
+		dW = (b->W - a->W);                                                                                                                                    \
+		den = -(sign d##dir) + dW;                                                                                                                             \
+		if (den == 0)                                                                                                                                          \
+			t = 0;                                                                                                                                             \
+		else                                                                                                                                                   \
+			t = (sign a->dir - a->W) / den;                                                                                                                    \
+		c->dir1 = a->dir1 + t * d##dir1;                                                                                                                       \
+		c->dir2 = a->dir2 + t * d##dir2;                                                                                                                       \
+		c->W = a->W + t * dW;                                                                                                                                  \
+		c->dir = sign c->W;                                                                                                                                    \
+		return t;                                                                                                                                              \
+	}
+clip_funcdef(clip_xmin, -, X, Y, Z)
+
+	clip_funcdef(clip_xmax, +, X, Y, Z)
+
+		clip_funcdef(clip_ymin, -, Y, X, Z)
+
+			clip_funcdef(clip_ymax, +, Y, X, Z)
+			
+				clip_funcdef(clip_zmin, -, Z, X, Y)
+
+					clip_funcdef(clip_zmax, +, Z, X, Y)
+
+static GLfloat (*clip_proc[6])(V4*, V4*, V4*) = {clip_xmin, clip_xmax, clip_ymin, clip_ymax, clip_zmin, clip_zmax};
+/* point */
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+static void gl_add_select1(GLint z1, GLint z2, GLint z3) {
+	GLint min, max;
+	min = max = z1;
+	if (z2 < min)
+		min = z2;
+	if (z3 < min)
+		min = z3;
+	if (z2 > max)
+		max = z2;
+	if (z3 > max)
+		max = z3;
+
+	gl_add_select(0xffffffff - min, 0xffffffff - max);
+}
+#else
+#define gl_add_select1(a, b, c) /*a comment*/
+#endif
+void gl_draw_point(GLVertex* p0) {
+	GLContext* c = gl_get_context();
+	if (p0->clip_code == 0) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+		if (c->render_mode == GL_SELECT) {
+			gl_add_select(p0->zp.z, p0->zp.z);
+
+		} else if (c->render_mode == GL_FEEDBACK) {
+			gl_add_feedback(GL_POINT_TOKEN, p0, NULL, NULL, 0);
+		} else
+#endif
+		{
+			ZB_plot(c->zb, &p0->zp);
+		}
+	}
+}
+
+/* line */
+
+/*
+ * Line Clipping
+ */
+
+static void GLinterpolate(GLVertex* q, GLVertex* p0, GLVertex* p1, GLfloat t) { 
+	GLint i;
+	q->pc.X = p0->pc.X + (p1->pc.X - p0->pc.X) * t;
+	q->pc.Y = p0->pc.Y + (p1->pc.Y - p0->pc.Y) * t;
+	q->pc.Z = p0->pc.Z + (p1->pc.Z - p0->pc.Z) * t;
+	q->pc.W = p0->pc.W + (p1->pc.W - p0->pc.W) * t;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+	for (i = 0; i < 3; i++)
+		q->color.v[i] = p0->color.v[i] + (p1->color.v[i] - p0->color.v[i]) * t;
+}
+
+/* Line Clipping algorithm from 'Computer Graphics', Principles and
+   Practice */
+static GLint ClipLine1(GLfloat denom, GLfloat num, GLfloat* tmin, GLfloat* tmax) {
+	GLfloat t;
+
+	if (denom > 0) {
+		t = num / denom;
+		if (t > *tmax)
+			return 0;
+		if (t > *tmin)
+			*tmin = t;
+	} else if (denom < 0) {
+		t = num / denom;
+		if (t < *tmin)
+			return 0;
+		if (t < *tmax)
+			*tmax = t;
+	} else if (num > 0)
+		return 0;
+	return 1;
+}
+void gl_draw_line(GLVertex* p1, GLVertex* p2) {
+	GLContext* c = gl_get_context();
+	GLfloat dx, dy, dz, dw, x1, y1, z1, w1;
+
+	GLVertex q1, q2;
+	GLint cc1, cc2;
+
+	cc1 = p1->clip_code;
+	cc2 = p2->clip_code;
+
+	if ((cc1 | cc2) == 0) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+		if (c->render_mode == GL_SELECT) {
+			gl_add_select1(p1->zp.z, p2->zp.z, p2->zp.z);
+		} else if (c->render_mode == GL_FEEDBACK) {
+			gl_add_feedback(GL_LINE_TOKEN, p1, p2, NULL, 0);
+		} else
+#endif
+		{
+			if (c->zb->depth_test)
+				ZB_line_z(c->zb, &p1->zp, &p2->zp);
+			else
+				ZB_line(c->zb, &p1->zp, &p2->zp);
+		}
+	} else if ((cc1 & cc2) != 0) {
+		return;
+	} else {
+		dx = p2->pc.X - p1->pc.X;
+		dy = p2->pc.Y - p1->pc.Y;
+		dz = p2->pc.Z - p1->pc.Z;
+		dw = p2->pc.W - p1->pc.W;
+		x1 = p1->pc.X;
+		y1 = p1->pc.Y;
+		z1 = p1->pc.Z;
+		w1 = p1->pc.W;
+
+		GLfloat tmin = 0;
+		GLfloat tmax = 1;
+		if (ClipLine1(dx + dw, -x1 - w1, &tmin, &tmax) && ClipLine1(-dx + dw, x1 - w1, &tmin, &tmax) && ClipLine1(dy + dw, -y1 - w1, &tmin, &tmax) &&
+			ClipLine1(-dy + dw, y1 - w1, &tmin, &tmax) && ClipLine1(dz + dw, -z1 - w1, &tmin, &tmax) && ClipLine1(-dz + dw, z1 - w1, &tmin, &tmax)) {
+
+			GLinterpolate(&q1, p1, p2, tmin);
+			GLinterpolate(&q2, p1, p2, tmax);
+			gl_transform_to_viewport_clip_c(&q1);
+			gl_transform_to_viewport_clip_c(&q2);
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+			if (c->render_mode == GL_SELECT) {
+				gl_add_select1(q1.zp.z, q2.zp.z, q2.zp.z);
+			} else if (c->render_mode == GL_FEEDBACK) {
+				gl_add_feedback(GL_LINE_TOKEN, &q1, &q2, NULL, 0);
+			} else
+#endif
+			{
+				if (c->zb->depth_test)
+					ZB_line_z(c->zb, &q1.zp, &q2.zp);
+				else
+					ZB_line(c->zb, &q1.zp, &q2.zp);
+			}
+		}
+	}
+}
+
+
+
+/*Triangles*/
+
+static void updateTmp(GLVertex* q, GLVertex* p0, GLVertex* p1, GLfloat t) { 
+	{
+
+		q->color.v[0] = p0->color.v[0] + (p1->color.v[0] - p0->color.v[0]) * t;
+		q->color.v[1] = p0->color.v[1] + (p1->color.v[1] - p0->color.v[1]) * t;
+		q->color.v[2] = p0->color.v[2] + (p1->color.v[2] - p0->color.v[2]) * t;
+	}
+
+#if TGL_OPTIMIZATION_HINT_BRANCH_COST < 1
+	if (c->texture_2d_enabled)
+#endif
+	{
+		q->tex_coord.X = p0->tex_coord.X + (p1->tex_coord.X - p0->tex_coord.X) * t;
+		q->tex_coord.Y = p0->tex_coord.Y + (p1->tex_coord.Y - p0->tex_coord.Y) * t;
+	}
+
+	q->clip_code = gl_clipcode(q->pc.X, q->pc.Y, q->pc.Z, q->pc.W);
+	if (q->clip_code == 0)
+		gl_transform_to_viewport_clip_c(q);
+}
+
+static void gl_draw_triangle_clip(GLVertex* p0, GLVertex* p1, GLVertex* p2, GLint clip_bit); 
+
+void gl_draw_triangle(GLVertex* p0, GLVertex* p1, GLVertex* p2) {
+	GLContext* c = gl_get_context();
+	GLint co, cc[3], front;
+
+	cc[0] = p0->clip_code;
+	cc[1] = p1->clip_code;
+	cc[2] = p2->clip_code;
+
+	co = cc[0] | cc[1] | cc[2];
+
+	/* we handle the non clipped case here to go faster */
+	if (co == 0) {
+		GLfloat norm;
+		norm = (GLfloat)(p1->zp.x - p0->zp.x) * (GLfloat)(p2->zp.y - p0->zp.y) - (GLfloat)(p2->zp.x - p0->zp.x) * (GLfloat)(p1->zp.y - p0->zp.y);
+
+		if (norm == 0) 
+			return;
+
+		front = norm < 0.0;
+		front = front ^ c->current_front_face; 
+
+		/* back face culling */
+		if (c->cull_face_enabled) {
+			/* most used case first */
+			if (c->current_cull_face == GL_BACK) {
+				if (front == 0)
+					return;
+				c->draw_triangle_front(p0, p1, p2);
+			} else if (c->current_cull_face == GL_FRONT) {
+				if (front != 0)
+					return;
+				c->draw_triangle_back(p0, p1, p2);
+			} else {
+				return;
+			}
+		} else {
+			/* no culling */
+			if (front) {
+				c->draw_triangle_front(p0, p1, p2);
+			} else {
+				c->draw_triangle_back(p0, p1, p2);
+			}
+		}
+	} else {
+		/* GLint c_and = cc[0] & cc[1] & cc[2];*/
+		if ((cc[0] & cc[1] & cc[2]) == 0) { /* Don't draw a triangle with no points*/
+			gl_draw_triangle_clip(p0, p1, p2, 0);
+		}
+	}
+}
+
+static void gl_draw_triangle_clip(GLVertex* p0, GLVertex* p1, GLVertex* p2, GLint clip_bit) {
+	
+	GLint co, c_and, co1, cc[3], edge_flag_tmp, clip_mask;
+	
+	GLVertex* q[3];
+
+	cc[0] = p0->clip_code;
+	cc[1] = p1->clip_code;
+	cc[2] = p2->clip_code;
+
+	co = cc[0] | cc[1] | cc[2];
+	if (co == 0) {
+		gl_draw_triangle(p0, p1, p2);
+	} else {
+
+		c_and = cc[0] & cc[1] & cc[2];
+		/* the triangle is completely outside */
+		if (c_and != 0)
+			return;
+
+		/* find the next direction to clip */
+		while (clip_bit < 6 && (co & (1 << clip_bit)) == 0) {
+			clip_bit++;
+		}
+
+		/* this test can be true only in case of rounding errors */
+		if (clip_bit == 6) { /* The 2 bit and the 4 bit.*/
+#if 0
+      tgl_warning("Error:\n");tgl_warning("%f %f %f %f\n",p0->pc.X,p0->pc.Y,p0->pc.Z,p0->pc.W);tgl_warning("%f %f %f %f\n",p1->pc.X,p1->pc.Y,p1->pc.Z,p1->pc.W);tgl_warning("%f %f %f %f\n",p2->pc.X,p2->pc.Y,p2->pc.Z,p2->pc.W);
+#endif
+			return;
+		}
+
+		clip_mask = 1 << clip_bit;
+		co1 = (cc[0] ^ cc[1] ^ cc[2]) & clip_mask;
+
+		if (co1) {
+			/* one point outside */
+
+			if (cc[0] & clip_mask) {
+				q[0] = p0;
+				q[1] = p1;
+				q[2] = p2;
+			} else if (cc[1] & clip_mask) {
+				q[0] = p1;
+				q[1] = p2;
+				q[2] = p0;
+			} else {
+				q[0] = p2;
+				q[1] = p0;
+				q[2] = p1;
+			}
+			{
+				GLVertex tmp1, tmp2;
+				GLfloat tt;
+				tt = clip_proc[clip_bit](&tmp1.pc, &q[0]->pc, &q[1]->pc);
+				updateTmp(&tmp1, q[0], q[1], tt);
+
+				tt = clip_proc[clip_bit](&tmp2.pc, &q[0]->pc, &q[2]->pc);
+				updateTmp(&tmp2, q[0], q[2], tt);
+
+				tmp1.edge_flag = q[0]->edge_flag;
+				edge_flag_tmp = q[2]->edge_flag;
+				q[2]->edge_flag = 0;
+				gl_draw_triangle_clip(&tmp1, q[1], q[2], clip_bit + 1);
+
+				tmp2.edge_flag = 1;
+				tmp1.edge_flag = 0;
+				q[2]->edge_flag = edge_flag_tmp;
+				gl_draw_triangle_clip(&tmp2, &tmp1, q[2], clip_bit + 1);
+			}
+		} else {
+			/* two points outside */
+
+			if ((cc[0] & clip_mask) == 0) {
+				q[0] = p0;
+				q[1] = p1;
+				q[2] = p2;
+			} else if ((cc[1] & clip_mask) == 0) {
+				q[0] = p1;
+				q[1] = p2;
+				q[2] = p0;
+			} else {
+				q[0] = p2;
+				q[1] = p0;
+				q[2] = p1;
+			}
+			{
+				GLVertex tmp1, tmp2;
+				GLfloat tt;
+				tt = clip_proc[clip_bit](&tmp1.pc, &q[0]->pc, &q[1]->pc);
+				updateTmp(&tmp1, q[0], q[1], tt);
+
+				tt = clip_proc[clip_bit](&tmp2.pc, &q[0]->pc, &q[2]->pc);
+				updateTmp(&tmp2, q[0], q[2], tt);
+
+				tmp1.edge_flag = 1;
+				tmp2.edge_flag = q[2]->edge_flag;
+				gl_draw_triangle_clip(q[0], &tmp1, &tmp2, clip_bit + 1);
+			}
+		}
+	}
+}
+
+/* see vertex.c to see how the draw functions are assigned.*/
+void gl_draw_triangle_select(GLVertex* p0, GLVertex* p1, GLVertex* p2) { gl_add_select1(p0->zp.z, p1->zp.z, p2->zp.z); }
+void gl_draw_triangle_feedback(GLVertex* p0, GLVertex* p1, GLVertex* p2) { gl_add_feedback(GL_POLYGON_TOKEN, p0, p1, p2, 0); }
+
+#ifdef PROFILE
+int count_triangles, count_triangles_textured, count_pixels;
+#warning "Compile with PROFILE slows down everything"
+#endif
+
+/* see vertex.c to see how the draw functions are assigned.*/
+void gl_draw_triangle_fill(GLVertex* p0, GLVertex* p1, GLVertex* p2) { 
+	GLContext* c = gl_get_context();
+	if (c->texture_2d_enabled) {
+		/* if(c->current_texture)*/
+#if TGL_FEATURE_LIT_TEXTURES == 1
+		if (c->current_shade_model != GL_SMOOTH) {
+			p1->zp.r = p2->zp.r;
+			p1->zp.g = p2->zp.g;
+			p1->zp.b = p2->zp.b;
+
+			p0->zp.r = p2->zp.r;
+			p0->zp.g = p2->zp.g;
+			p0->zp.b = p2->zp.b;
+		}
+#endif
+
+		ZB_setTexture(c->zb, c->current_texture->images[0].pixmap);
+#if TGL_FEATURE_BLEND == 1
+		if (c->zb->enable_blend)
+			ZB_fillTriangleMappingPerspective(c->zb, &p0->zp, &p1->zp, &p2->zp);
+		else
+			ZB_fillTriangleMappingPerspectiveNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#else
+		ZB_fillTriangleMappingPerspectiveNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#endif
+	} else if (c->current_shade_model == GL_SMOOTH) {
+#if TGL_FEATURE_BLEND == 1
+		if (c->zb->enable_blend)
+			ZB_fillTriangleSmooth(c->zb, &p0->zp, &p1->zp, &p2->zp);
+		else
+			ZB_fillTriangleSmoothNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#else
+		ZB_fillTriangleSmoothNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#endif
+	} else {
+#if TGL_FEATURE_BLEND == 1
+		if (c->zb->enable_blend)
+			ZB_fillTriangleFlat(c->zb, &p0->zp, &p1->zp, &p2->zp);
+		else
+			ZB_fillTriangleFlatNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#else
+		ZB_fillTriangleFlatNOBLEND(c->zb, &p0->zp, &p1->zp, &p2->zp);
+#endif
+	}
+}
+
+/* Render a clipped triangle in line mode */
+
+void gl_draw_triangle_line(GLVertex* p0, GLVertex* p1, GLVertex* p2) {
+	GLContext* c = gl_get_context();
+	if (c->zb->depth_test) {
+		if (p0->edge_flag)
+			ZB_line_z(c->zb, &p0->zp, &p1->zp);
+		if (p1->edge_flag)
+			ZB_line_z(c->zb, &p1->zp, &p2->zp);
+		if (p2->edge_flag)
+			ZB_line_z(c->zb, &p2->zp, &p0->zp);
+	} else {
+		if (p0->edge_flag)
+			ZB_line(c->zb, &p0->zp, &p1->zp);
+		if (p1->edge_flag)
+			ZB_line(c->zb, &p1->zp, &p2->zp);
+		if (p2->edge_flag)
+			ZB_line(c->zb, &p2->zp, &p0->zp);
+	}
+}
+
+/* Render a clipped triangle in point mode */
+void gl_draw_triangle_point(GLVertex* p0, GLVertex* p1, GLVertex* p2) {
+	GLContext* c = gl_get_context();
+	if (p0->edge_flag)
+		ZB_plot(c->zb, &p0->zp);
+	if (p1->edge_flag)
+		ZB_plot(c->zb, &p1->zp);
+	if (p2->edge_flag)
+		ZB_plot(c->zb, &p2->zp);
+}
diff --git a/src/other/tinygl/src/error_check.h b/src/other/tinygl/src/error_check.h
new file mode 100644
index 0000000000..7517f4313c
--- /dev/null
+++ b/src/other/tinygl/src/error_check.h
@@ -0,0 +1,40 @@
+
+#ifndef RETVAL
+#define RETVAL /* a comment*/
+#endif
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+
+
+
+#ifndef ERROR_FLAG
+
+
+
+#if TGL_FEATURE_STRICT_OOM_CHECKS == 1
+if (c->error_flag == GL_OUT_OF_MEMORY)
+	return RETVAL;
+#endif
+
+
+#elif ERROR_FLAG != GL_OUT_OF_MEMORY
+{
+	c->error_flag = ERROR_FLAG;
+	return RETVAL;
+}
+
+#else
+{
+	c->error_flag = GL_OUT_OF_MEMORY;
+	return RETVAL;
+}
+#endif
+
+
+
+#endif
+
+
+
+#undef RETVAL
+#undef ERROR_FLAG
diff --git a/src/other/tinygl/src/error_check_no_context.h b/src/other/tinygl/src/error_check_no_context.h
new file mode 100644
index 0000000000..2d6e4d36e1
--- /dev/null
+++ b/src/other/tinygl/src/error_check_no_context.h
@@ -0,0 +1,19 @@
+#ifndef RETVAL
+#define RETVAL /* a comment*/
+#endif
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+
+
+#if TGL_FEATURE_STRICT_OOM_CHECKS == 1
+GLContext* c = gl_get_context();
+if (c->error_flag == GL_OUT_OF_MEMORY)
+	return RETVAL;
+#elif defined(NEED_CONTEXT)
+GLContext* c = gl_get_context();
+#endif
+
+#endif
+
+#undef RETVAL
+#undef NEED_CONTEXT
diff --git a/src/other/tinygl/src/font8x8_basic.h b/src/other/tinygl/src/font8x8_basic.h
new file mode 100644
index 0000000000..75e4540578
--- /dev/null
+++ b/src/other/tinygl/src/font8x8_basic.h
@@ -0,0 +1,154 @@
+/**
+ * 8x8 monochrome bitmap fonts for rendering
+ * Author: Daniel Hepper <daniel@hepper.net>
+ *
+ * License: Public Domain
+ *
+ * Based on:
+ * // Summary: font8x8.h
+ * // 8x8 monochrome bitmap fonts for rendering
+ * //
+ * // Author:
+ * //     Marcel Sondaar
+ * //     International Business Machines (public domain VGA fonts)
+ * //
+ * // License:
+ * //     Public Domain
+ *
+ * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
+ *
+ * This copy from:  https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h
+ **/
+
+// Constant: font8x8_basic
+// Contains an 8x8 font map for unicode points U+0000 - U+007F (basic latin)
+static GLbyte font8x8_basic[128][8] = {
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
+    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
+    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
+    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
+    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
+    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
+    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
+    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
+    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
+    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
+    { 0x00, 0x66, 0x3C, -0x01, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
+    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
+    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
+    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
+    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
+    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
+    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
+    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
+    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
+    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
+    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
+    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
+    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
+    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
+    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
+    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
+    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
+    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
+    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
+    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
+    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
+    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
+    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
+    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
+    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
+    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
+    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
+    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
+    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
+    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
+    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
+    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
+    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
+    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
+    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
+    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
+    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
+    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
+    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
+    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
+    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
+    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
+    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
+    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
+    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
+    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
+    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
+    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
+    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
+    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
+    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, -0x01},   // U+005F (_)
+    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
+    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
+    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
+    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
+    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
+    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
+    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
+    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
+    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
+    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
+    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
+    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
+    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
+    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
+    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
+    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
+    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
+    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
+    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
+    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
+    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
+    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
+    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
+    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
+    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
+    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
+    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
+    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
+    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
+    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
+    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
+};
diff --git a/src/other/tinygl/src/get.c b/src/other/tinygl/src/get.c
new file mode 100644
index 0000000000..620d3ebc85
--- /dev/null
+++ b/src/other/tinygl/src/get.c
@@ -0,0 +1,687 @@
+#include "msghandling.h"
+#include "zgl.h"
+
+#define xstr(s) str(s)
+#define str(s) #s
+
+
+const GLubyte* license_string = (const GLubyte*)""
+												"Copyright notice:\n"
+												"\n"
+												" (C) 1997-2021 Fabrice Bellard, Gek (DMHSW), C-Chads\n"
+												"\n"
+												" This software is provided 'as-is', without any express or implied\n"
+												"  warranty.  In no event will the authors be held liable for any damages\n"
+												"   arising from the use of this software.\n"
+												"\n"
+												" Permission is granted to anyone to use this software for any purpose,\n"
+												" including commercial applications, and to alter it and redistribute it\n"
+												" freely, subject to the following restrictions:\n"
+												"\n"
+												" 1. The origin of this software must not be misrepresented; you must not\n"
+												"    claim that you wrote the original software. If you use this software\n"
+												"    in a product, an acknowledgment in the product and its documentation \n"
+												"    *is* required.\n"
+												" 2. Altered source versions must be plainly marked as such, and must not be\n"
+												"    misrepresented as being the original software.\n"
+												" 3. This notice may not be removed or altered from any source distribution.\n"
+												"\n"
+												"If you redistribute modified sources, I would appreciate that you\n"
+												"include in the files history information documenting your changes.";
+
+const GLubyte* vendor_string = (const GLubyte*)"Fabrice Bellard, Gek, and the C-Chads";
+const GLubyte* renderer_string = (const GLubyte*)"TinyGL";
+const GLubyte* version_string = (const GLubyte*)"" xstr(TINYGL_VERSION) " TinyGLv" xstr(TINYGL_VERSION) " "
+#ifdef __GNUC__
+																										"Compiled using GCC " __VERSION__
+#endif
+#ifdef __TINYC__
+																										"Compiled using Tiny C Compiler " xstr(__TINYC__)
+#endif
+#ifdef _MSVC_VER
+																											"Compiled using the worst compiler on earth, M$VC. "
+#endif
+#ifdef __clang__
+																											"Compiled Using Clang " __clang_version__
+#endif
+	;
+const GLubyte* extensions_string =
+	(const GLubyte*)"TGL_TEXTURE "
+					"TGL_SMOOTHSHADING "
+					"TGL_LIGHTING "
+					"TGL_OPTIMIZATION_HINT_BRANCH_COST=" xstr(
+						TGL_OPTIMIZATION_HINT_BRANCH_COST) " "
+#if TGL_FEATURE_ERROR_CHECK == 1
+														   "TGL_FEATURE_ERROR_CHECK "
+#endif
+#if TGL_FEATURE_STRICT_OOM_CHECKS == 1
+														   "TGL_FEATURE_STRICT_OOM_CHECKS "
+#endif
+#if TGL_FEATURE_CUSTOM_MALLOC == 1
+														   "TGL_FEATURE_CUSTOM_MALLOC "
+#endif
+#if TGL_FEATURE_FISR == 1
+														   "TGL_FEATURE_FISR "
+#endif
+#if TGL_FEATURE_ARRAYS == 1
+														   "TGL_FEATURE_ARRAYS "
+#endif
+#if TGL_FEATURE_DISPLAYLISTS == 1
+														   "TGL_FEATURE_DISPLAYLISTS "
+#endif
+#if ZB_POINT_T_FRAC_BITS == (ZB_POINT_S_FRAC_BITS + TGL_FEATURE_TEXTURE_POW2)
+														   "TGL_FEATURE_OPTIMIZED_TEXTURE_ACCESS "
+#endif
+														   "TGL_FEATURE_TEXTURE_POW2=" xstr(
+															   TGL_FEATURE_TEXTURE_POW2) " "
+#if TGL_FEATURE_LIT_TEXTURES == 1
+																						 "TGL_FEATURE_LIT_TEXTURES "
+#endif
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+																						 "TGL_FEATURE_SPECULAR_BUFFERS "
+#endif
+
+#if TGL_FEATURE_POLYGON_OFFSET == 1
+																						 "TGL_FEATURE_POLYGON_OFFSET "
+#endif
+
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+																						 "TGL_FEATURE_POLYGON_STIPPLE "
+#endif
+#if TGL_FEATURE_GL_POLYGON == 1
+																						 "TGL_FEATURE_GL_POLYGON "
+#endif
+
+#if TGL_FEATURE_BLEND == 1
+																						 "TGL_FEATURE_BLEND "
+#endif
+#if TGL_FEATURE_BLEND_DRAW_PIXELS == 1
+																						 "TGL_FEATURE_BLEND_DRAW_PIXELS "
+#endif
+#if TGL_FEATURE_NO_DRAW_COLOR == 1
+																						 "TGL_FEATURE_NO_DRAW_COLOR "
+#endif
+
+#if TGL_FEATURE_NO_COPY_COLOR == 1
+																						 "TGL_FEATURE_NO_COPY_COLOR "
+#endif
+
+#if TGL_FEATURE_FORCE_CLEAR_NO_COPY_COLOR == 1
+																						 "TGL_FEATURE_FORCE_CLEAR_NO_COPY_COLOR "
+#endif
+
+#if TGL_FEATURE_16_BITS == 1
+																						 "TGL_FEATURE_16_BITS "
+#endif
+
+#if TGL_FEATURE_32_BITS == 1
+																						 "TGL_FEATURE_32_BITS "
+#endif
+#if COMPILETIME_TINYGL_COMPAT_TEST == 1
+																						 "TGL_COMPILETIME_TINYGL_COMPAT_TEST "
+#endif
+#if TGL_FEATURE_TINYGL_RUNTIME_COMPAT_TEST == 1
+																						 "TGL_FEATURE_TINYGL_RUNTIME_COMPAT_TEST "
+#endif
+#if defined(_OPENMP)
+																						 "TGL_FEATURE_MULTI_THREADED "
+																						 "TGL_FEATURE_MULTI_THREADED_POST_PROCESS "
+
+#if TGL_FEATURE_MULTITHREADED_DRAWPIXELS == 1
+																						 "TGL_FEATURE_MULTITHREADED_DRAWPIXELS "
+#endif
+
+#if TGL_FEATURE_MULTITHREADED_COPY_TEXIMAGE_2D == 1
+																						 "TGL_FEATURE_MULTITHREADED_COPY_TEXIMAGE_2D "
+#endif
+
+#if TGL_FEATURE_MULTITHREADED_ZB_COPYBUFFER == 1
+																						 "TGL_FEATURE_MULTITHREADED_ZB_COPYBUFFER "
+#endif
+
+#else
+																						 "TGL_FEATURE_SINGLE_THREADED "
+#endif
+
+#if TGL_FEATURE_ALIGNAS
+																						 "TGL_FEATURE_ALIGNAS "
+#endif
+																						 "TGL_BUFFER_EXT "
+#if TGL_FEATURE_ALT_RENDERMODES
+																						 "TGL_FEEDBACK "
+																						 "TGL_SELECT "
+#endif
+																						 "TGL_SOFTWARE_ACCELERATED";
+const GLubyte* glGetString(GLenum name) {
+	switch (name) {
+	case GL_VENDOR:
+		return vendor_string;
+	case GL_RENDERER:
+		return renderer_string;
+	case GL_VERSION:
+		return version_string;
+	case GL_EXTENSIONS:
+		return extensions_string;
+	case GL_LICENSE:
+		return license_string;
+	}
+	return NULL;
+}
+
+
+
+void glGetIntegerv(GLint pname, GLint* params) {
+	GLint i;
+	GLContext* c = gl_get_context();
+	i = 0;
+	switch (pname) {
+	case GL_MAX_BUFFERS:
+		*params = MAX_BUFFERS;
+		break;
+	case GL_TEXTURE_HASH_TABLE_SIZE:
+		*params = TEXTURE_HASH_TABLE_SIZE;
+		break;
+
+	case GL_LIGHT15:
+		i++;
+	case GL_LIGHT14:
+		i++;
+	case GL_LIGHT13:
+		i++;
+	case GL_LIGHT12:
+		i++;
+	case GL_LIGHT11:
+		i++;
+	case GL_LIGHT10:
+		i++;
+	case GL_LIGHT9:
+		i++;
+	case GL_LIGHT8:
+		i++;
+	case GL_LIGHT7:
+		i++;
+	case GL_LIGHT6:
+		i++;
+	case GL_LIGHT5:
+		i++;
+	case GL_LIGHT4:
+		i++;
+	case GL_LIGHT3:
+		i++;
+	case GL_LIGHT2:
+		i++;
+	case GL_LIGHT1:
+		i++;
+	case GL_LIGHT0:
+		*params = c->lights[i].enabled;
+		break;
+	case GL_COLOR_ARRAY:
+		*params = ((c->client_states & COLOR_ARRAY) != 0);
+		break;
+	case GL_COLOR_ARRAY_SIZE:
+		*params = (c->color_array_size);
+		break;
+	case GL_COLOR_ARRAY_STRIDE:
+		*params = c->color_array_stride;
+		break;
+	case GL_VERTEX_ARRAY:
+		*params = ((c->client_states & VERTEX_ARRAY) != 0);
+		break;
+	case GL_VERTEX_ARRAY_SIZE:
+		*params = c->vertex_array_size;
+		break;
+	case GL_VERTEX_ARRAY_STRIDE:
+		*params = c->vertex_array_stride;
+		break;
+	case GL_TEXTURE_COORD_ARRAY:
+		*params = ((c->client_states & TEXCOORD_ARRAY) != 0);
+		break;
+	case GL_TEXTURE_COORD_ARRAY_SIZE:
+		*params = c->texcoord_array_size;
+		break;
+	case GL_TEXTURE_COORD_ARRAY_STRIDE:
+		*params = c->texcoord_array_stride;
+		break;
+	case GL_NORMAL_ARRAY:
+		*params = ((c->client_states & NORMAL_ARRAY) != 0);
+		break;
+	case GL_NORMAL_ARRAY_STRIDE:
+		*params = c->normal_array_stride;
+		break;
+	case GL_BLEND:
+		*params = c->zb->enable_blend;
+		break;
+	case GL_SHADE_MODEL:
+		*params = c->current_shade_model;
+		break;
+	case GL_BLEND_DST:
+		*params = c->zb->dfactor;
+		break;
+	case GL_BLEND_SRC:
+		*params = c->zb->sfactor;
+		break;
+	case GL_POLYGON_MODE:
+		params[0] = c->polygon_mode_front;
+		params[1] = c->polygon_mode_back;
+		break;
+	case GL_LIST_MODE:
+		if (c->compile_flag && !c->exec_flag)
+			params[0] = GL_COMPILE;
+		else if (c->exec_flag && c->compile_flag)
+			params[0] = GL_COMPILE_AND_EXECUTE;
+		else
+			params[0] = 0;
+		break;
+	case GL_LIST_BASE:
+		*params = c->listbase;
+		break;
+	case GL_LIST_INDEX: /* TODO*/
+		params[0] = 0;
+		break;
+	case GL_TEXTURE_2D:
+	case GL_TEXTURE_1D:
+		params[0] = c->texture_2d_enabled;
+		break;
+	case GL_POLYGON_STIPPLE:
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+		params[0] = c->zb->dostipple;
+#else
+		params[0] = GL_FALSE;
+#endif
+		break;
+	case GL_LIGHT_MODEL_LOCAL_VIEWER:
+		*params = c->local_light_model;
+		break;
+	case GL_FOG_INDEX:
+		*params = 0;
+		break;
+	case GL_FOG_COLOR:
+		params[0] = 0;
+		params[1] = 0;
+		params[2] = 0;
+		params[3] = 0;
+		break;
+	case GL_FOG_MODE:
+		*params = GL_EXP;
+		break;
+	case GL_LIGHTING:
+		*params = (c->lighting_enabled != 0);
+		break;
+	case GL_LIGHT_MODEL_TWO_SIDE:
+		*params = (c->light_model_two_side != 0);
+		break;
+	case GL_LINE_STIPPLE_REPEAT:
+		*params = 1;
+		break;
+	case GL_LINE_STIPPLE:
+		*params = 0;
+		break;
+	case GL_LINE_STIPPLE_PATTERN:
+		*params = (GLushort)(~0);
+		break;
+	case GL_NORMALIZE:
+		params[0] = c->normalize_enabled;
+		break;
+	case GL_POINT_SMOOTH_HINT:
+	case GL_FOG_HINT:
+	case GL_LINE_SMOOTH_HINT:
+	case GL_PERSPECTIVE_CORRECTION_HINT:
+	case GL_POLYGON_SMOOTH_HINT:
+		*params = GL_FASTEST;
+		break;
+	case GL_BLUE_SCALE:
+	case GL_RED_SCALE:
+	case GL_GREEN_SCALE:
+	case GL_ALPHA_SCALE:
+		*params = 1;
+		break;
+	case GL_SUBPIXEL_BITS:
+		*params = 6;
+		break;
+	case GL_MATRIX_MODE:
+		if (c->matrix_mode == 0)
+			*params = GL_MODELVIEW;
+		else if (c->matrix_mode == 1)
+			*params = GL_PROJECTION;
+		else if (c->matrix_mode == 2)
+			*params = GL_TEXTURE;
+		break;
+	case GL_BLUE_BIAS:
+	case GL_RED_BIAS:
+	case GL_GREEN_BIAS:
+	case GL_ALPHA_BIAS:
+	case GL_CLIP_PLANE0:
+	case GL_CLIP_PLANE1:
+	case GL_CLIP_PLANE2:
+	case GL_CLIP_PLANE3:
+	case GL_CLIP_PLANE4:
+	case GL_CLIP_PLANE5:
+	case GL_SCISSOR_TEST:
+	case GL_UNPACK_SWAP_BYTES:
+	case GL_UNPACK_SKIP_ROWS:
+	case GL_UNPACK_SKIP_PIXELS:
+	case GL_UNPACK_ROW_LENGTH:
+	case GL_UNPACK_LSB_FIRST:
+	case GL_TEXTURE_GEN_T:
+	case GL_TEXTURE_GEN_S:
+	case GL_TEXTURE_GEN_R:
+	case GL_TEXTURE_GEN_Q:
+
+	case GL_STEREO:
+	case GL_PACK_SWAP_BYTES:
+	case GL_PACK_SKIP_ROWS:
+	case GL_PACK_SKIP_PIXELS:
+	case GL_PACK_ROW_LENGTH:
+	case GL_PACK_LSB_FIRST:
+	case GL_STENCIL_TEST:
+	case GL_MAX_PIXEL_MAP_TABLE:
+	case GL_MAX_EVAL_ORDER:
+	case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
+		params[0] = 0;
+		break;
+	case GL_POLYGON_MAX_VERTEX:
+		params[0] = POLYGON_MAX_VERTEX;
+		break;
+	case GL_MAX_VIEWPORT_DIMS:
+		params[0] = 4096;
+		params[1] = 4096;
+		break;
+	case GL_MAX_LIST_NESTING:
+		*params = ~(GLuint)0; /* No checking is done, indicate it to the user!*/
+		break;
+	case GL_STENCIL_FUNC:
+		*params = GL_ALWAYS;
+		break;
+	case GL_STENCIL_CLEAR_VALUE:
+		*params = 0;
+		break;
+	case GL_STENCIL_BITS:
+	case GL_MAP_STENCIL:
+	case GL_MAP_COLOR:
+	case GL_INDEX_SHIFT:
+	case GL_INDEX_OFFSET:
+	case GL_INDEX_MODE:
+	case GL_INDEX_CLEAR_VALUE:
+	case GL_INDEX_BITS:
+	case GL_INDEX_ARRAY:
+		*params = 0;
+		break;
+	case GL_FRONT_FACE:
+		*params = c->current_front_face;
+		break;
+	case GL_STENCIL_PASS_DEPTH_PASS:
+	case GL_STENCIL_PASS_DEPTH_FAIL:
+		*params = GL_KEEP;
+		break;
+	case GL_STENCIL_VALUE_MASK:
+	case GL_INDEX_WRITEMASK:
+		*params = ~0;
+		break;
+	case GL_UNPACK_ALIGNMENT:
+	case GL_PACK_ALIGNMENT:
+		*params = 4;
+		break;
+	case GL_COLOR_ARRAY_TYPE:
+	case GL_NORMAL_ARRAY_TYPE:
+	case GL_TEXTURE_COORD_ARRAY_TYPE:
+	case GL_VERTEX_ARRAY_TYPE:
+		*params = GL_FLOAT;
+		break;
+	case GL_RENDER_MODE:
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+		*params = c->render_mode;
+#else
+		*params = GL_RENDER;
+#endif
+		break;
+	case GL_BLEND_EQUATION:
+		*params = c->zb->blendeq;
+		break;
+	case GL_DRAW_BUFFER:
+		*params = c->drawbuffer;
+		break;
+	case GL_READ_BUFFER:
+		*params = c->readbuffer;
+		break;
+	case GL_AUX_BUFFERS:
+		*params = 0;
+		break;
+	case GL_PIXEL_MAP_S_TO_S_SIZE:
+	case GL_PIXEL_MAP_I_TO_I_SIZE:
+	case GL_PIXEL_MAP_I_TO_R_SIZE:
+	case GL_PIXEL_MAP_I_TO_G_SIZE:
+	case GL_PIXEL_MAP_I_TO_B_SIZE:
+	case GL_PIXEL_MAP_I_TO_A_SIZE:
+	case GL_PIXEL_MAP_R_TO_R_SIZE:
+	case GL_PIXEL_MAP_G_TO_G_SIZE:
+	case GL_PIXEL_MAP_B_TO_B_SIZE:
+	case GL_PIXEL_MAP_A_TO_A_SIZE:
+		*params = 0;
+		break;
+	case GL_RGBA_MODE:
+		*params = 1; /* yes, even in 565 (it's what the spec says)*/
+		break;
+	case GL_VIEWPORT:
+		params[0] = c->viewport.xmin;
+		params[1] = c->viewport.ymin;
+		params[2] = c->viewport.xsize;
+		params[3] = c->viewport.ysize;
+		break;
+	case GL_MAX_SPECULAR_BUFFERS:
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+		*params = MAX_SPECULAR_BUFFERS;
+#else
+		*params = 0;
+#endif
+		break;
+	case GL_MAX_DISPLAY_LISTS:
+		*params = MAX_DISPLAY_LISTS;
+		break;
+	case GL_ERROR_CHECK_LEVEL:
+#if TGL_FEATURE_STRICT_OOM_CHECKS == 1
+		*params = 2;
+#elif TGL_FEATURE_ERROR_CHECK == 1
+		*params = 1;
+#else
+		*params = 0;
+#endif
+		break;
+	
+	case GL_IS_SPECULAR_ENABLED:
+		*params = c->zEnableSpecular;
+		break;
+	case GL_MAX_MODELVIEW_STACK_DEPTH:
+		*params = MAX_MODELVIEW_STACK_DEPTH;
+		break;
+	case GL_MAX_NAME_STACK_DEPTH:
+		*params = MAX_NAME_STACK_DEPTH;
+		break;
+	case GL_MAX_PROJECTION_STACK_DEPTH:
+		*params = MAX_PROJECTION_STACK_DEPTH;
+		break;
+	case GL_MAX_TEXTURE_STACK_DEPTH:
+		*params = MAX_TEXTURE_STACK_DEPTH;
+		break;
+	case GL_MAX_TEXTURE_LEVELS:
+		*params = MAX_TEXTURE_LEVELS;
+		break;
+	case GL_GREEN_BITS:
+#if TGL_FEATURE_RENDER_BITS == 16
+		*params = 6;
+#elif TGL_FEATURE_RENDER_BITS == 32
+		*params = 8;
+#endif
+		break;
+	case GL_BLUE_BITS:
+	case GL_RED_BITS:
+#if TGL_FEATURE_RENDER_BITS == 16
+		*params = 5;
+#elif TGL_FEATURE_RENDER_BITS == 32
+		*params = 8;
+#endif
+		break;
+	case GL_POLYGON_OFFSET_FILL:
+		*params = ((c->offset_states & TGL_OFFSET_FILL) != 0);
+		break;
+	case GL_POLYGON_OFFSET_LINE:
+		*params = ((c->offset_states & TGL_OFFSET_LINE) != 0);
+		break;
+	case GL_DEPTH_BITS:
+		*params = 16;
+		break;
+	case GL_POLYGON_OFFSET_POINT:
+		*params = ((c->offset_states & TGL_OFFSET_POINT) != 0);
+		break;
+	case GL_POLYGON_SMOOTH:
+		*params = GL_FALSE;
+		break;
+	case GL_CULL_FACE_MODE:
+		*params = c->current_cull_face;
+		break;
+	case GL_MAX_LIGHTS:
+		*params = MAX_LIGHTS;
+		break;
+	case GL_MAX_TEXTURE_SIZE:
+		*params = TGL_FEATURE_TEXTURE_DIM; /* not completely true, but... */
+		break;
+	case GL_CULL_FACE:
+		*params = c->cull_face_enabled;
+		break;
+	case GL_CURRENT_RASTER_POSITION_VALID:
+		*params = c->rasterposvalid;
+		break;
+	case GL_FOG:
+		*params = GL_FALSE;
+		break;
+	case GL_EDGE_FLAG:
+		*params = c->current_edge_flag;
+		break;
+	case GL_DOUBLEBUFFER:
+	case GL_DITHER:
+		*params = GL_FALSE;
+		break;
+	case GL_DEPTH_TEST:
+		*params = (c->zb->depth_test == 1);
+		break;
+	case GL_DEPTH_FUNC:
+		*params = GL_LESS;
+		break;
+
+	default:
+		tgl_warning("glGet: option not implemented");
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+		break;
+	}
+}
+
+void glGetFloatv(GLint pname, GLfloat* v) {
+	GLint i, mnr;
+	GLContext* c;
+	mnr = 0; /* just a trick to return the correct matrix */
+	c = gl_get_context();
+	switch (pname) {
+	case GL_BLUE_SCALE:
+	case GL_RED_SCALE:
+	case GL_GREEN_SCALE:
+	case GL_ALPHA_SCALE:
+	case GL_FOG_END:
+	case GL_FOG_DENSITY:
+		*v = 1;
+		break;
+	case GL_BLUE_BIAS:
+	case GL_RED_BIAS:
+	case GL_GREEN_BIAS:
+	case GL_ALPHA_BIAS:
+	case GL_FOG_START:
+		*v = 0;
+		break;
+	case GL_DEPTH_SCALE:
+		*v = 1;
+		break;
+	case GL_TEXTURE_MATRIX:
+		mnr++;
+	case GL_PROJECTION_MATRIX:
+		mnr++;
+	case GL_MODELVIEW_MATRIX: {
+		GLfloat* p = &c->matrix_stack_ptr[mnr]->m[0][0];
+		for (i = 0; i < 4; i++) {
+			*v++ = p[0];
+			*v++ = p[4];
+			*v++ = p[8];
+			*v++ = p[12];
+			p++;
+		}
+	} break;
+	case GL_LINE_WIDTH:
+		*v = 1.0f;
+		break;
+	case GL_DEPTH_CLEAR_VALUE:
+		*v = 1; /* This is not entirely true, but... good enough?*/
+		break;
+	case GL_DEPTH_RANGE:
+		v[0] = 0;
+		v[1] = 1;
+		break;
+	case GL_DEPTH_BIAS:
+		*v = 0;
+		break;
+	case GL_CURRENT_TEXTURE_COORDS:
+		v[0] = c->current_tex_coord.X;
+		v[1] = c->current_tex_coord.Y;
+		v[2] = c->current_tex_coord.Z;
+		v[3] = c->current_tex_coord.W;
+		break;
+	case GL_CURRENT_RASTER_POSITION:
+		v[0] = c->rastervertex.pc.X;
+		v[1] = c->rastervertex.pc.Y;
+		v[2] = c->rastervertex.pc.Z;
+		v[3] = c->rastervertex.pc.W;
+		break;
+	case GL_CURRENT_RASTER_DISTANCE:
+		*v = c->rastervertex.ec.Z;
+		break;
+	case GL_LINE_WIDTH_RANGE:
+		v[0] = v[1] = 1.0f;
+		break;
+	case GL_POINT_SIZE:
+		/* case GL_POINT_SIZE_MIN:*/
+		/* case GL_POINT_SIZE_MAX:*/
+		*v = c->zb->pointsize;
+		break;
+	case GL_FOG_COLOR:
+		v[0] = 0;
+		v[1] = 0;
+		v[2] = 0;
+		v[3] = 0;
+		break;
+	case GL_POINT_SIZE_GRANULARITY:
+		*v = 1.0f; /* if we ever implement AA'd points...*/
+		break;
+	case GL_POLYGON_OFFSET_FACTOR:
+		*v = 0;
+		break;
+	case GL_POLYGON_OFFSET_UNITS:
+		*v = 0;
+		break;
+	case GL_LIGHT_MODEL_AMBIENT:
+		for (i = 0; i < 4; i++)
+			v[i] = c->ambient_light_model.v[i];
+		break;
+	case GL_ZOOM_X:
+		*v = c->pzoomx;
+		break;
+	case GL_ZOOM_Y:
+		*v = c->pzoomy;
+		break;
+	case GL_POINT_SIZE_RANGE:
+		v[0] = c->zb->pointsize;
+		v[1] = c->zb->pointsize;
+		break;
+	default:
+		tgl_warning("warning: unknown pname in glGetFloatv()\n");
+		break;
+	}
+}
diff --git a/src/other/tinygl/src/image_util.c b/src/other/tinygl/src/image_util.c
new file mode 100644
index 0000000000..53d9d54a50
--- /dev/null
+++ b/src/other/tinygl/src/image_util.c
@@ -0,0 +1,124 @@
+#include "zgl.h"
+
+/*
+ * image conversion
+ */
+
+void gl_convertRGB_to_5R6G5B(GLushort* pixmap, GLubyte* rgb, GLint xsize, GLint ysize) {
+	GLint i, n;
+	GLubyte* p;
+
+	p = rgb;
+	n = xsize * ysize;
+	for (i = 0; i < n; i++) {
+		pixmap[i] = ((p[0] & 0xF8) << 8) | ((p[1] & 0xFC) << 3) | ((p[2] & 0xF8) >> 3);
+		p += 3;
+	}
+}
+
+/*
+ This actually converts to ARGB!!!
+ This is the format of the entire engine!!!
+*/
+void gl_convertRGB_to_8A8R8G8B(GLuint* pixmap, GLubyte* rgb, GLint xsize, GLint ysize) {
+	GLint i, n;
+	GLubyte* p;
+
+	p = rgb;
+	n = xsize * ysize;
+	for (i = 0; i < n; i++) {
+		pixmap[i] = (((GLuint)p[0]) << 16) | (((GLuint)p[1]) << 8) | (((GLuint)p[2]));
+		p += 3;
+	}
+}
+
+/*
+ * linear GLinterpolation with xf,yf normalized to 2^16
+ */
+
+#define INTERP_NORM_BITS 16
+#define INTERP_NORM (1 << INTERP_NORM_BITS)
+
+static GLint GLinterpolate_imutil(GLint v00, GLint v01, GLint v10, GLint xf, GLint yf) {
+	return v00 + (((v01 - v00) * xf + (v10 - v00) * yf) >> INTERP_NORM_BITS);
+}
+
+/*
+ * TODO: more accurate resampling
+ */
+
+void gl_resizeImage(GLubyte* dest, GLint xsize_dest, GLint ysize_dest, GLubyte* src, GLint xsize_src, GLint ysize_src) {
+	GLubyte *pix, *pix_src;
+	GLfloat x1, y1, x1inc, y1inc;
+	GLint xi, yi, j, xf, yf, x, y;
+
+	pix = dest;
+	pix_src = src;
+	
+	x1inc = (GLfloat)(xsize_src - 1) / (GLfloat)(xsize_dest - 1);
+	y1inc = (GLfloat)(ysize_src - 1) / (GLfloat)(ysize_dest - 1);
+
+	y1 = 0;
+	for (y = 0; y < ysize_dest; y++) {
+		x1 = 0;
+		for (x = 0; x < xsize_dest; x++) {
+			xi = (GLint)x1;
+			yi = (GLint)y1;
+			xf = (GLint)((x1 - floor(x1)) * INTERP_NORM);
+			yf = (GLint)((y1 - floor(y1)) * INTERP_NORM);
+
+			if ((xf + yf) <= INTERP_NORM) {
+				for (j = 0; j < 3; j++) {
+					pix[j] = GLinterpolate_imutil(pix_src[(yi * xsize_src + xi) * 3 + j], pix_src[(yi * xsize_src + xi + 1) * 3 + j],
+												  pix_src[((yi + 1) * xsize_src + xi) * 3 + j], xf, yf);
+				}
+			} else {
+				xf = INTERP_NORM - xf;
+				yf = INTERP_NORM - yf;
+				for (j = 0; j < 3; j++) {
+					pix[j] = GLinterpolate_imutil(pix_src[((yi + 1) * xsize_src + xi + 1) * 3 + j], pix_src[((yi + 1) * xsize_src + xi) * 3 + j],
+												  pix_src[(yi * xsize_src + xi + 1) * 3 + j], xf, yf);
+				}
+			}
+
+			pix += 3;
+			x1 += x1inc;
+		}
+		y1 += y1inc;
+	}
+	
+}
+
+#define FRAC_BITS 16
+
+/* resizing with no GLinterlating nor nearest pixel */
+
+void gl_resizeImageNoInterpolate(GLubyte* dest, GLint xsize_dest, GLint ysize_dest, GLubyte* src, GLint xsize_src, GLint ysize_src) {
+	GLubyte *pix, *pix_src, *pix1;
+	GLint x1, y1, x1inc, y1inc;
+	GLint xi, yi, x, y;
+
+	pix = dest;
+	pix_src = src;
+
+	x1inc = (GLint)((GLfloat)((xsize_src) << FRAC_BITS) / (GLfloat)(xsize_dest));
+	y1inc = (GLint)((GLfloat)((ysize_src) << FRAC_BITS) / (GLfloat)(ysize_dest));
+
+	y1 = 0;
+	for (y = 0; y < ysize_dest; y++) {
+		x1 = 0;
+		for (x = 0; x < xsize_dest; x++) {
+			xi = x1 >> FRAC_BITS;
+			yi = y1 >> FRAC_BITS;
+			pix1 = pix_src + (yi * xsize_src + xi) * 3;
+
+			pix[0] = pix1[0];
+			pix[1] = pix1[1];
+			pix[2] = pix1[2];
+
+			pix += 3;
+			x1 += x1inc;
+		}
+		y1 += y1inc;
+	}
+}
diff --git a/src/other/tinygl/src/init.c b/src/other/tinygl/src/init.c
new file mode 100644
index 0000000000..cf2121a48a
--- /dev/null
+++ b/src/other/tinygl/src/init.c
@@ -0,0 +1,379 @@
+#include "msghandling.h"
+#include "zgl.h"
+GLContext gl_ctx;
+static const GLContext empty_gl_ctx = {0};
+
+static void initSharedState(GLContext* c) {
+	GLSharedState* s = &c->shared_state;
+	s->lists = gl_zalloc(sizeof(GLList*) * MAX_DISPLAY_LISTS);
+	if (!s->lists)
+		gl_fatal_error("TINYGL_CANNOT_INIT_OOM");
+	s->texture_hash_table = gl_zalloc(sizeof(GLTexture*) * TEXTURE_HASH_TABLE_SIZE);
+	if (!s->texture_hash_table)
+		gl_fatal_error("TINYGL_CANNOT_INIT_OOM");
+	s->buffers = gl_zalloc(sizeof(GLBuffer*) * MAX_BUFFERS);
+	if (!s->buffers)
+		gl_fatal_error("TINYGL_CANNOT_INIT_OOM");
+	alloc_texture(0);
+#include "error_check.h"
+}
+
+static void endSharedState(GLContext* c) {
+	GLSharedState* s = &c->shared_state;
+	GLint i;
+	GLList* l;
+	GLParamBuffer *pb, *pb1;
+	GLTexture *t, *n;
+	for (i = 0; i < MAX_DISPLAY_LISTS; i++)
+		if (s->lists[i]) {
+			l = s->lists[i];
+			pb = l->first_op_buffer;
+			while (pb != NULL) {
+				pb1 = pb->next;
+				gl_free(pb);
+				pb = pb1;
+			}
+			gl_free(l);
+			s->lists[i] = NULL;
+		}
+	gl_free(s->lists);
+	for (i = 0; i < TEXTURE_HASH_TABLE_SIZE; i++) {
+		t = s->texture_hash_table[i];
+		while (t) {
+			GLTexture** ht;
+			if (t->prev == NULL) {
+				ht = &c->shared_state.texture_hash_table[t->handle & TEXTURE_HASH_TABLE_MASK];
+				*ht = t->next;
+			} else {
+				t->prev->next = t->next;
+			}
+			n = t->next;
+			if (t->next != NULL)
+				t->next->prev = t->prev;
+			gl_free(t);
+			t = n;
+		}
+	}
+	gl_free(s->texture_hash_table);
+	for (i = 0; i < MAX_BUFFERS; i++) {
+		if (s->buffers[i]) {
+			if (s->buffers[i]->data) {
+				gl_free(s->buffers[i]->data);
+			}
+			gl_free(s->buffers[i]);
+		}
+	}
+	gl_free(s->buffers);
+}
+
+#if TGL_FEATURE_TINYGL_RUNTIME_COMPAT_TEST == 1
+
+#define TGL_FLOAT_ERR(a, b) ((a - b) / b)
+static int TinyGLRuntimeCompatibilityTest() {
+	GLfloat t = -0, tf2;
+	GLint t2 = 1 << 31;
+	memcpy(&tf2, &t2, 4);
+	if (tf2 != t) return 1;
+#if 0
+	/* TODO - what are we testing for here? This triggers
+	 * a compiler warning about an overflow */
+	t2 = 3212836864;
+	t = -1;
+	memcpy(&tf2, &t2, 4);
+	if (tf2 != t)return 1;
+#endif
+	if (((GLint)255 << 8) != 65280)
+		return 1;
+	if ((GLint)65280 >> 8 != 255)
+		return 1;
+	if (((GLint)-1) >> 14 != -1)
+		return 1;
+	if (((GLuint)255 << 8) != 65280)
+		return 1;
+	if ((GLuint)65280 >> 8 != 255)
+		return 1;
+	if (((GLushort)255 << 8) != 65280)
+		return 1;
+	if ((GLushort)65280 >> 8 != 255)
+		return 1;
+	if (((GLshort)255 << 8) != 65280)
+		return 1;
+	if ((GLshort)65280 >> 8 != -1)
+		return 1;
+#if TGL_FEATURE_FISR == 1
+	t = fastInvSqrt(37);
+	tf2 = 1.0 / sqrt(37);
+	if (TGL_FLOAT_ERR(t, tf2) > 0.05)
+		return 1;
+	t = fastInvSqrt(59);
+	tf2 = 1.0 / sqrt(59);
+	if (TGL_FLOAT_ERR(t, tf2) > 0.05)
+		return 1;
+	t = fastInvSqrt(1023);
+	tf2 = 1.0 / sqrt(1023);
+	if (TGL_FLOAT_ERR(t, tf2) > 0.05)
+		return 1;
+
+	t = fastInvSqrt(10000);
+	tf2 = 1.0 / sqrt(10000);
+	if (TGL_FLOAT_ERR(t, tf2) > 0.05)
+		return 1;
+#endif
+	{
+		GLint i;
+		GLuint buf1[10];
+		GLuint buf2[10];
+		for (i = 0; i < 10; i++)
+			buf1[i] = (1023 << i) + i + i % -1;
+		for (i = 0; i < 10; i++)
+			buf2[i] = (14 << i) + i + i % -4;
+		memcpy(buf1, buf2, 10 * 4);
+		for (i = 0; i < 10; i++)
+			if (buf2[i] != buf1[i])
+				return 1;
+	}
+	if (sizeof(void*) < 4)
+		return 1;
+	/* ZALLOC TEST*/
+	{
+		GLint i, j;
+		for (i = 0; i < 10; i++) {
+			GLubyte* data = gl_zalloc(1024); 
+			if (!data)
+				return 1;
+			for (j = 0; j < 1024; j++)
+				if (data[j] != 0)
+					return 1;
+			gl_free(data);
+		}
+	}
+	return 0;
+}
+#endif
+
+void glInit(void* zbuffer1) {
+	GLContext* c;
+	GLViewport* v;
+	GLint i;
+	ZBuffer* zbuffer = (ZBuffer*)zbuffer1;
+#if TGL_FEATURE_TINYGL_RUNTIME_COMPAT_TEST == 1
+	if (TinyGLRuntimeCompatibilityTest())
+		gl_fatal_error("TINYGL_FAILED_RUNTIME_COMPAT_TEST");
+#endif
+	gl_ctx = empty_gl_ctx;
+	c = &gl_ctx;
+	if (!c)
+		gl_fatal_error("TINYGL_CANNOT_INIT_OOM");
+
+	c->zb = zbuffer;
+#if TGL_FEATURE_ERROR_CHECK == 1
+	c->error_flag = GL_NO_ERROR;
+#endif
+	/* allocate GLVertex array */
+	/*c->vertex_max = POLYGON_MAX_VERTEX;*/
+	/*c->vertex = gl_malloc(POLYGON_MAX_VERTEX * sizeof(GLVertex));*/
+	/*if(!c->vertex) gl_fatal_error("TINYGL_CANNOT_INIT_OOM");*/
+	/* viewport */
+	v = &c->viewport;
+	v->xmin = 0;
+	v->ymin = 0;
+	v->xsize = zbuffer->xsize;
+	v->ysize = zbuffer->ysize;
+	gl_eval_viewport();
+	/* buffer stuff GL 1.1 */
+	c->drawbuffer = GL_FRONT;
+	c->readbuffer = GL_FRONT;
+	/* shared state */
+	initSharedState(c);
+	/* ztext */
+	c->textsize = 1;
+	/* buffer */
+	c->boundarraybuffer = 0;
+	c->boundvertexbuffer = 0;
+	c->boundcolorbuffer = 0;
+	c->boundnormalbuffer = 0;
+	c->boundtexcoordbuffer = 0;
+	/* lists */
+
+	c->exec_flag = 1;
+	c->compile_flag = 0;
+	c->print_flag = 0;
+	c->listbase = 0;
+	c->in_begin = 0;
+
+	/* lights */
+	for (i = 0; i < MAX_LIGHTS; i++) {
+		GLLight* l = &c->lights[i];
+		l->ambient = gl_V4_New(0, 0, 0, 1);
+		l->diffuse = gl_V4_New(1, 1, 1, 1);
+		l->specular = gl_V4_New(1, 1, 1, 1);
+		l->position = gl_V4_New(0, 0, 1, 0);
+		l->norm_position = gl_V3_New(0, 0, 1);
+		l->spot_direction = gl_V3_New(0, 0, -1);
+		l->norm_spot_direction = gl_V3_New(0, 0, -1);
+		l->spot_exponent = 0;
+		l->spot_cutoff = 180;
+		l->attenuation[0] = 1;
+		l->attenuation[1] = 0;
+		l->attenuation[2] = 0;
+		l->enabled = 0;
+	}
+	c->first_light = NULL;
+	c->ambient_light_model = gl_V4_New(0.2, 0.2, 0.2, 1);
+	c->local_light_model = 0;
+	c->lighting_enabled = 0;
+	c->light_model_two_side = 0;
+
+	/* default materials */
+	for (i = 0; i < 2; i++) {
+		GLMaterial* m = &c->materials[i];
+		m->emission = gl_V4_New(0, 0, 0, 1);
+		m->ambient = gl_V4_New(0.2, 0.2, 0.2, 1);
+		m->diffuse = gl_V4_New(0.8, 0.8, 0.8, 1);
+		m->specular = gl_V4_New(0, 0, 0, 1);
+		m->shininess = 0;
+	}
+	c->current_color_material_mode = GL_FRONT_AND_BACK;
+	c->current_color_material_type = GL_AMBIENT_AND_DIFFUSE;
+	c->color_material_enabled = 0;
+
+	/* textures */
+	glInitTextures(c);
+
+	/* blending */
+	c->zb->enable_blend = 0;
+	c->zb->sfactor = GL_ONE;
+	c->zb->dfactor = GL_ZERO;
+	c->zb->blendeq = GL_FUNC_ADD;
+
+	/* default state */
+	c->current_color.X = 1.0;
+	c->current_color.Y = 1.0;
+	c->current_color.Z = 1.0;
+	c->current_color.W = 0.0;
+
+	c->current_normal.X = 1.0;
+	c->current_normal.Y = 0.0;
+	c->current_normal.Z = 0.0;
+	c->current_normal.W = 0.0;
+
+	c->current_edge_flag = 1;
+
+	c->current_tex_coord.X = 0;
+	c->current_tex_coord.Y = 0;
+	c->current_tex_coord.Z = 0;
+	c->current_tex_coord.W = 1;
+
+	c->polygon_mode_front = GL_FILL;
+	c->polygon_mode_back = GL_FILL;
+
+	c->current_front_face = 0; /* 0 = GL_CCW  1 = GL_CW */
+	c->current_cull_face = GL_BACK;
+	c->current_shade_model = GL_SMOOTH;
+	c->cull_face_enabled = 0;
+
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+	c->zb->dostipple = 0;
+	for (GLint i = 0; i < 128; i++)
+		c->zb->stipplepattern[i] = 0xFF;
+#endif
+	/* clear */
+	c->clear_color.v[0] = 0;
+	c->clear_color.v[1] = 0;
+	c->clear_color.v[2] = 0;
+	c->clear_color.v[3] = 0;
+	c->clear_depth = 0;
+
+	/* selection */
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	c->render_mode = GL_RENDER;
+	c->select_buffer = NULL;
+	c->name_stack_size = 0;
+
+	/* feedback */
+	c->feedback_buffer = NULL;
+	c->feedback_ptr = NULL;
+	c->feedback_size = 0;
+	c->feedback_hits = 0;
+	c->feedback_overflow = 0;
+#endif
+	/* matrix */
+	c->matrix_mode = 0;
+
+	c->matrix_stack_depth_max[0] = MAX_MODELVIEW_STACK_DEPTH;
+	c->matrix_stack_depth_max[1] = MAX_PROJECTION_STACK_DEPTH;
+	c->matrix_stack_depth_max[2] = MAX_TEXTURE_STACK_DEPTH;
+
+	for (i = 0; i < 3; i++) {
+		c->matrix_stack[i] = gl_zalloc(c->matrix_stack_depth_max[i] * sizeof(M4));
+		if (!(c->matrix_stack[i]))
+			gl_fatal_error("TINYGL_CANNOT_INIT_OOM");
+		c->matrix_stack_ptr[i] = c->matrix_stack[i];
+	}
+
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	glMatrixMode(GL_TEXTURE);
+	glLoadIdentity();
+	glMatrixMode(GL_MODELVIEW);
+	glLoadIdentity();
+
+	c->matrix_model_projection_updated = 1;
+
+	/* opengl 1.1 arrays */
+	c->client_states = 0;
+
+	/* opengl 1.1 polygon offset */
+	c->offset_states = 0;
+
+	/* clear the resize callback function pointer */
+	c->gl_resize_viewport = NULL;
+
+	/* specular buffer */
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+	c->specbuf_first = NULL;
+	c->specbuf_used_counter = 0;
+	c->specbuf_num_buffers = 0;
+#endif
+	c->zEnableSpecular = 0;
+	/* depth test */
+	c->zb->depth_test = 0;
+	c->zb->depth_write = 1;
+	c->zb->pointsize = 1;
+
+	/* raster position */
+	c->rasterpos.X = 0;
+	c->rasterpos.Y = 0;
+	c->rasterpos.Z = 0;
+	c->rasterpos.W = 1;
+
+	c->rastervertex.pc.X = 0;
+	c->rastervertex.pc.Y = 0;
+	c->rastervertex.pc.Z = 0;
+	c->rastervertex.pc.W = 1;
+	c->rasterposvalid = 0;
+	c->pzoomx = 1;
+	c->pzoomy = 1;
+}
+
+void glClose(void) {
+
+	GLuint i;
+	GLContext* c = gl_get_context();
+	for (i = 0; i < 3; i++) {
+		gl_free(c->matrix_stack[i]);
+	}
+	i = 0;
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+	{
+		GLSpecBuf *b, *n = NULL;
+		for (b = c->specbuf_first; b != NULL; b = n) {
+			n = b->next;
+			gl_free(b);
+			i++;
+		}
+	}
+#endif
+	endSharedState(c);
+	gl_ctx = empty_gl_ctx;
+}
diff --git a/src/other/tinygl/src/light.c b/src/other/tinygl/src/light.c
new file mode 100644
index 0000000000..b1524e16ca
--- /dev/null
+++ b/src/other/tinygl/src/light.c
@@ -0,0 +1,394 @@
+#include "msghandling.h"
+#include "zgl.h"
+
+void glopMaterial(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint mode = p[1].i;
+	GLint type = p[2].i;
+	GLfloat v[4];
+	v[0] = p[3].f;
+	v[1] = p[4].f;
+	v[2] = p[5].f;
+	v[3] = p[6].f;
+	GLint i;
+	GLMaterial* m;
+
+	if (mode == GL_FRONT_AND_BACK) {
+		p[1].i = GL_FRONT;
+		glopMaterial(p);
+		mode = GL_BACK;
+	}
+	if (mode == GL_FRONT)
+		m = &c->materials[0];
+	else
+		m = &c->materials[1];
+
+	switch (type) {
+	case GL_EMISSION:
+		for (i = 0; i < 4; i++)
+			m->emission.v[i] = clampf(v[i], 0, 1);
+		break;
+	case GL_AMBIENT:
+		for (i = 0; i < 4; i++)
+			m->ambient.v[i] = clampf(v[i], 0, 1);
+		break;
+	case GL_DIFFUSE:
+		for (i = 0; i < 4; i++)
+			m->diffuse.v[i] = clampf(v[i], 0, 1);
+		break;
+	case GL_SPECULAR:
+		for (i = 0; i < 4; i++)
+			m->specular.v[i] = clampf(v[i], 0, 1);
+		break;
+	case GL_SHININESS:
+		m->shininess = v[0];
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+		m->shininess_i = (v[0] / 128.0f) * SPECULAR_BUFFER_SIZE;
+#endif
+		break;
+	case GL_AMBIENT_AND_DIFFUSE:
+		for (i = 0; i < 4; i++)
+			m->diffuse.v[i] = clampf(v[i], 0, 1);
+
+		for (i = 0; i < 4; i++)
+			m->ambient.v[i] = clampf(v[i], 0, 1);
+		break;
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	default:
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+		/* default: return;*/
+#endif
+	}
+}
+
+void glopColorMaterial(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint mode = p[1].i;
+	GLint type = p[2].i;
+
+	c->current_color_material_mode = mode;
+	c->current_color_material_type = type;
+}
+
+void glopLight(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint light = p[1].i;
+	GLint type = p[2].i;
+	V4 v;
+	GLLight* l;
+	GLint i;
+
+	/* assert(light >= GL_LIGHT0 && light < GL_LIGHT0 + MAX_LIGHTS);*/
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(light >= GL_LIGHT0 && light < GL_LIGHT0 + MAX_LIGHTS))
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+
+#else
+/*	if(!(light >= GL_LIGHT0 && light < GL_LIGHT0 + MAX_LIGHTS)) return;*/
+#endif
+
+		l = &c->lights[light - GL_LIGHT0];
+
+	for (i = 0; i < 4; i++)
+		if (type != GL_POSITION && type != GL_SPOT_DIRECTION && type != GL_SPOT_EXPONENT && type != GL_SPOT_CUTOFF && type != GL_LINEAR_ATTENUATION &&
+			type != GL_CONSTANT_ATTENUATION && type != GL_QUADRATIC_ATTENUATION)
+			v.v[i] = clampf(p[3 + i].f, 0, 1);
+		else
+			v.v[i] = p[3 + i].f;
+
+	switch (type) {
+	case GL_AMBIENT:
+		l->ambient = v;
+		break;
+	case GL_DIFFUSE:
+		l->diffuse = v;
+		break;
+	case GL_SPECULAR:
+		l->specular = v;
+		break;
+	case GL_POSITION: {
+		V4 pos;
+		gl_M4_MulV4(&pos, c->matrix_stack_ptr[0], &v);
+
+		l->position = pos;
+
+		if (l->position.v[3] == 0) {
+			l->norm_position.X = pos.X;
+			l->norm_position.Y = pos.Y;
+			l->norm_position.Z = pos.Z;
+			/* gl_V3_Norm(&l->norm_position);*/
+			gl_V3_Norm_Fast(&l->norm_position);
+		}
+	} break;
+	case GL_SPOT_DIRECTION:
+		for (i = 0; i < 3; i++) {
+			l->spot_direction.v[i] = v.v[i];
+			l->norm_spot_direction.v[i] = v.v[i];
+		}
+		gl_V3_Norm_Fast(&l->norm_spot_direction);
+		break;
+	case GL_SPOT_EXPONENT:
+		l->spot_exponent = v.v[0];
+		break;
+	case GL_SPOT_CUTOFF: {
+		GLfloat a = v.v[0];
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_VALUE
+#include "error_check.h"
+#else
+		/* assert(a == 180 || (a >= 0 && a <= 90));*/
+#endif
+
+		l->spot_cutoff = a;
+		if (a != 180)
+			l->cos_spot_cutoff = cos(a * M_PI / 180.0);
+	} break;
+	case GL_CONSTANT_ATTENUATION:
+		l->attenuation[0] = v.v[0];
+		break;
+	case GL_LINEAR_ATTENUATION:
+		l->attenuation[1] = v.v[0];
+		break;
+	case GL_QUADRATIC_ATTENUATION:
+		l->attenuation[2] = v.v[0];
+		break;
+	default:
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+		return;
+	}
+}
+
+void glopLightModel(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint pname = p[1].i;
+	GLint* v = &p[2].i;
+	GLint i;
+
+	switch (pname) {
+	case GL_LIGHT_MODEL_AMBIENT:
+		for (i = 0; i < 4; i++)
+			c->ambient_light_model.v[i] = p[2 + i].f;
+		break;
+	case GL_LIGHT_MODEL_LOCAL_VIEWER:
+		c->local_light_model = (GLint)v[0];
+		break;
+	case GL_LIGHT_MODEL_TWO_SIDE:
+		c->light_model_two_side = (GLint)v[0];
+		break;
+	default:
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+	/*
+				tgl_warning("glopLightModel: illegal pname: 0x%x\n", pname);
+		 assert(0);
+	*/
+		break;
+	}
+}
+
+void gl_enable_disable_light(GLint light, GLint v) {
+	GLContext* c = gl_get_context();
+	GLLight* l = &c->lights[light];
+	if (v && !l->enabled) {
+		l->enabled = 1;
+		l->next = c->first_light;
+		c->first_light = l;
+		l->prev = NULL;
+	} else if (!v && l->enabled) {
+		l->enabled = 0;
+		if (l->prev == NULL)
+			c->first_light = l->next;
+		else
+			l->prev->next = l->next;
+		if (l->next != NULL)
+			l->next->prev = l->prev;
+	}
+}
+
+
+void glSetEnableSpecular(GLint s) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[1].i = s;
+	p[0].op = OP_SetEnableSpecular;
+	gl_add_op(p);
+}
+void glopSetEnableSpecular(GLParam* p) {
+	
+	gl_get_context()->zEnableSpecular = p[1].i;
+}
+/* non optimized lightening model */
+void gl_shade_vertex(GLVertex* v) {
+	GLContext* c = gl_get_context();
+	GLfloat R, G, B, A;
+	GLMaterial* m;
+	GLLight* l;
+	V3 n, s, d;
+	GLfloat dist=0, tmp, att, dot, dot_spot, dot_spec;
+	GLint twoside = c->light_model_two_side;
+
+	m = &c->materials[0];
+
+	n.X = v->normal.X;
+	n.Y = v->normal.Y;
+	n.Z = v->normal.Z;
+
+	R = m->emission.v[0] + m->ambient.v[0] * c->ambient_light_model.v[0];
+	G = m->emission.v[1] + m->ambient.v[1] * c->ambient_light_model.v[1];
+	B = m->emission.v[2] + m->ambient.v[2] * c->ambient_light_model.v[2];
+	A = m->diffuse.v[3];
+	
+	for (l = c->first_light; l != NULL; l = l->next) {
+	
+	
+	
+		GLfloat lR, lB, lG;
+
+		/* ambient */
+		lR = l->ambient.v[0] * m->ambient.v[0];
+		lG = l->ambient.v[1] * m->ambient.v[1];
+		lB = l->ambient.v[2] * m->ambient.v[2];
+
+		if (l->position.v[3] == 0) {
+			/* light at infinity */
+			/* Fixed by Gek, it used to use the unnormalized position?*/
+			d.X = l->norm_position.v[0];
+			d.Y = l->norm_position.v[1];
+			d.Z = l->norm_position.v[2];
+			att = 1;
+		} else {
+			/* distance attenuation */
+			d.X = l->position.v[0] - v->ec.v[0];
+			d.Y = l->position.v[1] - v->ec.v[1];
+			d.Z = l->position.v[2] - v->ec.v[2];
+#if TGL_FEATURE_FISR == 1
+			tmp = fastInvSqrt(d.X * d.X + d.Y * d.Y + d.Z * d.Z); /* FISR IMPL, MATCHED!*/
+			{
+				d.X *= tmp;
+				d.Y *= tmp;
+				d.Z *= tmp;
+			}
+#else
+			dist = sqrt(d.X * d.X + d.Y * d.Y + d.Z * d.Z);
+			if (dist > 1E-3) {
+				tmp = 1 / dist;
+				d.X *= tmp;
+				d.Y *= tmp;
+				d.Z *= tmp;
+			}
+#endif
+			att = 1.0f / (l->attenuation[0] + dist * (l->attenuation[1] + dist * l->attenuation[2]));
+		}
+		dot = d.X * n.X + d.Y * n.Y + d.Z * n.Z;
+		if (twoside && dot < 0)
+			dot = -dot;
+		if (dot > 0) {
+			/* diffuse light */
+			lR += dot * l->diffuse.v[0] * m->diffuse.v[0];
+			lG += dot * l->diffuse.v[1] * m->diffuse.v[1];
+			lB += dot * l->diffuse.v[2] * m->diffuse.v[2];
+
+			/* spot light */
+			if (l->spot_cutoff != 180) {
+				dot_spot = -(d.X * l->norm_spot_direction.v[0] + d.Y * l->norm_spot_direction.v[1] + d.Z * l->norm_spot_direction.v[2]);
+				if (twoside && dot_spot < 0)
+					dot_spot = -dot_spot;
+				if (dot_spot < l->cos_spot_cutoff) {
+					/* no contribution */
+					continue;
+				} else {
+					/* TODO: pow table for spot_exponent?*/
+					if (l->spot_exponent > 0) {
+						att = att * pow(dot_spot, l->spot_exponent);
+					}
+				}
+				
+				
+			}
+
+			/* specular light */
+			if (c->zEnableSpecular) {
+				if (c->local_light_model) {
+					V3 vcoord;
+					vcoord.X = v->ec.X;
+					vcoord.Y = v->ec.Y;
+					vcoord.Z = v->ec.Z;
+					
+					gl_V3_Norm_Fast(&vcoord);
+					s.X = d.X - vcoord.X;
+					s.Y = d.Y - vcoord.X;
+					s.Z = d.Z - vcoord.X;
+				} else {
+					
+					s.X = d.X; 
+					s.Y = d.Y; 
+					s.Z = d.Z - 1.0;
+				}
+				
+				dot_spec = n.X * s.X + n.Y * s.Y + n.Z * s.Z;
+				if (twoside && dot_spec < 0)
+					dot_spec = -dot_spec;
+				if (dot_spec > 0) {
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+					GLSpecBuf* specbuf;
+					GLint idx;
+#endif
+					dot_spec = clampf(dot_spec, 0, 1);
+#if TGL_FEATURE_FISR == 1
+					tmp = fastInvSqrt(s.X * s.X + s.Y * s.Y + s.Z * s.Z); 
+					
+					{ dot_spec = dot_spec * tmp; }
+					
+#else
+					
+					tmp = sqrt(s.X * s.X + s.Y * s.Y + s.Z * s.Z);
+					if (tmp > 1E-3) {
+						dot_spec = dot_spec / tmp;
+					} else
+						dot_spec = 0;
+#endif
+					/* dot_spec= pow(dot_spec,m->shininess);*/
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+					specbuf = specbuf_get_buffer(c, m->shininess_i, m->shininess);
+/* Check for GL_OUT_OF_MEMORY*/
+#if TGL_FEATURE_ERROR_CHECK == 1
+#include "error_check.h"
+#endif
+#else
+					dot_spec = pow(dot_spec, m->shininess);
+#endif
+
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+					idx = (GLint)(dot_spec * SPECULAR_BUFFER_SIZE);
+					if (idx > SPECULAR_BUFFER_SIZE)
+						idx = SPECULAR_BUFFER_SIZE; /* NOTE by GEK: this is poorly written, it's actually 1 larger.*/
+					dot_spec = specbuf->buf[idx];
+#endif
+					lR += dot_spec * l->specular.v[0] * m->specular.v[0];
+					lG += dot_spec * l->specular.v[1] * m->specular.v[1];
+					lB += dot_spec * l->specular.v[2] * m->specular.v[2];
+				} 
+			}	 
+		}		  
+
+		R += att * lR;
+		G += att * lG;
+		B += att * lB;
+	} /* End of light loop.*/
+
+	v->color.v[0] = clampf(R, 0, 1);
+	v->color.v[1] = clampf(G, 0, 1);
+	v->color.v[2] = clampf(B, 0, 1);
+	v->color.v[3] = A;
+}
diff --git a/src/other/tinygl/src/list.c b/src/other/tinygl/src/list.c
new file mode 100644
index 0000000000..2470667477
--- /dev/null
+++ b/src/other/tinygl/src/list.c
@@ -0,0 +1,303 @@
+#include "msghandling.h"
+#include "zgl.h"
+
+/*
+static char* op_table_str[] = {
+#define ADD_OP(a, b, c) "gl" #a " " #c,
+
+#include "opinfo.h"
+};
+*/
+
+void (*op_table_func[])(GLParam*) = {
+#define ADD_OP(a, b, c) glop##a,
+
+#include "opinfo.h"
+};
+
+GLint op_table_size[] = {
+#define ADD_OP(a, b, c) b + 1,
+
+#include "opinfo.h"
+};
+
+static GLList* find_list(GLuint list) { return gl_get_context()->shared_state.lists[list]; }
+
+static void delete_list(GLint list) {
+	GLContext* c = gl_get_context();
+	GLParamBuffer *pb, *pb1;
+	GLList* l;
+
+	l = find_list(list);
+	if (l == NULL) { 
+		return;
+	}
+	
+
+	/* free param buffer */
+	pb = l->first_op_buffer;
+	while (pb != NULL) {
+		pb1 = pb->next;
+		gl_free(pb);
+		pb = pb1;
+	}
+
+	gl_free(l);
+	c->shared_state.lists[list] = NULL;
+}
+void glDeleteLists(GLuint list, GLuint range) {
+	GLuint i;
+#include "error_check_no_context.h"
+	for (i = 0; i < list + range; i++)
+		glDeleteList(list + i);
+}
+void glDeleteList(GLuint list) {
+#include "error_check_no_context.h"
+	delete_list(list);
+}
+
+static GLList* alloc_list(GLint list) {
+	GLList* l;
+	GLParamBuffer* ob;
+	GLContext* c = gl_get_context();
+#define RETVAL NULL
+#include "error_check.h"
+	l = gl_zalloc(sizeof(GLList));
+	ob = gl_zalloc(sizeof(GLParamBuffer));
+
+#if TGL_FEATURE_ERROR_CHECK
+	if (!l || !ob)
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#define RETVAL NULL
+#include "error_check.h"
+
+#else
+	/* 
+	if(!l || !ob) gl_fatal_error("GL_OUT_OF_MEMORY");
+	 This will crash a few lines down, so, let it!
+	 */
+#endif
+		ob->next = NULL;
+	l->first_op_buffer = ob;
+
+	ob->ops[0].op = OP_EndList;
+
+	c->shared_state.lists[list] = l;
+	return l;
+}
+/*
+void gl_print_op(FILE* f, GLParam* p) {
+	GLint op;
+	char* s;
+
+	op = p[0].op;
+	p++;
+	s = op_table_str[op];
+	while (*s != 0) {
+		if (*s == '%') {
+			s++;
+			switch (*s++) {
+			case 'f':
+				fpr_ntf(f, "%g", p[0].f);
+				break;
+			default:
+				fpr_ntf(f, "%d", p[0].i);
+				break;
+			}
+			p++;
+		} else {
+			fputc(*s, f);
+			s++;
+		}
+	}
+	tgl_warning(f, "\n");
+}
+*/
+void glListBase(GLint n) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	c->listbase = n;
+}
+void glCallLists(GLsizei n, GLenum type, const GLuint* lists) {
+	GLint i;
+	GLContext* c = gl_get_context();
+	#include "error_check.h"
+	#if TGL_FEATURE_ERROR_CHECK == 1
+		if(type != GL_UNSIGNED_INT &&
+			type != GL_INT)
+	#define ERROR_FLAG GL_INVALID_ENUM
+	#include "error_check.h"
+	#endif
+	for (i = 0; i < n; i++)
+		glCallList(c->listbase + lists[i]);
+}
+void gl_compile_op(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint op, op_size;
+	GLParamBuffer *ob, *ob1;
+	GLint index, i;
+#include "error_check.h"
+	op = p[0].op;
+	op_size = op_table_size[op];
+	index = c->current_op_buffer_index;
+	ob = c->current_op_buffer;
+
+	/* we should be able to add a NextBuffer opcode */
+	if ((index + op_size) > (OP_BUFFER_MAX_SIZE - 2)) {
+
+		ob1 = gl_zalloc(sizeof(GLParamBuffer));
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (!ob1)
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+		
+		
+#endif
+			ob1->next = NULL;
+
+		ob->next = ob1;
+		ob->ops[index].op = OP_NextBuffer;
+		ob->ops[index + 1].p = (void*)ob1;
+
+		c->current_op_buffer = ob1;
+		ob = ob1;
+		index = 0;
+	}
+
+	for (i = 0; i < op_size; i++) {
+		ob->ops[index] = p[i];
+		index++;
+	}
+	c->current_op_buffer_index = index;
+}
+/* this opcode is never called directly */
+void glopEndList(GLParam* p) { exit(1); }
+
+/* this opcode is never called directly */
+void glopNextBuffer(GLParam* p) { exit(1); }
+
+void glopCallList(GLParam* p) {
+	
+	GLList* l;
+	GLint list;
+#include "error_check_no_context.h"
+	list = p[1].ui;
+	l = find_list(list);
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (l == NULL) {
+		gl_fatal_error("Bad list op, not defined");
+	}
+#else
+	
+#endif
+	p = l->first_op_buffer->ops;
+
+	while (1) {
+		GLint op;
+#include "error_check.h"
+		op = p[0].op;
+		if (op == OP_EndList)
+			break;
+		if (op == OP_NextBuffer) {
+			p = (GLParam*)p[1].p;
+		} else {
+			op_table_func[op](p);
+			p += op_table_size[op];
+		}
+	}
+}
+
+void glNewList(GLuint list, GLint mode) {
+	GLList* l;
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+
+	if (!(mode == GL_COMPILE || mode == GL_COMPILE_AND_EXECUTE))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+
+		if (!(c->compile_flag == 0))
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+
+#else
+	
+	
+#endif
+			l = find_list(list);
+	if (l != NULL)
+		delete_list(list);
+	l = alloc_list(list);
+#include "error_check.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (l == NULL)
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+	
+	if (l == NULL)
+		gl_fatal_error("Could not find or allocate list.");
+#endif
+		c->current_op_buffer = l->first_op_buffer;
+	c->current_op_buffer_index = 0;
+
+	c->compile_flag = 1;
+	c->exec_flag = (mode == GL_COMPILE_AND_EXECUTE);
+}
+
+void glEndList(void) {
+	GLContext* c = gl_get_context();
+	GLParam p[1];
+#include "error_check.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->compile_flag != 1)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	if (c->compile_flag != 1)
+		return;
+#endif
+		/* end of list */
+		p[0].op = OP_EndList;
+	gl_compile_op(p);
+
+	c->compile_flag = 0;
+	c->exec_flag = 1;
+}
+
+GLint glIsList(GLuint list) {
+	
+	GLList* l;
+	l = find_list(list);
+	return (l != NULL);
+}
+
+GLuint glGenLists(GLint range) {
+	GLint count, i, list;
+	GLList** lists;
+	GLContext* c = gl_get_context();
+#define RETVAL 0
+#include "error_check.h"
+	lists = c->shared_state.lists;
+	count = 0;
+	for (i = 0; i < MAX_DISPLAY_LISTS; i++) {
+		if (lists[i] == NULL) {
+			count++;
+			if (count == range) {
+				list = i - range + 1;
+				for (i = 0; i < range; i++) {
+					alloc_list(list + i);
+				}
+				return list;
+			}
+		} else {
+			count = 0;
+		}
+	}
+	return 0;
+}
diff --git a/src/other/tinygl/src/matrix.c b/src/other/tinygl/src/matrix.c
new file mode 100644
index 0000000000..6234352e94
--- /dev/null
+++ b/src/other/tinygl/src/matrix.c
@@ -0,0 +1,274 @@
+#include "msghandling.h"
+#include "zgl.h"
+void gl_print_matrix(const GLfloat* m) {
+	GLint i;
+
+	for (i = 0; i < 4; i++) {
+		tgl_warning("%f %f %f %f\n", m[i], m[4 + i], m[8 + i], m[12 + i]);
+	}
+}
+
+static void gl_matrix_update() {
+	GLContext* c = gl_get_context();
+	c->matrix_model_projection_updated = (c->matrix_mode <= 1);
+}
+
+void glopMatrixMode(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint mode = p[1].i;
+	switch (mode) {
+	case GL_MODELVIEW:
+		c->matrix_mode = 0;
+		break;
+	case GL_PROJECTION:
+		c->matrix_mode = 1;
+		break;
+	case GL_TEXTURE:
+		c->matrix_mode = 2;
+		break;
+	default:
+		break;
+		
+	}
+}
+
+void glopLoadMatrix(GLParam* p) {
+	GLContext* c = gl_get_context();
+	M4* m;
+	GLint i;
+
+	GLParam* q;
+
+	m = c->matrix_stack_ptr[c->matrix_mode];
+	q = p + 1;
+
+	for (i = 0; i < 4; i++) {
+		m->m[0][i] = q[0].f;
+		m->m[1][i] = q[1].f;
+		m->m[2][i] = q[2].f;
+		m->m[3][i] = q[3].f;
+		q += 4;
+	}
+
+	gl_matrix_update();
+}
+
+void glopLoadIdentity(GLParam* p) {
+	GLContext* c = gl_get_context();
+
+	gl_M4_Id(c->matrix_stack_ptr[c->matrix_mode]);
+
+	gl_matrix_update();
+}
+
+void glopMultMatrix(GLParam* p) {
+	GLContext* c = gl_get_context();
+	M4 m;
+	GLint i;
+
+	GLParam* q;
+	q = p + 1;
+
+	for (i = 0; i < 4; i++) {
+		m.m[0][i] = q[0].f;
+		m.m[1][i] = q[1].f;
+		m.m[2][i] = q[2].f;
+		m.m[3][i] = q[3].f;
+		q += 4;
+	}
+
+	gl_M4_MulLeft(c->matrix_stack_ptr[c->matrix_mode], &m);
+
+	gl_matrix_update();
+}
+
+void glopPushMatrix(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint n = c->matrix_mode;
+	M4* m;
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!((c->matrix_stack_ptr[n] - c->matrix_stack[n] + 1) < c->matrix_stack_depth_max[n]))
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#endif
+
+		m = ++c->matrix_stack_ptr[n];
+
+	gl_M4_Move(&m[0], &m[-1]);
+
+	gl_matrix_update();
+}
+
+void glopPopMatrix(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint n = c->matrix_mode;
+
+	
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(c->matrix_stack_ptr[n] > c->matrix_stack[n]))
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#endif
+		c->matrix_stack_ptr[n]--;
+	gl_matrix_update();
+}
+
+void glopRotate(GLParam* p) {
+	GLContext* c = gl_get_context();
+	M4 m;
+	GLfloat u[3];
+	GLfloat angle;
+	GLint dir_code;
+
+	angle = p[1].f * M_PI / 180.0;
+	u[0] = p[2].f;
+	u[1] = p[3].f;
+	u[2] = p[4].f;
+
+	/* simple case detection */
+	dir_code = ((u[0] != 0) << 2) | ((u[1] != 0) << 1) | (u[2] != 0);
+
+	switch (dir_code) {
+	case 0:
+		gl_M4_Id(&m);
+		break;
+	case 4:
+		if (u[0] < 0)
+			angle = -angle;
+		gl_M4_Rotate(&m, angle, 0);
+		break;
+	case 2:
+		if (u[1] < 0)
+			angle = -angle;
+		gl_M4_Rotate(&m, angle, 1);
+		break;
+	case 1:
+		if (u[2] < 0)
+			angle = -angle;
+		gl_M4_Rotate(&m, angle, 2);
+		break;
+	default: {
+		GLfloat cost, sint;
+
+		/* normalize vector */
+
+#if TGL_FEATURE_FISR == 1
+		GLfloat len = u[0] + u[1] + u[2];
+		if (len == 0.0f)
+			return;
+		len = fastInvSqrt(len); /* FISR*/
+#else
+		GLfloat len = u[0] * u[0] + u[1] * u[1] + u[2] * u[2];
+		if (len == 0.0f)
+			return;
+		len = 1.0f / sqrt(len);
+#endif
+		u[0] *= len;
+		u[1] *= len;
+		u[2] *= len;
+		/* store cos and sin values */
+		cost = cos(angle);
+		sint = sin(angle);
+
+		/* fill in the values */
+		m.m[3][0] = m.m[3][1] = m.m[3][2] = m.m[0][3] = m.m[1][3] = m.m[2][3] = 0.0f;
+		m.m[3][3] = 1.0f;
+
+		/* do the math */
+		m.m[0][0] = u[0] * u[0] + cost * (1 - u[0] * u[0]);
+		m.m[1][0] = u[0] * u[1] * (1 - cost) - u[2] * sint;
+		m.m[2][0] = u[2] * u[0] * (1 - cost) + u[1] * sint;
+		m.m[0][1] = u[0] * u[1] * (1 - cost) + u[2] * sint;
+		m.m[1][1] = u[1] * u[1] + cost * (1 - u[1] * u[1]);
+		m.m[2][1] = u[1] * u[2] * (1 - cost) - u[0] * sint;
+		m.m[0][2] = u[2] * u[0] * (1 - cost) - u[1] * sint;
+		m.m[1][2] = u[1] * u[2] * (1 - cost) + u[0] * sint;
+		m.m[2][2] = u[2] * u[2] + cost * (1 - u[2] * u[2]);
+	}
+	}
+
+	gl_M4_MulLeft(c->matrix_stack_ptr[c->matrix_mode], &m);
+
+	gl_matrix_update();
+}
+
+void glopScale(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLfloat* m;
+	GLfloat x = p[1].f, y = p[2].f, z = p[3].f;
+
+	m = &c->matrix_stack_ptr[c->matrix_mode]->m[0][0];
+
+	m[0] *= x;
+	m[1] *= y;
+	m[2] *= z;
+	m[4] *= x;
+	m[5] *= y;
+	m[6] *= z;
+	m[8] *= x;
+	m[9] *= y;
+	m[10] *= z;
+	m[12] *= x;
+	m[13] *= y;
+	m[14] *= z;
+	gl_matrix_update();
+}
+
+void glopTranslate(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLfloat* m;
+	GLfloat x = p[1].f, y = p[2].f, z = p[3].f;
+
+	m = &c->matrix_stack_ptr[c->matrix_mode]->m[0][0];
+
+	m[3] = m[0] * x + m[1] * y + m[2] * z + m[3];
+	m[7] = m[4] * x + m[5] * y + m[6] * z + m[7];
+	m[11] = m[8] * x + m[9] * y + m[10] * z + m[11];
+	m[15] = m[12] * x + m[13] * y + m[14] * z + m[15];
+
+	gl_matrix_update();
+}
+
+void glopFrustum(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLfloat* r;
+	M4 m;
+	GLfloat left = p[1].f;
+	GLfloat right = p[2].f;
+	GLfloat bottom = p[3].f;
+	GLfloat top = p[4].f;
+	GLfloat near = p[5].f;
+	GLfloat farp = p[6].f;
+	GLfloat x, y, A, B, C, D;
+
+	x = (2.0 * near) / (right - left);
+	y = (2.0 * near) / (top - bottom);
+	A = (right + left) / (right - left);
+	B = (top + bottom) / (top - bottom);
+	C = -(farp + near) / (farp - near);
+	D = -(2.0 * farp * near) / (farp - near);
+
+	r = &m.m[0][0];
+	r[0] = x;
+	r[1] = 0;
+	r[2] = A;
+	r[3] = 0;
+	r[4] = 0;
+	r[5] = y;
+	r[6] = B;
+	r[7] = 0;
+	r[8] = 0;
+	r[9] = 0;
+	r[10] = C;
+	r[11] = D;
+	r[12] = 0;
+	r[13] = 0;
+	r[14] = -1;
+	r[15] = 0;
+
+	gl_M4_MulLeft(c->matrix_stack_ptr[c->matrix_mode], &m);
+
+	gl_matrix_update();
+}
diff --git a/src/other/tinygl/src/memory.c b/src/other/tinygl/src/memory.c
new file mode 100644
index 0000000000..d3110e21e5
--- /dev/null
+++ b/src/other/tinygl/src/memory.c
@@ -0,0 +1,18 @@
+/*
+ * Memory allocator for TinyGL
+ */
+#include<string.h>
+#include<stdlib.h>
+#include "zgl.h"
+
+static inline void required_for_compilation_(){
+	return;
+}
+
+/* modify these functions so that they suit your needs */
+#include <string.h>
+void gl_free(void* p) { free(p); }
+
+void* gl_malloc(GLint size) { return malloc(size); }
+
+void* gl_zalloc(GLint size) { return calloc(1, size); }
diff --git a/src/other/tinygl/src/misc.c b/src/other/tinygl/src/misc.c
new file mode 100644
index 0000000000..3369f6a566
--- /dev/null
+++ b/src/other/tinygl/src/misc.c
@@ -0,0 +1,294 @@
+#include "msghandling.h"
+#include "zgl.h"
+
+GLContext* gl_get_context(void) { return &gl_ctx; }
+
+void glPolygonStipple(void* a) {
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	ZBuffer* zb = c->zb;
+
+	memcpy(zb->stipplepattern, a, TGL_POLYGON_STIPPLE_BYTES);
+	for (GLint i = 0; i < TGL_POLYGON_STIPPLE_BYTES; i++) {
+		zb->stipplepattern[i] = ((GLubyte*)a)[i];
+	}
+#endif
+}
+
+void glopViewport(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint xsize, ysize, xmin, ymin, xsize_req, ysize_req;
+
+	xmin = p[1].i;
+	ymin = p[2].i;
+	xsize = p[3].i;
+	ysize = p[4].i;
+
+	/* we may need to resize the zbuffer */
+
+	if (c->viewport.xmin != xmin || c->viewport.ymin != ymin || c->viewport.xsize != xsize || c->viewport.ysize != ysize) {
+
+		xsize_req = xmin + xsize;
+		ysize_req = ymin + ysize;
+
+		if (c->gl_resize_viewport && c->gl_resize_viewport(&xsize_req, &ysize_req) != 0) {
+			gl_fatal_error("glViewport: error while resizing display");
+		}
+		if (xsize <= 0 || ysize <= 0) {
+			gl_fatal_error("glViewport: size too small");
+		}
+
+		
+		c->viewport.xmin = xmin;
+		c->viewport.ymin = ymin;
+		c->viewport.xsize = xsize;
+		c->viewport.ysize = ysize;
+
+		
+		gl_eval_viewport();
+		
+	}
+}
+void glBlendFunc(GLenum sfactor, GLenum dfactor) {
+	GLParam p[3];
+#include "error_check_no_context.h"
+	p[0].op = OP_BlendFunc;
+	p[1].i = sfactor;
+	p[2].i = dfactor;
+	gl_add_op(p);
+	return;
+}
+void glopBlendFunc(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->zb->sfactor = p[1].i;
+	c->zb->dfactor = p[2].i;
+}
+
+void glBlendEquation(GLenum mode) {
+	GLParam p[2];
+#include "error_check_no_context.h"
+	p[0].op = OP_BlendEquation;
+	p[1].i = mode;
+	gl_add_op(p);
+}
+void glopBlendEquation(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->zb->blendeq = p[1].i;
+}
+
+void glopPointSize(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->zb->pointsize = p[1].f;
+}
+void glPointSize(GLfloat f) {
+	GLParam p[2];
+	p[0].op = OP_PointSize;
+#include "error_check_no_context.h"
+	p[1].f = f;
+	gl_add_op(p);
+}
+
+void glopEnableDisable(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint code = p[1].i;
+	GLint v = p[2].i;
+
+	switch (code) {
+	case GL_CULL_FACE:
+		c->cull_face_enabled = v;
+		break;
+	case GL_LIGHTING:
+		c->lighting_enabled = v;
+		break;
+	case GL_COLOR_MATERIAL:
+		c->color_material_enabled = v;
+		break;
+	case GL_TEXTURE_2D:
+		c->texture_2d_enabled = v;
+		break;
+	case GL_BLEND:
+		c->zb->enable_blend = v;
+		break;
+	case GL_NORMALIZE:
+		c->normalize_enabled = v;
+		break;
+	case GL_DEPTH_TEST:
+		c->zb->depth_test = v;
+		break;
+	case GL_POLYGON_OFFSET_FILL:
+		if (v)
+			c->offset_states |= TGL_OFFSET_FILL;
+		else
+			c->offset_states &= ~TGL_OFFSET_FILL;
+		break;
+	case GL_POLYGON_STIPPLE:
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+		c->zb->dostipple = v;
+#endif
+		break;
+	case GL_POLYGON_OFFSET_POINT:
+		if (v)
+			c->offset_states |= TGL_OFFSET_POINT;
+		else
+			c->offset_states &= ~TGL_OFFSET_POINT;
+		break;
+	case GL_POLYGON_OFFSET_LINE:
+		if (v)
+			c->offset_states |= TGL_OFFSET_LINE;
+		else
+			c->offset_states &= ~TGL_OFFSET_LINE;
+		break;
+	default:
+		if (code >= GL_LIGHT0 && code < GL_LIGHT0 + MAX_LIGHTS) {
+			gl_enable_disable_light(code - GL_LIGHT0, v);
+		} else {
+			tgl_warning("glEnableDisable: 0x%X not supported.\n", code);
+		}
+		break;
+	}
+}
+
+void glopShadeModel(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint code = p[1].i;
+	c->current_shade_model = code;
+}
+
+void glopCullFace(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint code = p[1].i;
+	c->current_cull_face = code;
+}
+
+void glopFrontFace(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint code = p[1].i;
+	c->current_front_face = code;
+}
+
+void glopPolygonMode(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint face = p[1].i;
+	GLint mode = p[2].i;
+
+	switch (face) {
+	case GL_BACK:
+		c->polygon_mode_back = mode;
+		break;
+	case GL_FRONT:
+		c->polygon_mode_front = mode;
+		break;
+	case GL_FRONT_AND_BACK:
+		c->polygon_mode_front = mode;
+		c->polygon_mode_back = mode;
+		break;
+	default:
+		break;
+	}
+}
+
+void glopPolygonOffset(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->offset_factor = p[1].f;
+	c->offset_units = p[2].f;
+}
+
+GLenum glGetError() {
+#if TGL_FEATURE_ERROR_CHECK == 1
+	GLContext* c = gl_get_context();
+	GLenum eflag = c->error_flag;
+	if (eflag != GL_OUT_OF_MEMORY) 
+		c->error_flag = GL_NO_ERROR;
+	return eflag;
+#else
+	return GL_NO_ERROR;
+#endif
+}
+
+void glDrawBuffer(GLenum mode) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	if ((mode != GL_FRONT && mode != GL_NONE) || c->in_begin) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	c->drawbuffer = mode;
+}
+
+void glReadBuffer(GLenum mode) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	if ((mode != GL_FRONT && mode != GL_NONE) || c->in_begin) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	c->readbuffer = mode;
+}
+
+
+void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* data) {
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	if (c->readbuffer != GL_FRONT || (format != GL_RGBA && format != GL_RGB && format != GL_DEPTH_COMPONENT) ||
+#if TGL_FEATURE_RENDER_BITS == 32
+		(type != GL_UNSIGNED_INT && type != GL_UNSIGNED_INT_8_8_8_8)
+#elif TGL_FEATURE_RENDER_BITS == 16
+		(type != GL_UNSIGNED_SHORT && type != GL_UNSIGNED_SHORT_5_6_5)
+#else
+#error "Unsupported TGL_FEATURE_RENDER_BITS"
+#endif
+
+	) {
+#if TGL_FEATURE_ERROR_CHECK
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	/* TODO: implement read pixels.*/
+}
+
+void glFinish() { return; }
+
+void gl_eval_viewport() {
+        GLContext* c = gl_get_context();
+        GLViewport* v;
+        GLfloat zsize = (1 << (ZB_Z_BITS + ZB_POINT_Z_FRAC_BITS));
+
+        v = &c->viewport;
+
+        v->trans.X = ((v->xsize - 0.5) / 2.0) + v->xmin;
+        v->trans.Y = ((v->ysize - 0.5) / 2.0) + v->ymin;
+        v->trans.Z = ((zsize - 0.5) / 2.0) + ((1 << ZB_POINT_Z_FRAC_BITS)) / 2;
+
+        v->scale.X = (v->xsize - 0.5) / 2.0;
+        v->scale.Y = -(v->ysize - 0.5) / 2.0;
+        v->scale.Z = -((zsize - 0.5) / 2.0);
+}
+
+GLint gl_clipcode(GLfloat x, GLfloat y, GLfloat z, GLfloat w1) {
+        GLfloat w;
+
+        w = w1 * (1.0 + CLIP_EPSILON);
+        return (x < -w) | ((x > w) << 1) | ((y < -w) << 2) | ((y > w) << 3) | ((z < -w) << 4) | ((z > w) << 5);
+}
+
+GLfloat clampf(GLfloat a, GLfloat min, GLfloat max) {
+        if (a < min)
+                return min;
+        else if (a > max)
+                return max;
+        else
+                return a;
+}
+
diff --git a/src/other/tinygl/src/msghandling.c b/src/other/tinygl/src/msghandling.c
new file mode 100644
index 0000000000..622ffe53dc
--- /dev/null
+++ b/src/other/tinygl/src/msghandling.c
@@ -0,0 +1,64 @@
+#include "msghandling.h"
+#include "../include/TGL/gl.h"
+#include "zgl.h"
+#include <stdarg.h>
+
+
+#ifdef __TINYC__
+#define NO_DEBUG_OUTPUT
+#endif
+
+#ifndef NO_DEBUG_OUTPUT
+#include <stdio.h>
+#endif
+/* Use this function to output messages when something unexpected
+   happens (which might be an indication of an error). *Don't* use it
+   when there's GLinternal errors in the code - these should be handled
+   by asserts. */
+void tgl_warning(const char* format, ...) {
+#ifndef NO_DEBUG_OUTPUT
+	va_list args;
+	va_start(args, format);
+	fprintf(stderr, "*WARNING* ");
+	vfprintf(stderr, format, args);
+	va_end(args);
+#endif /* !NO_DEBUG_OUTPUT */
+}
+
+/* This function should be used for debug output only. */
+void tgl_trace(const char* format, ...) {
+#ifndef NO_DEBUG_OUTPUT
+	va_list args;
+	va_start(args, format);
+	fprintf(stderr, "*DEBUG* ");
+	vfprintf(stderr, format, args);
+	va_end(args);
+#endif /* !NO_DEBUG_OUTPUT */
+}
+
+/* Use this function to output info about things in the code which
+   should be fixed (missing handling of special cases, important
+   features not implemented, known bugs/buglets, ...). */
+void tgl_fixme(const char* format, ...) {
+#ifndef NO_DEBUG_OUTPUT
+	va_list args;
+	va_start(args, format);
+	fprintf(stderr, "*FIXME* ");
+	vfprintf(stderr, format, args);
+	va_end(args);
+#endif /* !NO_DEBUG_OUTPUT */
+}
+
+void gl_fatal_error(char* format, ...) {
+#ifndef NO_DEBUG_OUTPUT
+	va_list ap;
+	va_start(ap, format);
+	fprintf(stderr, "TinyGL: fatal error: ");
+	vfprintf(stderr, format, ap);
+	fprintf(stderr, "\n");
+	exit(1);
+	va_end(ap);
+#else
+	exit(1);
+#endif
+}
diff --git a/src/other/tinygl/src/msghandling.h b/src/other/tinygl/src/msghandling.h
new file mode 100644
index 0000000000..9c75b93a3f
--- /dev/null
+++ b/src/other/tinygl/src/msghandling.h
@@ -0,0 +1,8 @@
+#ifndef _msghandling_h_
+#define _msghandling_h_
+#include "../include/TGL/gl.h"
+extern void tgl_warning(const char* text, ...);
+extern void tgl_trace(const char* text, ...);
+extern void tgl_fixme(const char* text, ...);
+
+#endif /* _msghandling_h_ */
diff --git a/src/other/tinygl/src/opinfo.h b/src/other/tinygl/src/opinfo.h
new file mode 100644
index 0000000000..123b84363b
--- /dev/null
+++ b/src/other/tinygl/src/opinfo.h
@@ -0,0 +1,92 @@
+
+
+ADD_OP(Color, 7, "%f %f %f %f %d %d %d")
+ADD_OP(TexCoord, 4, "%f %f %f %f")
+ADD_OP(EdgeFlag, 1, "%d")
+ADD_OP(Normal, 3, "%f %f %f")
+
+ADD_OP(Begin, 1, "%C")
+ADD_OP(Vertex, 4, "%f %f %f %f")
+ADD_OP(End, 0, "")
+
+ADD_OP(EnableDisable, 2, "%C %d")
+
+ADD_OP(MatrixMode, 1, "%C")
+ADD_OP(LoadMatrix, 16, "")
+ADD_OP(LoadIdentity, 0, "")
+ADD_OP(MultMatrix, 16, "")
+ADD_OP(PushMatrix, 0, "")
+ADD_OP(PopMatrix, 0, "")
+ADD_OP(Rotate, 4, "%f %f %f %f")
+ADD_OP(Translate, 3, "%f %f %f")
+ADD_OP(Scale, 3, "%f %f %f")
+
+ADD_OP(Viewport, 4, "%d %d %d %d")
+ADD_OP(Frustum, 6, "%f %f %f %f %f %f")
+
+ADD_OP(Material, 6, "%C %C %f %f %f %f")
+ADD_OP(ColorMaterial, 2, "%C %C")
+ADD_OP(Light, 6, "%C %C %f %f %f %f")
+ADD_OP(LightModel, 5, "%C %f %f %f %f")
+
+ADD_OP(Clear, 1, "%d")
+ADD_OP(ClearColor, 4, "%f %f %f %f")
+ADD_OP(ClearDepth, 1, "%f")
+
+ADD_OP(InitNames, 0, "")
+ADD_OP(PushName, 1, "%d")
+ADD_OP(PopName, 0, "")
+ADD_OP(LoadName, 1, "%d")
+
+ADD_OP(TexImage2D, 9, "%d %d %d  %d %d %d  %d %d %d")
+ADD_OP(TexImage1D, 8, "%d %d  %d %d %d  %d %d %d")
+ADD_OP(CopyTexImage2D, 8, "%d %d %d %d  %d %d %d %d")
+ADD_OP(BindTexture, 2, "%C %d")
+
+
+
+
+ADD_OP(ShadeModel, 1, "%C")
+ADD_OP(CullFace, 1, "%C")
+ADD_OP(FrontFace, 1, "%C")
+ADD_OP(PolygonMode, 2, "%C %C")
+
+ADD_OP(CallList, 1, "%d")
+
+
+/* special opcodes */
+ADD_OP(EndList, 0, "")
+ADD_OP(NextBuffer, 1, "%p")
+
+/* opengl 1.1 arrays */
+ADD_OP(ArrayElement, 1, "%d")
+ADD_OP(EnableClientState, 1, "%C")
+ADD_OP(DisableClientState, 1, "%C")
+ADD_OP(VertexPointer, 4, "%d %C %d %p")
+ADD_OP(ColorPointer, 4, "%d %C %d %p")
+ADD_OP(NormalPointer, 3, "%C %d %p")
+ADD_OP(TexCoordPointer, 4, "%d %C %d %p")
+
+/* opengl 1.1 polygon offset */
+ADD_OP(PolygonOffset, 2, "%f %f")
+
+/* blending */
+ADD_OP(BlendEquation, 1, "%d")
+ADD_OP(BlendFunc, 2, "%d %d")
+
+/* point size */
+ADD_OP(PointSize, 1, "%f")
+
+/* raster position */
+ADD_OP(RasterPos, 4, "%f %f %f %f")
+ADD_OP(PixelZoom, 2, "%f %f")
+/* Draw pixels*/
+/* Width, Height, Data*/
+ADD_OP(DrawPixels, 3, "%d %d %p")
+
+/* Gek's Added Functions */
+ADD_OP(PlotPixel, 2, "%d %d")
+ADD_OP(TextSize, 1, "%d")
+ADD_OP(SetEnableSpecular, 1, "%d")
+
+#undef ADD_OP
diff --git a/src/other/tinygl/src/select.c b/src/other/tinygl/src/select.c
new file mode 100644
index 0000000000..e43004e4f8
--- /dev/null
+++ b/src/other/tinygl/src/select.c
@@ -0,0 +1,352 @@
+#include "zgl.h"
+
+GLint glRenderMode(GLint mode) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	switch (c->render_mode) {
+	case GL_RENDER:
+		break;
+	case GL_SELECT:
+		if (c->select_overflow) {
+			result = -c->select_hits;
+		} else {
+			result = c->select_hits;
+		}
+		c->select_overflow = 0;
+		c->select_ptr = c->select_buffer;
+		c->name_stack_size = 0;
+		break;
+	case GL_FEEDBACK:
+		if (c->feedback_overflow)
+			result = -c->feedback_hits;
+		else
+			result = c->feedback_hits;
+		c->feedback_overflow = 0;
+		c->feedback_hits = 0;
+		c->feedback_ptr = c->feedback_buffer;
+		break;
+	default:
+		gl_fatal_error("GLContext's Rendermode was somehow erroneously set.");
+	}
+	switch (mode) {
+	case GL_RENDER:
+		c->render_mode = GL_RENDER;
+		break;
+	case GL_SELECT:
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (c->select_buffer == NULL)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#define RETVAL 0
+#include "error_check.h"
+#else
+		if (c->select_buffer == NULL)
+			return 0;
+#endif
+			c->render_mode = GL_SELECT;
+		c->select_ptr = c->select_buffer;
+		c->select_hits = 0;
+		c->select_overflow = 0;
+		c->select_hit = NULL;
+		break;
+	case GL_FEEDBACK:
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (c->feedback_buffer == NULL)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#define RETVAL 0
+#include "error_check.h"
+#else
+		if (c->feedback_buffer == NULL)
+			return 0;
+#endif
+			c->render_mode = GL_FEEDBACK;
+		c->feedback_hits = 0;
+		c->feedback_ptr = c->feedback_buffer;
+		c->feedback_overflow = 0;
+		break;
+	default:
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define RETVAL 0
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+
+#else
+		return 0;
+#endif
+	}
+	return result;
+#else
+	
+	return 0;
+#endif
+}
+
+void glSelectBuffer(GLint size, GLuint* buf) {
+
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->render_mode == GL_SELECT)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	if (c->render_mode == GL_SELECT)
+		return;
+#endif
+
+		c->select_buffer = buf;
+	c->select_size = size;
+#else
+	return;
+#endif
+}
+
+void glFeedbackBuffer(GLint size, GLenum type, GLfloat* buf) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->render_mode == GL_FEEDBACK || !(type == GL_2D || type == GL_3D || type == GL_3D_COLOR || type == GL_3D_COLOR_TEXTURE || type == GL_4D_COLOR_TEXTURE))
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	if (c->render_mode == GL_FEEDBACK || !(type == GL_2D || type == GL_3D || type == GL_3D_COLOR || type == GL_3D_COLOR_TEXTURE || type == GL_4D_COLOR_TEXTURE))
+		return;
+#endif
+		c->feedback_buffer = buf;
+	c->feedback_size = size;
+	c->feedback_type = type;
+#else
+	return;
+#endif
+}
+
+void gl_add_feedback(GLfloat token, GLVertex* v1, GLVertex* v2, GLVertex* v3, GLfloat passthrough_token_value) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	if (c->feedback_overflow)
+		return;
+	GLuint feedback_hits_needed = 2;
+	GLuint vertex_feedback_hits_needed = 0;
+	GLuint vertex_pos_hits_needed = 2;
+	GLuint vertex_color_hits_needed = 4;
+	GLuint vertex_texture_hits_needed = 4;
+#if TGL_FEATURE_ERROR_CHECK == 1
+	GLuint done = 0;
+#endif
+	switch (c->feedback_type) {
+	case GL_2D:
+		vertex_feedback_hits_needed = 2;
+		vertex_pos_hits_needed = 2;
+		vertex_color_hits_needed = 0;
+		vertex_texture_hits_needed = 0;
+		break;
+	case GL_3D:
+		vertex_feedback_hits_needed = 3;
+		vertex_pos_hits_needed = 3;
+		vertex_color_hits_needed = 0;
+		vertex_texture_hits_needed = 0;
+		break;
+	case GL_3D_COLOR:
+		vertex_feedback_hits_needed = 3 + 4;
+		vertex_pos_hits_needed = 3;
+		vertex_color_hits_needed = 4;
+		vertex_texture_hits_needed = 0;
+		break;
+	case GL_3D_COLOR_TEXTURE:
+		vertex_feedback_hits_needed = 3 + 4 + 4;
+		vertex_pos_hits_needed = 3;
+		vertex_color_hits_needed = 4;
+		vertex_texture_hits_needed = 4;
+		break;
+	case GL_4D_COLOR_TEXTURE:
+		vertex_feedback_hits_needed = 4 + 4 + 4;
+		vertex_pos_hits_needed = 4;
+		vertex_color_hits_needed = 4;
+		vertex_texture_hits_needed = 4;
+		break;
+	default:
+		vertex_feedback_hits_needed = 0;
+		vertex_pos_hits_needed = 0;
+		vertex_color_hits_needed = 0;
+		vertex_texture_hits_needed = 0;
+		break;
+	}
+	if (token == GL_PASS_THROUGH_TOKEN)
+		feedback_hits_needed = 1 + 1; 
+	else if (token == GL_POINT_TOKEN)
+		feedback_hits_needed = 1 + 1 * vertex_feedback_hits_needed; 
+	else if (token == GL_LINE_TOKEN || token == GL_LINE_RESET_TOKEN)
+		feedback_hits_needed = 1 + 2 * vertex_feedback_hits_needed; 
+	else if (token == GL_POLYGON_TOKEN)
+		feedback_hits_needed = 1 + 1 + 3 * vertex_feedback_hits_needed; 
+	else if (token == GL_BITMAP_TOKEN)
+		feedback_hits_needed = 1 + 1 * vertex_feedback_hits_needed; 
+	else if (token == GL_DRAW_PIXEL_TOKEN || token == GL_COPY_PIXEL_TOKEN)
+		feedback_hits_needed = 1 + 1 * vertex_feedback_hits_needed; 
+	else
+		return;
+	c->feedback_hits += feedback_hits_needed;
+	if (c->feedback_hits > (GLint)c->feedback_size) {
+		c->feedback_overflow = 1;
+		c->feedback_hits -= feedback_hits_needed;
+		return;
+	}
+	
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define DONE_ERROR_CHECK                                                                                                                                       \
+	{                                                                                                                                                          \
+		if (++done > feedback_hits_needed) {                                                                                                                   \
+			gl_fatal_error("\nBAD FEEDBACK BUFFER WRITE DETECTED\n");                                                                                          \
+		}                                                                                                                                                      \
+	}
+#else
+#define DONE_ERROR_CHECK /* a comment*/
+#endif
+#define WRITE_FLOAT(f)                                                                                                                                         \
+	{                                                                                                                                                          \
+		DONE_ERROR_CHECK;                                                                                                                                      \
+		*(c->feedback_ptr++) = f;                                                                                                                              \
+	}
+#define WRITE_UINT(u)                                                                                                                                          \
+	{                                                                                                                                                          \
+		DONE_ERROR_CHECK;                                                                                                                                      \
+		*(((GLuint*)c->feedback_ptr++)) = u;                                                                                                                   \
+	}
+#define WRITE_VERTEX(v)                                                                                                                                        \
+	{                                                                                                                                                          \
+		if (vertex_pos_hits_needed == 2) {                                                                                                                     \
+			WRITE_FLOAT(v->zp.x)                                                                                                                               \
+			WRITE_FLOAT(v->zp.y)                                                                                                                               \
+		}                                                                                                                                                      \
+		if (vertex_pos_hits_needed == 3) {                                                                                                                     \
+			WRITE_FLOAT(v->zp.x)                                                                                                                               \
+			WRITE_FLOAT(v->zp.y)                                                                                                                               \
+			WRITE_FLOAT(v->zp.z)                                                                                                                               \
+		}                                                                                                                                                      \
+		if (vertex_pos_hits_needed == 4) {                                                                                                                     \
+			WRITE_FLOAT(v->zp.x)                                                                                                                               \
+			WRITE_FLOAT(v->zp.y)                                                                                                                               \
+			WRITE_FLOAT(v->zp.z)                                                                                                                               \
+			WRITE_FLOAT(v->pc.W)                                                                                                                               \
+		}                                                                                                                                                      \
+		if (vertex_color_hits_needed == 4) {                                                                                                                   \
+			WRITE_FLOAT(v->color.X)                                                                                                                            \
+			WRITE_FLOAT(v->color.Y)                                                                                                                            \
+			WRITE_FLOAT(v->color.Z)                                                                                                                            \
+			WRITE_FLOAT(v->color.W)                                                                                                                            \
+		}                                                                                                                                                      \
+		if (vertex_texture_hits_needed == 4) {                                                                                                                 \
+			WRITE_FLOAT(v->tex_coord.X)                                                                                                                        \
+			WRITE_FLOAT(v->tex_coord.Y)                                                                                                                        \
+			WRITE_FLOAT(v->tex_coord.Z)                                                                                                                        \
+			WRITE_FLOAT(v->tex_coord.W)                                                                                                                        \
+		}                                                                                                                                                      \
+	}
+	if (token == GL_PASS_THROUGH_TOKEN) {
+		WRITE_UINT(GL_PASS_THROUGH_TOKEN);
+		WRITE_FLOAT(passthrough_token_value);
+	} else if (token == GL_LINE_TOKEN || token == GL_LINE_RESET_TOKEN) {
+		WRITE_UINT(token);
+		WRITE_VERTEX(v1);
+		WRITE_VERTEX(v2);
+	} else if (token == GL_POLYGON_TOKEN) {
+		WRITE_UINT(GL_POLYGON_TOKEN);
+		WRITE_UINT(3);
+		WRITE_VERTEX(v1);
+		WRITE_VERTEX(v2);
+		WRITE_VERTEX(v3);
+	} else if (token == GL_BITMAP_TOKEN) {
+		WRITE_UINT(GL_BITMAP_TOKEN);
+		WRITE_VERTEX(v1);
+	} else if (token == GL_DRAW_PIXEL_TOKEN || token == GL_COPY_PIXEL_TOKEN) {
+		WRITE_UINT(token);
+		WRITE_VERTEX(v1);
+	}
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (done != feedback_hits_needed)
+		gl_fatal_error("Failed to write enough information to the buffer.");
+#endif
+/* End of gl_add_feedback*/
+#endif
+	return;
+}
+void glPassThrough(GLfloat token) {
+
+#include "error_check_no_context.h"
+	gl_add_feedback(GL_PASS_THROUGH_TOKEN, NULL, NULL, NULL, token);
+}
+void glopInitNames(GLParam* p) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	if (c->render_mode == GL_SELECT) {
+		c->name_stack_size = 0;
+		c->select_hit = NULL;
+	}
+#endif
+}
+
+void glopPushName(GLParam* p) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	if (c->render_mode == GL_SELECT) {
+		
+		c->name_stack[c->name_stack_size++] = p[1].i;
+		c->select_hit = NULL;
+	}
+#endif
+}
+
+void glopPopName(GLParam* p) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	if (c->render_mode == GL_SELECT) {
+		
+		c->name_stack_size--;
+		c->select_hit = NULL;
+	}
+#endif
+}
+
+void glopLoadName(GLParam* p) {
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	if (c->render_mode == GL_SELECT) {
+		
+		c->name_stack[c->name_stack_size - 1] = p[1].i;
+		c->select_hit = NULL;
+	}
+#endif
+}
+
+void gl_add_select(GLuint zmin, GLuint zmax) {
+
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLContext* c = gl_get_context();
+	GLuint* ptr;
+	GLint n, i;
+	if (!c->select_overflow) {
+		if (c->select_hit == NULL) {
+			n = c->name_stack_size;
+			if ((c->select_ptr - c->select_buffer + 3 + n) > c->select_size) { 
+				c->select_overflow = 1;
+			} else {
+				ptr = c->select_ptr;
+				c->select_hit = ptr;
+				*ptr++ = c->name_stack_size;
+				*ptr++ = zmin;
+				*ptr++ = zmax;
+				for (i = 0; i < n; i++)
+					*ptr++ = c->name_stack[i];
+				c->select_ptr = ptr;
+				c->select_hits++;
+			}
+		} else {
+			if (zmin < c->select_hit[1])
+				c->select_hit[1] = zmin;
+			if (zmax > c->select_hit[2])
+				c->select_hit[2] = zmax;
+		}
+	}
+#else
+	return;
+#endif
+}
diff --git a/src/other/tinygl/src/specbuf.c b/src/other/tinygl/src/specbuf.c
new file mode 100644
index 0000000000..7b2565aa65
--- /dev/null
+++ b/src/other/tinygl/src/specbuf.c
@@ -0,0 +1,60 @@
+#include "msghandling.h"
+#include "zgl.h"
+#include <math.h>
+#include <stdlib.h>
+
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+
+static void calc_buf(GLSpecBuf* buf, const GLfloat shininess) {
+	GLint i;
+	GLfloat val, inc;
+	val = 0.0f;
+	inc = 1.0f / SPECULAR_BUFFER_SIZE;
+	for (i = 0; i <= SPECULAR_BUFFER_SIZE; i++) {
+		buf->buf[i] = pow(val, shininess);
+		val += inc;
+	}
+}
+
+GLSpecBuf* specbuf_get_buffer(GLContext* c, const GLint shininess_i, const GLfloat shininess) {
+	GLSpecBuf *found, *oldest;
+	found = oldest = c->specbuf_first;
+	while (found && found->shininess_i != shininess_i) {
+		if (found->last_used < oldest->last_used) {
+			oldest = found;
+		}
+		found = found->next;
+	}
+	if (found) { /* hey, found one! */
+		found->last_used = c->specbuf_used_counter++;
+		return found;
+	}
+	if (oldest == NULL || c->specbuf_num_buffers < MAX_SPECULAR_BUFFERS) {
+		/* create new buffer */
+		GLSpecBuf* buf = gl_malloc(sizeof(GLSpecBuf));
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (!buf)
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#define RETVAL NULL
+#include "error_check.h"
+#else
+		
+		
+#endif
+			c->specbuf_num_buffers++;
+		buf->next = c->specbuf_first;
+		c->specbuf_first = buf;
+		buf->last_used = c->specbuf_used_counter++;
+		buf->shininess_i = shininess_i;
+		calc_buf(buf, shininess);
+		return buf;
+	}
+	/* overwrite the lru buffer */
+	/*tgl_trace("overwriting spec buffer :(\n");*/
+	oldest->shininess_i = shininess_i;
+	oldest->last_used = c->specbuf_used_counter++;
+	calc_buf(oldest, shininess);
+	return oldest;
+}
+
+#endif
diff --git a/src/other/tinygl/src/texture.c b/src/other/tinygl/src/texture.c
new file mode 100644
index 0000000000..ed5351729f
--- /dev/null
+++ b/src/other/tinygl/src/texture.c
@@ -0,0 +1,432 @@
+/*
+ * Texture Manager
+ */
+
+#include "zgl.h"
+
+static GLTexture* find_texture(GLint h) {
+	GLTexture* t;
+	GLContext* c = gl_get_context();
+	t = c->shared_state.texture_hash_table[h & TEXTURE_HASH_TABLE_MASK];
+	while (t != NULL) {
+		if (t->handle == h)
+			return t;
+		t = t->next;
+	}
+	return NULL;
+}
+
+GLboolean glAreTexturesResident(GLsizei n, const GLuint* textures, GLboolean* residences) {
+#define RETVAL GL_FALSE
+	GLboolean retval = GL_TRUE;
+	GLint i;
+#include "error_check_no_context.h"
+
+	for (i = 0; i < n; i++)
+		if (find_texture(textures[i])) {
+			residences[i] = GL_TRUE;
+		} else {
+			residences[i] = GL_FALSE;
+			retval = GL_FALSE;
+		}
+	return retval;
+}
+GLboolean glIsTexture(GLuint texture) {
+#define RETVAL GL_FALSE
+#include "error_check.h"
+	if (find_texture(texture))
+		return GL_TRUE;
+	return GL_FALSE;
+}
+
+void* glGetTexturePixmap(GLint text, GLint level, GLint* xsize, GLint* ysize) {
+	GLTexture* tex;
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(text >= 0 && level < MAX_TEXTURE_LEVELS))
+#define ERROR_FLAG GL_INVALID_ENUM
+#define RETVAL NULL
+#include "error_check.h"
+#else
+	/*assert(text >= 0 && level < MAX_TEXTURE_LEVELS);*/
+#endif
+		tex = find_texture(text);
+	if (!tex)
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_ENUM
+#define RETVAL NULL
+#include "error_check.h"
+#else
+		return NULL;
+#endif
+		*xsize = tex->images[level].xsize;
+	*ysize = tex->images[level].ysize;
+	return tex->images[level].pixmap;
+}
+
+static void free_texture(GLContext* c, GLint h) {
+	GLTexture *t, **ht;
+
+	t = find_texture(h);
+	if (t->prev == NULL) {
+		ht = &c->shared_state.texture_hash_table[t->handle & TEXTURE_HASH_TABLE_MASK];
+		*ht = t->next;
+	} else {
+		t->prev->next = t->next;
+	}
+	if (t->next != NULL)
+		t->next->prev = t->prev;
+
+	gl_free(t);
+}
+
+GLTexture* alloc_texture(GLint h) {
+	GLContext* c = gl_get_context();
+	GLTexture *t, **ht;
+#define RETVAL NULL
+#include "error_check.h"
+	t = gl_zalloc(sizeof(GLTexture));
+	if (!t)
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#define RETVAL NULL
+#include "error_check.h"
+#else
+		gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+
+		ht = &c->shared_state.texture_hash_table[h & TEXTURE_HASH_TABLE_MASK];
+
+	if (t) {
+	   if (ht)
+	      t->next = *ht;
+	   t->prev = NULL;
+	   if (t->next != NULL)
+	      t->next->prev = t;
+	   if (ht)
+	      *ht = t;
+	   t->handle = h;
+	}
+
+	return t;
+}
+
+void glInitTextures() {
+	/* textures */
+	GLContext* c = gl_get_context();
+	c->texture_2d_enabled = 0;
+	c->current_texture = find_texture(0);
+}
+
+void glGenTextures(GLint n, GLuint* textures) {
+	GLContext* c = gl_get_context();
+	GLint max, i;
+	GLTexture* t;
+#include "error_check.h"
+	max = 0;
+	for (i = 0; i < TEXTURE_HASH_TABLE_SIZE; i++) {
+		t = c->shared_state.texture_hash_table[i];
+		while (t != NULL) {
+			if (t->handle > max)
+				max = t->handle;
+			t = t->next;
+		}
+	}
+	for (i = 0; i < n; i++) {
+		textures[i] = max + i + 1; /* MARK: How texture handles are created.*/
+	}
+}
+
+void glDeleteTextures(GLint n, const GLuint* textures) {
+	GLint i;
+	GLTexture* t;
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	for (i = 0; i < n; i++) {
+		t = find_texture(textures[i]);
+		if (t != NULL && t != 0) {
+			if (t == c->current_texture) {
+				glBindTexture(GL_TEXTURE_2D, 0);
+#include "error_check.h"
+			}
+			free_texture(c, textures[i]);
+		}
+	}
+}
+
+void glopBindTexture(GLParam* p) {
+	GLint texture = p[2].i;
+	GLTexture* t;
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!(target == GL_TEXTURE_2D && target > 0))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+	
+#endif
+		t = find_texture(texture);
+	if (t == NULL) {
+		t = alloc_texture(texture);
+#include "error_check.h"
+	}
+	if (t == NULL) { 
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+		gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+	}
+	c->current_texture = t;
+}
+
+
+void glCopyTexImage2D(GLenum target,		 
+					  GLint level,			 
+					  GLenum internalformat, 
+					  GLint x,				 
+					  GLint y,				 
+					  GLsizei width,		 
+					  GLsizei height, GLint border) {
+	GLParam p[9];
+#include "error_check_no_context.h"
+
+	p[0].op = OP_CopyTexImage2D;
+	p[1].i = target;
+	p[2].i = level;
+	p[3].i = internalformat;
+	p[4].i = x;
+	p[5].i = y;
+	p[6].i = width;
+	p[7].i = height;
+	p[8].i = border;
+	gl_add_op(p);
+}
+void glopCopyTexImage2D(GLParam* p) {
+	GLImage* im;
+	PIXEL* data;
+	GLint i, j;
+	GLint target = p[1].i;
+	GLint level = p[2].i;
+	GLint x = p[4].i;
+	GLint y = p[5].i;
+	GLsizei w = p[6].i;
+	GLsizei h = p[7].i;
+	GLint border = p[8].i;
+	GLContext* c = gl_get_context();
+	y -= h;
+
+	if (c->readbuffer != GL_FRONT || c->current_texture == NULL || target != GL_TEXTURE_2D || border != 0 ||
+		w != TGL_FEATURE_TEXTURE_DIM || /*TODO Implement image interp*/
+		h != TGL_FEATURE_TEXTURE_DIM) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+		return;
+#endif
+	}
+	im = &c->current_texture->images[level];
+	data = c->current_texture->images[level].pixmap;
+	im->xsize = TGL_FEATURE_TEXTURE_DIM;
+	im->ysize = TGL_FEATURE_TEXTURE_DIM;
+	/* TODO implement the scaling and stuff that the GL spec says it should have.*/
+#if TGL_FEATURE_MULTITHREADED_COPY_TEXIMAGE_2D == 1
+#  ifdef _OPENMP
+#    pragma omp parallel for
+#  endif
+	for (j = 0; j < h; j++)
+		for (i = 0; i < w; i++) {
+			data[i + j * w] = c->zb->pbuf[((i + x) % (c->zb->xsize)) + ((j + y) % (c->zb->ysize)) * (c->zb->xsize)];
+		}
+#else
+	for (j = 0; j < h; j++)
+		for (i = 0; i < w; i++) {
+			data[i + j * w] = c->zb->pbuf[((i + x) % (c->zb->xsize)) + ((j + y) % (c->zb->ysize)) * (c->zb->xsize)];
+		}
+#endif
+}
+
+void glopTexImage1D(GLParam* p) {
+	GLint target = p[1].i;
+	GLint level = p[2].i;
+	GLint components = p[3].i;
+	GLint width = p[4].i;
+	/* GLint height = p[5].i;*/
+	GLint height = 1;
+	GLint border = p[5].i;
+	GLint format = p[6].i;
+	GLint type = p[7].i;
+	void* pixels = p[8].p;
+	GLImage* im;
+	GLubyte* pixels1;
+	GLint do_free=0;
+	GLContext* c = gl_get_context();
+	{
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (!(c->current_texture != NULL && target == GL_TEXTURE_1D && level == 0 && components == 3 && border == 0 && format == GL_RGB &&
+			  type == GL_UNSIGNED_BYTE))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+
+#else
+		if (!(c->current_texture != NULL && target == GL_TEXTURE_1D && level == 0 && components == 3 && border == 0 && format == GL_RGB &&
+			  type == GL_UNSIGNED_BYTE))
+			gl_fatal_error("glTexImage2D: combination of parameters not handled!!");
+#endif
+	}
+	if (width != TGL_FEATURE_TEXTURE_DIM || height != TGL_FEATURE_TEXTURE_DIM) {
+		pixels1 = gl_malloc(TGL_FEATURE_TEXTURE_DIM * TGL_FEATURE_TEXTURE_DIM * 3); /* GUARDED*/
+		if (pixels1 == NULL) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+			gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+		}
+		/* no GLinterpolation is done here to respect the original image aliasing ! */
+		
+		gl_resizeImageNoInterpolate(pixels1, TGL_FEATURE_TEXTURE_DIM, TGL_FEATURE_TEXTURE_DIM, pixels, width, height);
+		do_free = 1;
+		width = TGL_FEATURE_TEXTURE_DIM;
+		height = TGL_FEATURE_TEXTURE_DIM; 
+	} else {
+		pixels1 = pixels;
+	}
+
+	im = &c->current_texture->images[level];
+	im->xsize = width;
+	im->ysize = height;
+#if TGL_FEATURE_RENDER_BITS == 32
+	gl_convertRGB_to_8A8R8G8B(im->pixmap, pixels1, width, height);
+#elif TGL_FEATURE_RENDER_BITS == 16
+	gl_convertRGB_to_5R6G5B(im->pixmap, pixels1, width, height);
+#else
+#error bad TGL_FEATURE_RENDER_BITS
+#endif
+	if (do_free)
+		gl_free(pixels1);
+}
+void glopTexImage2D(GLParam* p) {
+	GLint target = p[1].i;
+	GLint level = p[2].i;
+	GLint components = p[3].i;
+	GLint width = p[4].i;
+	GLint height = p[5].i;
+	GLint border = p[6].i;
+	GLint format = p[7].i;
+	GLint type = p[8].i;
+	void* pixels = p[9].p;
+	GLImage* im;
+	GLubyte* pixels1;
+	GLint do_free=0;
+	GLContext* c = gl_get_context();
+	{
+#if TGL_FEATURE_ERROR_CHECK == 1
+		if (!(c->current_texture != NULL && target == GL_TEXTURE_2D && level == 0 && components == 3 && border == 0 && format == GL_RGB &&
+			  type == GL_UNSIGNED_BYTE))
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+
+#else
+		if (!(c->current_texture != NULL && target == GL_TEXTURE_2D && level == 0 && components == 3 && border == 0 && format == GL_RGB &&
+			  type == GL_UNSIGNED_BYTE))
+			gl_fatal_error("glTexImage2D: combination of parameters not handled!!");
+#endif
+	}
+	if (width != TGL_FEATURE_TEXTURE_DIM || height != TGL_FEATURE_TEXTURE_DIM) {
+		pixels1 = gl_malloc(TGL_FEATURE_TEXTURE_DIM * TGL_FEATURE_TEXTURE_DIM * 3); /* GUARDED*/
+		if (pixels1 == NULL) {
+#if TGL_FEATURE_ERROR_CHECK == 1
+#define ERROR_FLAG GL_OUT_OF_MEMORY
+#include "error_check.h"
+#else
+			gl_fatal_error("GL_OUT_OF_MEMORY");
+#endif
+		}
+		/* no GLinterpolation is done here to respect the original image aliasing ! */
+		
+		gl_resizeImageNoInterpolate(pixels1, TGL_FEATURE_TEXTURE_DIM, TGL_FEATURE_TEXTURE_DIM, pixels, width, height);
+		do_free = 1;
+		width = TGL_FEATURE_TEXTURE_DIM;
+		height = TGL_FEATURE_TEXTURE_DIM;
+	} else {
+		pixels1 = pixels;
+	}
+
+	im = &c->current_texture->images[level];
+	im->xsize = width;
+	im->ysize = height;
+#if TGL_FEATURE_RENDER_BITS == 32
+	gl_convertRGB_to_8A8R8G8B(im->pixmap, pixels1, width, height);
+#elif TGL_FEATURE_RENDER_BITS == 16
+	gl_convertRGB_to_5R6G5B(im->pixmap, pixels1, width, height);
+#else
+#error Bad TGL_FEATURE_RENDER_BITS
+#endif
+	if (do_free)
+		gl_free(pixels1);
+}
+
+/* TODO: not all tests are done */
+/*
+void glopTexEnv(GLContext* c, GLParam* p) {
+	GLint target = p[1].i;
+	GLint pname = p[2].i;
+	GLint param = p[3].i;
+
+	if (target != GL_TEXTURE_ENV) {
+
+	error:
+#if TGL_FEATURE_ERROR_CHECK == 1
+
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#else
+		gl_fatal_error("glTexParameter: unsupported option");
+#endif
+
+	}
+
+	if (pname != GL_TEXTURE_ENV_MODE)
+		goto error;
+
+	if (param != GL_DECAL)
+		goto error;
+}
+*/
+/* TODO: not all tests are done */
+/*
+void glopTexParameter(GLContext* c, GLParam* p) {
+	GLint target = p[1].i;
+	GLint pname = p[2].i;
+	GLint param = p[3].i;
+
+	if (target != GL_TEXTURE_2D &&
+		target != GL_TEXTURE_1D) {
+	error:
+		tgl_warning("glTexParameter: unsupported option");
+		return;
+	}
+
+	switch (pname) {
+	case GL_TEXTURE_WRAP_S:
+	case GL_TEXTURE_WRAP_T:
+		if (param != GL_REPEAT)
+			goto error;
+		break;
+	}
+}
+*/
+
+/*
+void glopPixelStore(GLContext* c, GLParam* p) {
+	GLint pname = p[1].i;
+	GLint param = p[2].i;
+
+	if (pname != GL_UNPACK_ALIGNMENT || param != 1) {
+		gl_fatal_error("glPixelStore: unsupported option");
+	}
+}
+*/
diff --git a/src/other/tinygl/src/vertex.c b/src/other/tinygl/src/vertex.c
new file mode 100644
index 0000000000..a839002cee
--- /dev/null
+++ b/src/other/tinygl/src/vertex.c
@@ -0,0 +1,406 @@
+#include "zgl.h"
+#include <string.h>
+void glopNormal(GLParam* p) {
+	V3 v;
+	GLContext* c = gl_get_context();
+	v.X = p[1].f;
+	v.Y = p[2].f;
+	v.Z = p[3].f;
+
+	c->current_normal.X = v.X;
+	c->current_normal.Y = v.Y;
+	c->current_normal.Z = v.Z;
+	c->current_normal.W = 0;
+}
+
+void glopTexCoord(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->current_tex_coord.X = p[1].f;
+	c->current_tex_coord.Y = p[2].f;
+	c->current_tex_coord.Z = p[3].f;
+	c->current_tex_coord.W = p[4].f;
+}
+
+void glopEdgeFlag(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->current_edge_flag = p[1].i;
+}
+
+void glopColor(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->current_color.X = p[1].f;
+	c->current_color.Y = p[2].f;
+	c->current_color.Z = p[3].f;
+	c->current_color.W = p[4].f;
+
+	if (c->color_material_enabled) {
+		GLParam q[7];
+		q[0].op = OP_Material;
+		q[1].i = c->current_color_material_mode;
+		q[2].i = c->current_color_material_type;
+		q[3].f = p[1].f;
+		q[4].f = p[2].f;
+		q[5].f = p[3].f;
+		q[6].f = p[4].f;
+		glopMaterial(q);
+	}
+}
+
+void glopBegin(GLParam* p) {
+	GLint type;
+	M4 tmp;
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->in_begin != 0)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	
+#endif
+		type = p[1].i;
+	c->begin_type = type;
+	c->in_begin = 1;
+	c->vertex_n = 0;
+	c->vertex_cnt = 0;
+
+	if (c->matrix_model_projection_updated) {
+
+		if (c->lighting_enabled) {
+			/* precompute inverse modelview */
+			gl_M4_Inv(&tmp, c->matrix_stack_ptr[0]);
+			gl_M4_Transpose(&c->matrix_model_view_inv, &tmp);
+		} else {
+			GLfloat* m = &c->matrix_model_projection.m[0][0];
+			/* precompute projection matrix */
+			gl_M4_Mul(&c->matrix_model_projection, c->matrix_stack_ptr[1], c->matrix_stack_ptr[0]);
+			/* test to accelerate computation */
+			c->matrix_model_projection_no_w_transform = 0;
+			if (m[12] == 0.0 && m[13] == 0.0 && m[14] == 0.0)
+				/*
+				 if(c->matrix_model_projection.m[3][0] == 0.0 &&
+					c->matrix_model_projection.m[3][1] == 0.0 &&
+					c->matrix_model_projection.m[3][2] == 0.0)
+				*/
+				c->matrix_model_projection_no_w_transform = 1;
+		}
+
+		/* test if the texture matrix is not Identity */
+		c->apply_texture_matrix = !gl_M4_IsId(c->matrix_stack_ptr[2]);
+
+		c->matrix_model_projection_updated = 0;
+	}
+	/*  viewport- this is now updated on a glViewport call. 
+	if (c->viewport.updated) {
+		gl_eval_viewport(c);
+		c->viewport.updated = 0;
+	}
+	 triangle drawing functions 
+	*/
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	if (c->render_mode == GL_SELECT) {
+		c->draw_triangle_front = gl_draw_triangle_select;
+		c->draw_triangle_back = gl_draw_triangle_select;
+	} else if (c->render_mode == GL_FEEDBACK) {
+		c->draw_triangle_front = gl_draw_triangle_feedback;
+		c->draw_triangle_back = gl_draw_triangle_feedback;
+	} else
+#endif
+	{
+		switch (c->polygon_mode_front) {
+		case GL_POINT:
+			c->draw_triangle_front = gl_draw_triangle_point;
+			break;
+		case GL_LINE:
+			c->draw_triangle_front = gl_draw_triangle_line;
+			break;
+		default:
+			c->draw_triangle_front = gl_draw_triangle_fill;
+			break;
+		}
+
+		switch (c->polygon_mode_back) {
+		case GL_POINT:
+			c->draw_triangle_back = gl_draw_triangle_point;
+			break;
+		case GL_LINE:
+			c->draw_triangle_back = gl_draw_triangle_line;
+			break;
+		default:
+			c->draw_triangle_back = gl_draw_triangle_fill;
+			break;
+		}
+	}
+}
+
+static void gl_transform_to_viewport_vertex_c(GLVertex* v) {
+	GLContext* c = gl_get_context();
+	{
+		GLfloat winv = 1.0 / v->pc.W;
+		v->zp.x = (GLint)(v->pc.X * winv * c->viewport.scale.X + c->viewport.trans.X);
+		v->zp.y = (GLint)(v->pc.Y * winv * c->viewport.scale.Y + c->viewport.trans.Y);
+		v->zp.z = (GLint)(v->pc.Z * winv * c->viewport.scale.Z + c->viewport.trans.Z);
+	}
+
+	v->zp.r = (GLint)(v->color.v[0] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+	v->zp.g = (GLint)(v->color.v[1] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+	v->zp.b = (GLint)(v->color.v[2] * COLOR_CORRECTED_MULT_MASK + COLOR_MIN_MULT) & COLOR_MASK;
+
+	if (c->texture_2d_enabled) {
+		v->zp.s = (GLint)(v->tex_coord.X * (ZB_POINT_S_MAX - ZB_POINT_S_MIN) + ZB_POINT_S_MIN); 
+		v->zp.t = (GLint)(v->tex_coord.Y * (ZB_POINT_T_MAX - ZB_POINT_T_MIN) + ZB_POINT_T_MIN); 
+	}
+}
+
+int gl_V3_Norm_Fast(V3* a) {
+	GLfloat n;
+#if TGL_FEATURE_FISR == 1
+	n = fastInvSqrt(a->X * a->X + a->Y * a->Y + a->Z * a->Z); 
+	if (n > 1E+3)
+		return 1;
+#else
+	n = sqrt(a->X * a->X + a->Y * a->Y + a->Z * a->Z); 
+	if (n == 0)
+		return 1;
+	n = 1.0 / n;
+#endif
+	a->X *= n;
+	a->Y *= n;
+	a->Z *= n;
+	return 0;
+}
+
+static void gl_vertex_transform(GLVertex* v) {
+	GLfloat* m;
+	GLContext* c = gl_get_context();
+
+	if (c->lighting_enabled)
+
+	{
+		/* eye coordinates needed for lighting */
+		V4* n;
+		m = &c->matrix_stack_ptr[0]->m[0][0];
+		v->ec.X = (v->coord.X * m[0] + v->coord.Y * m[1] + v->coord.Z * m[2] + m[3]);
+		v->ec.Y = (v->coord.X * m[4] + v->coord.Y * m[5] + v->coord.Z * m[6] + m[7]);
+		v->ec.Z = (v->coord.X * m[8] + v->coord.Y * m[9] + v->coord.Z * m[10] + m[11]);
+		v->ec.W = (v->coord.X * m[12] + v->coord.Y * m[13] + v->coord.Z * m[14] + m[15]);
+
+		/* projection coordinates */
+		m = &c->matrix_stack_ptr[1]->m[0][0];
+		v->pc.X = (v->ec.X * m[0] + v->ec.Y * m[1] + v->ec.Z * m[2] + v->ec.W * m[3]);
+		v->pc.Y = (v->ec.X * m[4] + v->ec.Y * m[5] + v->ec.Z * m[6] + v->ec.W * m[7]);
+		v->pc.Z = (v->ec.X * m[8] + v->ec.Y * m[9] + v->ec.Z * m[10] + v->ec.W * m[11]);
+		v->pc.W = (v->ec.X * m[12] + v->ec.Y * m[13] + v->ec.Z * m[14] + v->ec.W * m[15]);
+
+		m = &c->matrix_model_view_inv.m[0][0];
+		n = &c->current_normal;
+
+		v->normal.X = (n->X * m[0] + n->Y * m[1] + n->Z * m[2]);
+		v->normal.Y = (n->X * m[4] + n->Y * m[5] + n->Z * m[6]);
+		v->normal.Z = (n->X * m[8] + n->Y * m[9] + n->Z * m[10]);
+
+		if (c->normalize_enabled) {
+			gl_V3_Norm_Fast(&v->normal);
+		}
+	}
+
+	else {
+		/* no eye coordinates needed, no normal */
+		/* NOTE: W = 1 is assumed */
+		m = &c->matrix_model_projection.m[0][0];
+
+		v->pc.X = (v->coord.X * m[0] + v->coord.Y * m[1] + v->coord.Z * m[2] + m[3]);
+		v->pc.Y = (v->coord.X * m[4] + v->coord.Y * m[5] + v->coord.Z * m[6] + m[7]);
+		v->pc.Z = (v->coord.X * m[8] + v->coord.Y * m[9] + v->coord.Z * m[10] + m[11]);
+		if (c->matrix_model_projection_no_w_transform) {
+			v->pc.W = m[15];
+		} else {
+			v->pc.W = (v->coord.X * m[12] + v->coord.Y * m[13] + v->coord.Z * m[14] + m[15]);
+		}
+	}
+
+	v->clip_code = gl_clipcode(v->pc.X, v->pc.Y, v->pc.Z, v->pc.W);
+}
+
+void glopVertex(GLParam* p) {
+	GLVertex* v;
+	GLint n, i, cnt;
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->in_begin == 0)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	
+#endif
+
+		n = c->vertex_n;
+	cnt = c->vertex_cnt;
+	cnt++;
+	c->vertex_cnt = cnt;
+
+	/* new vertex entry */
+	v = &c->vertex[n];
+	n++;
+
+	v->coord.X = p[1].f;
+	v->coord.Y = p[2].f;
+	v->coord.Z = p[3].f;
+	v->coord.W = p[4].f;
+
+	gl_vertex_transform(v);
+
+	/* color */
+
+	if (c->lighting_enabled) {
+		gl_shade_vertex(v);
+#include "error_check.h"
+		
+	} else {
+		v->color = c->current_color;
+	}
+	/* tex coords */
+#if TGL_OPTIMIZATION_HINT_BRANCH_COST < 1
+	if (c->texture_2d_enabled)
+#endif
+	{
+		if (c->apply_texture_matrix) {
+			gl_M4_MulV4(&v->tex_coord, c->matrix_stack_ptr[2], &c->current_tex_coord);
+		} else {
+			v->tex_coord = c->current_tex_coord;
+		}
+	}
+	/* precompute the mapping to the viewport */
+#if TGL_OPTIMIZATION_HINT_BRANCH_COST < 2
+	if (v->clip_code == 0)
+#endif
+	{
+		gl_transform_to_viewport_vertex_c(v);
+	}
+
+	/* edge flag */
+	v->edge_flag = c->current_edge_flag;
+
+	switch (c->begin_type) {
+	case GL_POINTS:
+		gl_draw_point(&c->vertex[0]);
+		n = 0;
+		break;
+
+	case GL_LINES:
+		if (n == 2) {
+			gl_draw_line(&c->vertex[0], &c->vertex[1]);
+			n = 0;
+		}
+		break;
+	case GL_LINE_STRIP:
+#if TGL_FEATURE_GL_POLYGON == 1
+	case GL_LINE_LOOP:
+#endif
+		switch (n) {
+		case 1: {
+			c->vertex[2] = c->vertex[0];
+		} break;
+		case 2: {
+			gl_draw_line(&c->vertex[0], &c->vertex[1]);
+			c->vertex[0] = c->vertex[1];
+			n = 1;
+		} break;
+		default:
+			break;
+		};
+		break;
+	case GL_TRIANGLES:
+		if (n == 3) {
+			gl_draw_triangle(&c->vertex[0], &c->vertex[1], &c->vertex[2]);
+			n = 0;
+		}
+		break;
+	case GL_TRIANGLE_STRIP:
+		if (cnt >= 3) {
+			if (n == 3)
+				n = 0;
+			/* needed to respect triangle orientation */
+			switch (cnt & 1) {
+			case 0:
+				gl_draw_triangle(&c->vertex[2], &c->vertex[1], &c->vertex[0]);
+				break;
+			default:
+			case 1:
+				gl_draw_triangle(&c->vertex[0], &c->vertex[1], &c->vertex[2]);
+				break;
+			}
+		}
+		break;
+	case GL_TRIANGLE_FAN:
+		if (n == 3) {
+			gl_draw_triangle(&c->vertex[0], &c->vertex[1], &c->vertex[2]);
+			c->vertex[1] = c->vertex[2];
+			n = 2;
+		}
+		break;
+
+	case GL_QUADS:
+		if (n == 4) {
+			c->vertex[2].edge_flag = 0;
+			gl_draw_triangle(&c->vertex[0], &c->vertex[1], &c->vertex[2]);
+			c->vertex[2].edge_flag = 1;
+			c->vertex[0].edge_flag = 0;
+			gl_draw_triangle(&c->vertex[0], &c->vertex[2], &c->vertex[3]);
+			n = 0;
+		}
+		break;
+
+	case GL_QUAD_STRIP:
+		if (n == 4) {
+			gl_draw_triangle(&c->vertex[0], &c->vertex[1], &c->vertex[2]);
+			gl_draw_triangle(&c->vertex[1], &c->vertex[3], &c->vertex[2]);
+			for (i = 0; i < 2; i++)
+				c->vertex[i] = c->vertex[i + 2];
+			n = 2;
+		}
+		break;
+
+#if TGL_FEATURE_GL_POLYGON == 1
+	case GL_POLYGON:
+		break;
+#endif
+#if TGL_FEATURE_ERROR_CHECK == 1
+	default:
+		gl_fatal_error("glBegin: type %x not handled\n", c->begin_type);
+#else
+	default:
+		break;
+#endif
+	}
+
+	c->vertex_n = n;
+}
+
+void glopEnd(GLParam* param) {
+	GLContext* c = gl_get_context();
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (c->in_begin != 1)
+#define ERROR_FLAG GL_INVALID_OPERATION
+#include "error_check.h"
+#else
+	
+	/* Assume it went alright.*/
+#endif
+
+
+
+#if TGL_FEATURE_GL_POLYGON == 1
+		if (c->begin_type == GL_LINE_LOOP) {
+			if (c->vertex_cnt >= 3) {
+				gl_draw_line(&c->vertex[0], &c->vertex[2]);
+			}
+		} else if (c->begin_type == GL_POLYGON) {
+			GLint i = c->vertex_cnt;
+			while (i >= 3) {
+				i--;
+				gl_draw_triangle(&c->vertex[i], &c->vertex[0], &c->vertex[i - 1]);
+			}
+		}
+#endif
+	c->in_begin = 0;
+}
diff --git a/src/other/tinygl/src/zbuffer.c b/src/other/tinygl/src/zbuffer.c
new file mode 100644
index 0000000000..eb7e7a7445
--- /dev/null
+++ b/src/other/tinygl/src/zbuffer.c
@@ -0,0 +1,387 @@
+/*
+
+ * Z buffer: 16 bits Z / 16 bits color
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "../include/zbuffer.h"
+#include "msghandling.h"
+ZBuffer* ZB_open(GLint xsize, GLint ysize, GLint mode,
+
+				 void* frame_buffer) {
+	ZBuffer* zb;
+	GLint size;
+
+	zb = gl_malloc(sizeof(ZBuffer));
+	if (zb == NULL)
+		return NULL;
+
+	zb->xsize = xsize & ~3; 
+	zb->ysize = ysize;
+	
+	
+	zb->linesize = (xsize * PSZB);
+
+	switch (mode) {
+#if TGL_FEATURE_32_BITS == 1
+	case ZB_MODE_RGBA:
+		break;
+#endif
+#if TGL_FEATURE_16_BITS == 1
+	case ZB_MODE_5R6G5B:
+		break;
+#endif
+
+	default:
+		goto error;
+	}
+
+	size = zb->xsize * zb->ysize * sizeof(GLushort);
+
+	zb->zbuf = gl_malloc(size);
+	if (zb->zbuf == NULL)
+		goto error;
+
+	if (frame_buffer == NULL) {
+		zb->pbuf = gl_malloc(zb->ysize * zb->linesize);
+		if (zb->pbuf == NULL) {
+			gl_free(zb->zbuf);
+			goto error;
+		}
+		zb->frame_buffer_allocated = 1;
+	} else {
+		zb->frame_buffer_allocated = 0;
+		zb->pbuf = frame_buffer;
+	}
+
+	zb->current_texture = NULL;
+
+	return zb;
+error:
+	gl_free(zb);
+	return NULL;
+}
+
+void ZB_close(ZBuffer* zb) {
+
+	if (zb->frame_buffer_allocated)
+		gl_free(zb->pbuf);
+
+	gl_free(zb->zbuf);
+	gl_free(zb);
+}
+
+void ZB_resize(ZBuffer* zb, void* frame_buffer, GLint xsize, GLint ysize) {
+	GLint size;
+
+	/* xsize must be a multiple of 4 */
+	xsize = xsize & ~3;
+
+	zb->xsize = xsize;
+	zb->ysize = ysize;
+	zb->linesize = (xsize * PSZB);
+
+	size = zb->xsize * zb->ysize * sizeof(GLushort);
+
+	gl_free(zb->zbuf);
+	zb->zbuf = gl_malloc(size);
+	if (zb->zbuf == NULL)
+		exit(1);
+	if (zb->frame_buffer_allocated)
+		gl_free(zb->pbuf);
+
+	if (frame_buffer == NULL) {
+		zb->pbuf = gl_malloc(zb->ysize * zb->linesize);
+		if (!zb->pbuf)
+			exit(1);
+		zb->frame_buffer_allocated = 1;
+	} else {
+		zb->pbuf = frame_buffer;
+		zb->frame_buffer_allocated = 0;
+	}
+}
+
+#if TGL_FEATURE_32_BITS == 1
+ PIXEL pxReverse32(PIXEL x) {
+	return
+		((x & 0xFF000000) >> 24) | /*______AA*/
+		((x & 0x00FF0000) >> 8) |  /*____RR__*/
+		((x & 0x0000FF00) << 8) |  /*__GG____*/
+		((x & 0x000000FF) << 24);  /* BB______*/
+}
+#endif
+
+static void ZB_copyBuffer(ZBuffer* zb, void* buf, GLint linesize) {
+	GLint y;
+#if TGL_FEATURE_MULTITHREADED_ZB_COPYBUFFER == 1
+#pragma omp parallel for
+	for (y = 0; y < zb->ysize; y++) {
+		PIXEL* q;
+		GLubyte* p1;
+		q = zb->pbuf + y * zb->xsize;
+		p1 = (GLubyte*)buf + y * linesize;
+#if TGL_FEATURE_NO_COPY_COLOR == 1
+		for (i = 0; i < zb->xsize; i++) {
+			if ((*(q + i) & TGL_COLOR_MASK) != TGL_NO_COPY_COLOR)
+				*(((PIXEL*)p1) + i) = *(q + i);
+		}
+#else
+		memcpy(p1, q, linesize);
+#endif
+
+
+	}
+#else
+	for (y = 0; y < zb->ysize; y++) {
+		PIXEL* q;
+		GLubyte* p1;
+		q = zb->pbuf + y * zb->xsize;
+		p1 = (GLubyte*)buf + y * linesize;
+#if TGL_FEATURE_NO_COPY_COLOR == 1
+		for (i = 0; i < zb->xsize; i++) {
+			if ((*(q + i) & TGL_COLOR_MASK) != TGL_NO_COPY_COLOR)
+				*(((PIXEL*)p1) + i) = *(q + i);
+		}
+#else
+		memcpy(p1, q, linesize);
+#endif
+	}
+#endif
+}
+
+#if TGL_FEATURE_RENDER_BITS == 16
+
+/* 32 bpp copy */
+/*
+
+#ifdef TGL_FEATURE_32_BITS
+
+#define RGB16_TO_RGB32(p0,p1,v)\
+{\
+	GLuint g,b,gb;\
+	g = (v & 0x07E007E0) << 5;\
+	b = (v & 0x001F001F) << 3;\
+	gb = g | b;\
+	p0 = (gb & 0x0000FFFF) | ((v & 0x0000F800) << 8);\
+	p1 = (gb >> 16) | ((v & 0xF8000000) >> 8);\
+}
+
+
+static void ZB_copyFrameBufferRGB32(ZBuffer * zb,
+									void *buf,
+									GLint linesize)
+{
+	GLushort *q;
+	GLuint *p, *p1, v, w0, w1;
+	GLint y, n;
+
+	q = zb->pbuf;
+	p1 = (GLuint *) buf;
+	
+	for (y = 0; y < zb->ysize; y++) {
+	p = p1;
+	n = zb->xsize >> 2;
+	do {
+		v = *(GLuint *) q;
+		RGB16_TO_RGB32(w1, w0, v);
+		p[0] = w0;
+		p[1] = w1;
+		v = *(GLuint *) (q + 2);
+		RGB16_TO_RGB32(w1, w0, v);
+		p[2] = w0;
+		p[3] = 0;
+
+		q += 4;
+		p += 4;
+	} while (--n > 0);
+
+	p1 += linesize;
+	}
+}
+*/
+#endif
+
+/* 24 bit packed pixel handling */
+
+#ifdef TGL_FEATURE_24_BITS
+
+/* order: RGBR GBRG BRGB */
+
+/* XXX: packed pixel 24 bit support not tested */
+/* XXX: big endian case not optimised */
+/*
+#if BYTE_ORDER == BIG_ENDIAN
+
+#define RGB16_TO_RGB24(p0,p1,p2,v1,v2)\
+{\
+	GLuint r1,g1,b1,gb1,g2,b2,gb2;\
+	v1 = (v1 << 16) | (v1 >> 16);\
+	v2 = (v2 << 16) | (v2 >> 16);\
+	r1 = (v1 & 0xF800F800);\
+	g1 = (v1 & 0x07E007E0) << 5;\
+	b1 = (v1 & 0x001F001F) << 3;\
+	gb1 = g1 | b1;\
+	p0 = ((gb1 & 0x0000FFFF) << 8) | (r1 << 16) | (r1 >> 24);\
+	g2 = (v2 & 0x07E007E0) << 5;\
+	b2 = (v2 & 0x001F001F) << 3;\
+	gb2 = g2 | b2;\
+	p1 = (gb1 & 0xFFFF0000) | (v2 & 0xF800) | ((gb2 >> 8) & 0xff);\
+	p2 = (gb2 << 24) | ((v2 & 0xF8000000) >> 8) | (gb2 >> 16);\
+}
+
+#else
+
+#define RGB16_TO_RGB24(p0,p1,p2,v1,v2)\
+{\
+	GLuint r1,g1,b1,gb1,g2,b2,gb2;\
+	r1 = (v1 & 0xF800F800);\
+	g1 = (v1 & 0x07E007E0) << 5;\
+	b1 = (v1 & 0x001F001F) << 3;\
+	gb1 = g1 | b1;\
+	p0 = ((gb1 & 0x0000FFFF) << 8) | (r1 << 16) | (r1 >> 24);\
+	g2 = (v2 & 0x07E007E0) << 5;\
+	b2 = (v2 & 0x001F001F) << 3;\
+	gb2 = g2 | b2;\
+	p1 = (gb1 & 0xFFFF0000) | (v2 & 0xF800) | ((gb2 >> 8) & 0xff);\
+	p2 = (gb2 << 24) | ((v2 & 0xF8000000) >> 8) | (gb2 >> 16);\
+}
+
+#endif
+*/
+/*
+static void ZB_copyFrameBufferRGB24(ZBuffer * zb,
+									void *buf,
+									GLint linesize)
+{
+	GLushort *q;
+	GLuint *p, *p1, w0, w1, w2, v0, v1;
+	GLint y, n;
+
+	q = zb->pbuf;
+	p1 = (GLuint *) buf;
+	linesize = linesize * 3;
+
+	for (y = 0; y < zb->ysize; y++) {
+	p = p1;
+	n = zb->xsize >> 2;
+	do {
+		v0 = *(GLuint *) q;
+		v1 = *(GLuint *) (q + 2);
+		RGB16_TO_RGB24(w0, w1, w2, v0, v1);
+		p[0] = w0;
+		p[1] = w1;
+		p[2] = w2;
+
+		q += 4;
+		p += 3;
+	} while (--n > 0);
+
+	*((GLbyte *) p1) += linesize;
+	}
+}
+*/
+#endif
+
+#if TGL_FEATURE_RENDER_BITS == 16
+
+void ZB_copyFrameBuffer(ZBuffer* zb, void* buf, GLint linesize) {
+
+	ZB_copyBuffer(zb, buf, linesize);
+}
+
+#endif 
+/*^ TGL_FEATURE_RENDER_BITS == 16 */
+
+
+#if TGL_FEATURE_RENDER_BITS == 32
+
+#define RGB32_TO_RGB16(v) (((v >> 8) & 0xf800) | (((v) >> 5) & 0x07e0) | (((v)&0xff) >> 3))
+
+
+void ZB_copyFrameBuffer(ZBuffer* zb, void* buf, GLint linesize) {
+	ZB_copyBuffer(zb, buf, linesize);
+}
+
+#endif 
+/* ^TGL_FEATURE_RENDER_BITS == 32 */
+
+/*
+ * adr must be aligned on an 'int'
+ */
+static void memset_s(void* adr, GLint val, GLint count) {
+	GLint i, n, v;
+	GLuint* p;
+	GLushort* q;
+
+	p = adr;
+	v = val | (val << 16);
+
+	n = count >> 3;
+	for (i = 0; i < n; i++) {
+		p[0] = v;
+		p[1] = v;
+		p[2] = v;
+		p[3] = v;
+		p += 4;
+	}
+
+	q = (GLushort*)p;
+	n = count & 7;
+	for (i = 0; i < n; i++)
+		*q++ = val;
+}
+
+/* Used in 32 bit mode*/
+static void memset_l(void* adr, GLint val, GLint count) {
+	GLint i, n, v;
+	GLuint* p;
+	p = adr;
+	v = val;
+	n = count >> 2;
+	for (i = 0; i < n; i++) {
+		p[0] = v;
+		p[1] = v;
+		p[2] = v;
+		p[3] = v;
+		p += 4;
+	}
+	n = count & 3;
+	for (i = 0; i < n; i++)
+		*p++ = val;
+}
+
+void ZB_clear(ZBuffer* zb, GLint clear_z, GLint z, GLint clear_color, GLint r, GLint g, GLint b) {
+	GLuint color;
+	GLint y;
+	PIXEL* pp;
+	if (clear_z) {
+		memset_s(zb->zbuf, z, zb->xsize * zb->ysize);
+	}
+	if (clear_color) {
+		pp = zb->pbuf;
+		for (y = 0; y < zb->ysize; y++) {
+#if TGL_FEATURE_RENDER_BITS == 15 || TGL_FEATURE_RENDER_BITS == 16
+			// color = RGB_TO_PIXEL(r, g, b);
+#if TGL_FEATURE_FORCE_CLEAR_NO_COPY_COLOR
+			color = TGL_NO_COPY_COLOR;
+#else
+			color = RGB_TO_PIXEL(r, g, b);
+#endif
+			memset_s(pp, color, zb->xsize);
+#elif TGL_FEATURE_RENDER_BITS == 32
+#if TGL_FEATURE_FORCE_CLEAR_NO_COPY_COLOR
+			color = TGL_NO_COPY_COLOR;
+#else
+			color = RGB_TO_PIXEL(r, g, b);
+#endif
+			memset_l(pp, color, zb->xsize);
+#else
+#error BADJUJU
+#endif
+			pp = (PIXEL*)((GLbyte*)pp + zb->linesize);
+		}
+	}
+}
diff --git a/src/other/tinygl/src/zgl.h b/src/other/tinygl/src/zgl.h
new file mode 100644
index 0000000000..f88325ac0e
--- /dev/null
+++ b/src/other/tinygl/src/zgl.h
@@ -0,0 +1,425 @@
+#ifndef _tgl_zgl_h_
+#define _tgl_zgl_h_
+#ifndef NDEBUG
+#define NDEBUG
+#endif
+#include "../include/TGL/gl.h"
+#include "../include/zbuffer.h"
+#include "../include/zfeatures.h"
+#include "zmath.h"
+#include <math.h>
+#include <stdlib.h>
+
+#include <string.h>
+#ifndef M_PI
+#define M_PI 3.1415926535897932384626433832795
+#endif
+
+
+enum {
+
+#define ADD_OP(a, b, c) OP_##a,
+
+#include "opinfo.h"
+
+};
+
+
+#if TGL_FEATURE_GL_POLYGON == 1
+
+#define POLYGON_MAX_VERTEX 16
+#else
+
+#define POLYGON_MAX_VERTEX 4
+#endif
+/* Max # of specular light pow buffers */
+#define MAX_SPECULAR_BUFFERS 32
+
+/* # of entries in specular buffer */
+#define SPECULAR_BUFFER_SIZE 512
+/* specular buffer granularity */
+
+
+#define MAX_MODELVIEW_STACK_DEPTH 32
+#define MAX_PROJECTION_STACK_DEPTH 8
+#define MAX_TEXTURE_STACK_DEPTH 8
+#define MAX_NAME_STACK_DEPTH 16
+#define MAX_TEXTURE_LEVELS 1
+#define MAX_LIGHTS 16
+
+#define VERTEX_ARRAY 0x0001
+#define COLOR_ARRAY 0x0002
+#define NORMAL_ARRAY 0x0004
+#define TEXCOORD_ARRAY 0x0008
+
+#define MAX_DISPLAY_LISTS 16384
+#define OP_BUFFER_MAX_SIZE 4096
+
+#define TGL_OFFSET_FILL 0x1
+#define TGL_OFFSET_LINE 0x2
+#define TGL_OFFSET_POINT 0x4
+
+typedef struct GLSpecBuf {
+	GLint shininess_i;
+	GLint last_used;
+	GLfloat buf[SPECULAR_BUFFER_SIZE + 1];
+	struct GLSpecBuf* next;
+} GLSpecBuf;
+
+typedef struct GLLight {
+	V4 ambient;
+	V4 diffuse;
+	V4 specular;
+	V4 position;
+	V3 spot_direction;
+	V3 norm_spot_direction;
+	V3 norm_position;
+	GLfloat spot_exponent;
+	GLfloat spot_cutoff;
+	GLfloat attenuation[3];
+	/* precomputed values */
+	GLfloat cos_spot_cutoff;
+
+	/* we use a linked list to know which are the enabled lights */
+	
+	struct GLLight *next, *prev;
+	GLubyte enabled;
+} GLLight;
+
+typedef struct GLMaterial {
+	V4 emission;
+	V4 ambient;
+	V4 diffuse;
+	V4 specular;
+	GLfloat shininess;
+
+	/* computed values */
+	GLint shininess_i;
+	GLint do_specular;
+} GLMaterial;
+
+typedef struct GLViewport {
+	V3 scale;
+	V3 trans;
+	GLint xmin, ymin, xsize, ysize;
+	
+} GLViewport;
+
+typedef union {
+	GLint op;
+	GLfloat f;
+	GLint i;
+	GLuint ui;
+	void* p;
+} GLParam;
+
+typedef struct GLParamBuffer {
+	GLParam ops[OP_BUFFER_MAX_SIZE];
+	struct GLParamBuffer* next;
+} GLParamBuffer;
+
+typedef struct GLList {
+	GLParamBuffer* first_op_buffer;
+	/* TODO: extensions for an hash table or a better allocating scheme */
+} GLList;
+
+typedef struct GLVertex {
+
+	V3 normal;
+	V4 coord;
+	V4 tex_coord;
+	V4 color;
+
+	/* computed values */
+	V4 ec;			 /* eye coordinates */
+	V4 pc;			 /* coordinates in the normalized volume */
+	ZBufferPoint zp; /* GLinteger coordinates for the rasterization */
+	GLint clip_code; /* clip code */
+	GLint edge_flag;
+} GLVertex;
+
+typedef struct GLImage {
+	PIXEL pixmap[TGL_FEATURE_TEXTURE_DIM * TGL_FEATURE_TEXTURE_DIM];
+	GLint xsize, ysize;
+} GLImage;
+
+/* textures */
+
+#define TEXTURE_HASH_TABLE_SIZE 256
+#define TEXTURE_HASH_TABLE_MASK 255
+typedef struct GLTexture {
+	GLImage images[MAX_TEXTURE_LEVELS];
+	struct GLTexture *next, *prev;
+	GLint handle;
+} GLTexture;
+
+/* buffers */
+#define MAX_BUFFERS 2048
+typedef struct GLBuffer {
+	void* data;
+	GLuint size;
+} GLBuffer;
+
+/* shared state */
+typedef struct GLSharedState {
+	GLList** lists;
+	GLTexture** texture_hash_table;
+	GLBuffer** buffers;
+} GLSharedState;
+
+struct GLContext;
+
+typedef void (*gl_draw_triangle_func)(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+
+/* display context */
+
+typedef struct GLContext {
+	/* lights */
+	GLLight lights[MAX_LIGHTS];
+	/* viewport */
+	GLViewport viewport;
+	GLMaterial materials[2];
+	GLVertex vertex[POLYGON_MAX_VERTEX];
+
+	M4 matrix_model_view_inv;
+	M4 matrix_model_projection;
+	V4 ambient_light_model;
+	V4 clear_color;
+	V4 current_color;
+	V4 current_normal;
+	V4 current_tex_coord;
+	V4 rasterpos;
+
+	/*Pointers.*/
+	/* shared state */
+	GLSharedState shared_state;
+	ZBuffer* zb;
+	GLLight* first_light;
+	GLTexture* current_texture;
+	GLParamBuffer* current_op_buffer;
+	M4* matrix_stack[3];
+	M4* matrix_stack_ptr[3];
+	gl_draw_triangle_func draw_triangle_front, draw_triangle_back;
+	/* resize viewport function */
+	GLint (*gl_resize_viewport)(GLint* xsize, GLint* ysize);
+	GLfloat* texcoord_array;
+	GLfloat* vertex_array;
+	GLfloat* normal_array;
+	GLfloat* color_array;
+
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLfloat* feedback_buffer;
+	GLuint* select_buffer;
+	GLuint *select_ptr, *select_hit;
+	GLfloat* feedback_ptr;
+#endif
+
+	GLint local_light_model;
+	GLint lighting_enabled;
+	GLint light_model_two_side;
+
+	/* materials */
+	GLint color_material_enabled;
+	GLint current_color_material_mode;
+	GLint current_color_material_type;
+
+	/* textures */
+
+	GLint texture_2d_enabled;
+
+	/* current list */
+
+	GLint current_op_buffer_index;
+	GLint exec_flag, compile_flag, print_flag;
+	GLuint listbase;
+	/* matrix */
+
+	GLint matrix_mode;
+
+	GLint matrix_stack_depth_max[3];
+
+	GLint matrix_model_projection_updated;
+	GLint matrix_model_projection_no_w_transform;
+	GLint apply_texture_matrix;
+
+	/* current state */
+	GLint polygon_mode_back;
+	GLint polygon_mode_front;
+
+	GLint current_front_face;
+	GLint current_shade_model;
+	GLint current_cull_face;
+	GLint cull_face_enabled;
+	GLint normalize_enabled;
+
+	/* selection */
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	GLint render_mode;
+
+	GLint select_size;
+
+	GLint select_overflow;
+	GLint select_hits;
+#endif
+	/* glDrawBuffer, glRenderBuffer */
+	GLenum drawbuffer;
+	GLenum readbuffer;
+	/* feedback */
+	
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+
+	GLuint feedback_size;
+	GLint feedback_hits;
+	GLubyte feedback_overflow;
+	GLenum feedback_type;
+	/* names */
+	GLuint name_stack[MAX_NAME_STACK_DEPTH];
+	GLint name_stack_size;
+#endif
+
+	/* clear */
+	GLfloat clear_depth;
+
+	GLint current_edge_flag;
+
+	/* glBegin / glEnd */
+	GLint in_begin;
+	GLint begin_type;
+	GLint vertex_n, vertex_cnt;
+
+	/* opengl 1.1 arrays  */
+
+	GLint vertex_array_size;
+	GLint vertex_array_stride;
+	GLint normal_array_stride;
+	GLint color_array_size;
+	GLint color_array_stride;
+
+	GLint texcoord_array_size;
+	GLint texcoord_array_stride;
+	GLint client_states;
+
+	/* opengl 1.1 polygon offset */
+	GLfloat offset_factor;
+	GLfloat offset_units;
+	GLint offset_states;
+
+	/* opengl blending */
+	
+
+	/* specular buffer. could probably be shared between contexts,
+	  but that wouldn't be 100% thread safe */
+#if TGL_FEATURE_SPECULAR_BUFFERS == 1
+	GLSpecBuf* specbuf_first;
+	GLint specbuf_used_counter;
+	GLint specbuf_num_buffers;
+#endif
+	GLint zEnableSpecular; 
+
+	/* raster position */
+	GLint rasterpos_zz;
+	GLfloat pzoomx, pzoomy;
+	GLVertex rastervertex;
+	/* text */
+	GLTEXTSIZE textsize;
+	/* buffers */
+	GLint boundarraybuffer;
+	GLint boundvertexbuffer;
+	GLint boundnormalbuffer;
+	GLint boundcolorbuffer;
+	GLint boundtexcoordbuffer;
+	GLubyte rasterposvalid;
+#if TGL_FEATURE_ERROR_CHECK == 1
+	GLenum error_flag;
+#endif
+} GLContext;
+
+extern GLContext gl_ctx;
+extern GLContext* gl_get_context(void);
+
+extern void (*op_table_func[])(GLParam*);
+extern GLint op_table_size[];
+extern void gl_compile_op(GLParam* p);
+extern void gl_add_op(GLParam* p);
+
+/* select.c */
+void gl_add_select(GLuint zmin, GLuint zmax);
+void gl_add_feedback(GLfloat token, GLVertex* v1, GLVertex* v2, GLVertex* v3, GLfloat passthrough_token_value);
+
+/* clip.c */
+
+#define CLIP_EPSILON (1E-5)
+
+extern GLint gl_clipcode(GLfloat x, GLfloat y, GLfloat z, GLfloat w1);
+
+#define CLIP_XMIN (1 << 0)
+#define CLIP_XMAX (1 << 1)
+#define CLIP_YMIN (1 << 2)
+#define CLIP_YMAX (1 << 3)
+#define CLIP_ZMIN (1 << 4)
+#define CLIP_ZMAX (1 << 5)
+
+extern GLfloat clampf(GLfloat a, GLfloat min, GLfloat max);
+
+/* triangle */
+
+/*
+ * Clipping
+ */
+
+/* We clip the segment [a,b] against the 6 planes of the normal volume.
+ * We compute the point 'c' of GLintersection and the value of the parameter 't'
+ * of the GLintersection if x=a+t(b-a).
+ */
+
+
+
+void gl_draw_triangle(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+void gl_draw_line(GLVertex* p0, GLVertex* p1);
+void gl_draw_point(GLVertex* p0);
+
+void gl_draw_triangle_point(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+void gl_draw_triangle_line(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+void gl_draw_triangle_fill(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+void gl_draw_triangle_select(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+void gl_draw_triangle_feedback(GLVertex* p0, GLVertex* p1, GLVertex* p2);
+/* matrix.c */
+void gl_print_matrix(const GLfloat* m);
+/*
+void glopLoadIdentity(GLParam *p);
+void glopTranslate(GLParam *p);*/
+
+/* light.c */
+void gl_enable_disable_light(GLint light, GLint v);
+void gl_shade_vertex(GLVertex* v);
+
+void glInitTextures();
+void glEndTextures();
+GLTexture* alloc_texture(GLint h);
+
+/* image_util.c */
+void gl_convertRGB_to_5R6G5B(GLushort* pixmap, GLubyte* rgb, GLint xsize, GLint ysize);
+void gl_convertRGB_to_8A8R8G8B(GLuint* pixmap, GLubyte* rgb, GLint xsize, GLint ysize);
+void gl_resizeImage(GLubyte* dest, GLint xsize_dest, GLint ysize_dest, GLubyte* src, GLint xsize_src, GLint ysize_src);
+void gl_resizeImageNoInterpolate(GLubyte* dest, GLint xsize_dest, GLint ysize_dest, GLubyte* src, GLint xsize_src, GLint ysize_src);
+
+
+
+void gl_fatal_error(char* format, ...);
+
+/* specular buffer "api" */
+GLSpecBuf* specbuf_get_buffer(const GLint shininess_i, const GLfloat shininess);
+
+
+
+/* glopXXX functions */
+
+#define ADD_OP(a, b, c) void glop##a(GLParam*);
+#include "opinfo.h"
+
+/* this clip epsilon is needed to avoid some rounding errors after
+   several clipping stages */
+
+extern void gl_eval_viewport();
+
+#endif /* _tgl_zgl_h_ */
diff --git a/src/other/tinygl/src/zline.c b/src/other/tinygl/src/zline.c
new file mode 100644
index 0000000000..fd0f2de650
--- /dev/null
+++ b/src/other/tinygl/src/zline.c
@@ -0,0 +1,126 @@
+#include "../include/zbuffer.h"
+#include <stdlib.h>
+
+#define ZCMP(z, zpix) (!(zbdt) || z >= (zpix))
+
+/* TODO: Implement point size. */
+/* TODO: Implement blending for lines and points. */
+
+void ZB_plot(ZBuffer* zb, ZBufferPoint* p) {
+
+	GLint zz, y, x;
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	GLfloat zbps = zb->pointsize;
+	TGL_BLEND_VARS
+	zz = p->z >> ZB_POINT_Z_FRAC_BITS;
+	
+	if (zbps == 1) {
+		GLushort* pz;
+		PIXEL* pp;
+		pz = zb->zbuf + (p->y * zb->xsize + p->x);
+		pp = (PIXEL*)((GLbyte*)zb->pbuf + zb->linesize * p->y + p->x * PSZB);
+
+		if (ZCMP(zz, *pz)) {
+#if TGL_FEATURE_BLEND == 1
+			if (!zb->enable_blend)
+				*pp = RGB_TO_PIXEL(p->r, p->g, p->b);
+			else
+				TGL_BLEND_FUNC_RGB(p->r, p->g, p->b, (*pp))
+#else
+			*pp = RGB_TO_PIXEL(p->r, p->g, p->b);
+#endif
+			if (zbdw)
+				*pz = zz;
+		}
+	} else {
+		PIXEL col = RGB_TO_PIXEL(p->r, p->g, p->b);
+		GLfloat hzbps = zbps / 2.0f;
+		GLint bx = (GLfloat)p->x - hzbps;
+		GLint ex = (GLfloat)p->x + hzbps;
+		GLint by = (GLfloat)p->y - hzbps;
+		GLint ey = (GLfloat)p->y + hzbps;
+		bx = (bx < 0) ? 0 : bx;
+		by = (by < 0) ? 0 : by;
+		ex = (ex > zb->xsize) ? zb->xsize : ex;
+		ey = (ey > zb->ysize) ? zb->ysize : ey;
+		for (y = by; y < ey; y++)
+			for (x = bx; x < ex; x++) {
+				GLushort* pz = zb->zbuf + (y * zb->xsize + x);
+				PIXEL* pp = (PIXEL*)((GLbyte*)zb->pbuf + zb->linesize * y + x * PSZB);
+				
+				if (ZCMP(zz, *pz)) {
+#if TGL_FEATURE_BLEND == 1
+					if (!zb->enable_blend)
+						*pp = col;
+					else
+						TGL_BLEND_FUNC_RGB(p->r, p->g, p->b, (*pp))
+#else
+					*pp = col;
+#endif
+					if (zbdw)
+						*pz = zz;
+				}
+			}
+	}
+}
+
+#define INTERP_Z
+static void ZB_line_flat_z(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2, GLint color) {
+	
+	GLubyte zbdt = zb->depth_test;
+	GLubyte zbdw = zb->depth_write;
+#include "zline.h"
+}
+
+/* line with color GLinterpolation */
+#define INTERP_Z
+#define INTERP_RGB
+static void ZB_line_interp_z(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2) {
+	
+	GLubyte zbdt = zb->depth_test;
+	GLubyte zbdw = zb->depth_write;
+#include "zline.h"
+}
+
+/* no Z GLinterpolation */
+
+static void ZB_line_flat(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2, GLint color) {
+	
+	
+#include "zline.h"
+}
+
+#define INTERP_RGB
+static void ZB_line_interp(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2) {
+
+#include "zline.h"
+}
+
+void ZB_line_z(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2) {
+	GLint color1, color2;
+	
+	color1 = RGB_TO_PIXEL(p1->r, p1->g, p1->b);
+	color2 = RGB_TO_PIXEL(p2->r, p2->g, p2->b);
+
+	/* choose if the line should have its color GLinterpolated or not */
+	if (color1 == color2) {
+		ZB_line_flat_z(zb, p1, p2, color1);
+	} else {
+		ZB_line_interp_z(zb, p1, p2);
+	}
+}
+
+void ZB_line(ZBuffer* zb, ZBufferPoint* p1, ZBufferPoint* p2) {
+	GLint color1, color2;
+
+	color1 = RGB_TO_PIXEL(p1->r, p1->g, p1->b);
+	color2 = RGB_TO_PIXEL(p2->r, p2->g, p2->b);
+
+	/* choose if the line should have its color GLinterpolated or not */
+	if (color1 == color2) {
+		ZB_line_flat(zb, p1, p2, color1);
+	} else {
+		ZB_line_interp(zb, p1, p2);
+	}
+}
diff --git a/src/other/tinygl/src/zline.h b/src/other/tinygl/src/zline.h
new file mode 100644
index 0000000000..df8d1b2395
--- /dev/null
+++ b/src/other/tinygl/src/zline.h
@@ -0,0 +1,123 @@
+
+{
+	GLint n, dx, dy, sx, pp_inc_1, pp_inc_2;
+	register GLint a;
+	register PIXEL* pp;
+#if defined(INTERP_RGB)
+	register GLuint r, g, b;
+#endif
+#ifdef INTERP_RGB
+	register GLuint rinc, ginc, binc;
+#endif
+#ifdef INTERP_Z
+	register GLushort* pz;
+	GLint zinc;
+	register GLint z, zz;
+#endif
+
+	if (p1->y > p2->y || (p1->y == p2->y && p1->x > p2->x)) {
+		ZBufferPoint* tmp;
+		tmp = p1;
+		p1 = p2;
+		p2 = tmp;
+	}
+	sx = zb->xsize;
+	pp = (PIXEL*)((GLbyte*)zb->pbuf + zb->linesize * p1->y + p1->x * PSZB);
+#ifdef INTERP_Z
+	pz = zb->zbuf + (p1->y * sx + p1->x);
+	z = p1->z;
+#endif
+
+	dx = p2->x - p1->x;
+	dy = p2->y - p1->y;
+#ifdef INTERP_RGB
+	r = p2->r << 8;
+	g = p2->g << 8;
+	b = p2->b << 8;
+#endif
+
+#ifdef INTERP_RGB
+#define RGB(x) x
+#define RGBPIXEL *pp = RGB_TO_PIXEL(r >> 8, g >> 8, b >> 8)
+	
+
+#else /* INTERP_RGB */
+#define RGB(x)
+#if TGL_FEATURE_RENDER_BITS == 24
+#define RGBPIXEL pp[0] = r, pp[1] = g, pp[2] = b
+#else
+#define RGBPIXEL *pp = color
+
+#endif
+#endif /* INTERP_RGB */
+
+#ifdef INTERP_Z
+#define ZZ(x) x
+#define PUTPIXEL()                                                                                                                                             \
+	{                                                                                                                                                          \
+		zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                                        \
+		if (ZCMP(zz, *pz)) {                                                                                                                                   \
+			RGBPIXEL;                                                                                                                                          \
+			if (zbdw) {                                                                                                                                        \
+				*pz = zz;                                                                                                                                      \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+	}
+#else /* INTERP_Z */
+#define ZZ(x)
+#define PUTPIXEL() RGBPIXEL
+#endif /* INTERP_Z */
+
+#define DRAWLINE(dx, dy, inc_1, inc_2)                                                                                                                         \
+	n = dx;                                                                                                                                                    \
+	ZZ(zinc = (p2->z - p1->z) / n);                                                                                                                            \
+	RGB(rinc = ((p2->r - p1->r) << 8) / n; ginc = ((p2->g - p1->g) << 8) / n; binc = ((p2->b - p1->b) << 8) / n);                                              \
+	a = 2 * dy - dx;                                                                                                                                           \
+	dy = 2 * dy;                                                                                                                                               \
+	dx = 2 * dx - dy;                                                                                                                                          \
+	pp_inc_1 = (inc_1)*PSZB;                                                                                                                                   \
+	pp_inc_2 = (inc_2)*PSZB;                                                                                                                                   \
+	do {                                                                                                                                                       \
+		PUTPIXEL();                                                                                                                                            \
+		ZZ(z += zinc);                                                                                                                                         \
+		RGB(r += rinc; g += ginc; b += binc);                                                                                                                  \
+		if (a > 0) {                                                                                                                                           \
+			pp = (PIXEL*)((GLbyte*)pp + pp_inc_1);                                                                                                             \
+			ZZ(pz += (inc_1));                                                                                                                                 \
+			a -= dx;                                                                                                                                           \
+		} else {                                                                                                                                               \
+			pp = (PIXEL*)((GLbyte*)pp + pp_inc_2);                                                                                                             \
+			ZZ(pz += (inc_2));                                                                                                                                 \
+			a += dy;                                                                                                                                           \
+		}                                                                                                                                                      \
+	} while (--n >= 0);
+
+	/* fin macro */
+
+	if (dx == 0 && dy == 0) {
+		PUTPIXEL();
+	} else if (dx > 0) {
+		if (dx >= dy) {
+			DRAWLINE(dx, dy, sx + 1, 1);
+		} else {
+			DRAWLINE(dy, dx, sx + 1, sx);
+		}
+	} else {
+		dx = -dx;
+		if (dx >= dy) {
+			DRAWLINE(dx, dy, sx - 1, -1);
+		} else {
+			DRAWLINE(dy, dx, sx - 1, sx);
+		}
+	}
+}
+
+#undef INTERP_Z
+#undef INTERP_RGB
+
+/* GLinternal defines */
+#undef DRAWLINE
+#undef PUTPIXEL
+#undef ZZ
+#undef RGB
+#undef RGBPIXEL
diff --git a/src/other/tinygl/src/zmath.c b/src/other/tinygl/src/zmath.c
new file mode 100644
index 0000000000..4980eed41e
--- /dev/null
+++ b/src/other/tinygl/src/zmath.c
@@ -0,0 +1,309 @@
+/* Some simple mathematical functions. Don't look for some logic in
+   the function names :-) */
+
+#include "zmath.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/* ******* Gestion des matrices 4x4 ****** */
+
+void gl_M4_Id(M4* a) {
+	/*
+		GLint i, j;
+	#pragma omp simd collapse(2)
+		for (i = 0; i < 4; i++)
+			for (j = 0; j < 4; j++)
+				if (i == j)
+					a->m[i][j] = 1.0;
+				else
+					a->m[i][j] = 0.0;
+	*/
+	const M4 c = (M4){{
+		{1, 0, 0, 0},
+		{0, 1, 0, 0},
+		{0, 0, 1, 0},
+		{0, 0, 0, 1},
+	}};
+	*a = c;
+}
+
+GLint gl_M4_IsId(M4* a) {
+	
+	const M4 c = (M4){{
+		{1, 0, 0, 0},
+		{0, 1, 0, 0},
+		{0, 0, 1, 0},
+		{0, 0, 0, 1},
+	}};
+	return (memcmp(a->m, c.m, 16 * sizeof(GLfloat)) == 0);
+	/*
+		for (i = 0; i < 4; i++)
+			for (j = 0; j < 4; j++) {
+				if (i == j) {
+					if (a->m[i][j] != 1.0)
+						return 0;
+				} else if (a->m[i][j] != 0.0)
+					return 0;
+			}
+		return 1;
+	*/
+}
+
+void gl_M4_Mul(M4* c, M4* a, M4* b) {
+	GLint i, j, k;
+	GLfloat s;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+	for (i = 0; i < 4; i++)
+		for (j = 0; j < 4; j++) {
+			s = 0.0;
+			for (k = 0; k < 4; k++)
+				s += a->m[i][k] * b->m[k][j];
+			c->m[i][j] = s;
+		}
+}
+
+/* c=c*a */
+void gl_M4_MulLeft(M4* c, M4* b) {
+	GLint i, j, k;
+	GLfloat s;
+	M4 a;
+
+	/*memcpy(&a, c, 16*sizeof(GLfloat));
+	 */
+	a = *c;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+	for (i = 0; i < 4; i++)
+		for (j = 0; j < 4; j++) {
+			s = 0.0;
+			for (k = 0; k < 4; k++)
+				s += a.m[i][k] * b->m[k][j];
+			c->m[i][j] = s;
+		}
+}
+
+void gl_M4_Move(M4* a, M4* b) { memcpy(a, b, sizeof(M4)); }
+
+void gl_MoveV3(V3* a, V3* b) { memcpy(a, b, sizeof(V3)); }
+
+void gl_MulM4V3(V3* a, M4* b, V3* c) {
+	a->X = b->m[0][0] * c->X + b->m[0][1] * c->Y + b->m[0][2] * c->Z + b->m[0][3];
+	a->Y = b->m[1][0] * c->X + b->m[1][1] * c->Y + b->m[1][2] * c->Z + b->m[1][3];
+	a->Z = b->m[2][0] * c->X + b->m[2][1] * c->Y + b->m[2][2] * c->Z + b->m[2][3];
+}
+
+void gl_MulM3V3(V3* a, M4* b, V3* c) {
+	a->X = b->m[0][0] * c->X + b->m[0][1] * c->Y + b->m[0][2] * c->Z;
+	a->Y = b->m[1][0] * c->X + b->m[1][1] * c->Y + b->m[1][2] * c->Z;
+	a->Z = b->m[2][0] * c->X + b->m[2][1] * c->Y + b->m[2][2] * c->Z;
+}
+
+void gl_M4_MulV4(V4* a, M4* b, V4* c) {
+	{
+		a->X = b->m[0][0] * c->X + b->m[0][1] * c->Y + b->m[0][2] * c->Z + b->m[0][3] * c->W;
+		a->Y = b->m[1][0] * c->X + b->m[1][1] * c->Y + b->m[1][2] * c->Z + b->m[1][3] * c->W;
+		a->Z = b->m[2][0] * c->X + b->m[2][1] * c->Y + b->m[2][2] * c->Z + b->m[2][3] * c->W;
+		a->W = b->m[3][0] * c->X + b->m[3][1] * c->Y + b->m[3][2] * c->Z + b->m[3][3] * c->W;
+	}
+}
+
+/* transposition of a 4x4 matrix */
+void gl_M4_Transpose(M4* a, M4* b) {
+	{
+		a->m[0][0] = b->m[0][0];
+		a->m[0][1] = b->m[1][0];
+		a->m[0][2] = b->m[2][0];
+		a->m[0][3] = b->m[3][0];
+
+		a->m[1][0] = b->m[0][1];
+		a->m[1][1] = b->m[1][1];
+		a->m[1][2] = b->m[2][1];
+		a->m[1][3] = b->m[3][1];
+
+		a->m[2][0] = b->m[0][2];
+		a->m[2][1] = b->m[1][2];
+		a->m[2][2] = b->m[2][2];
+		a->m[2][3] = b->m[3][2];
+
+		a->m[3][0] = b->m[0][3];
+		a->m[3][1] = b->m[1][3];
+		a->m[3][2] = b->m[2][3];
+		a->m[3][3] = b->m[3][3];
+	}
+}
+
+/* inversion of an orthogonal matrix of type Y=M.X+P */
+void gl_M4_InvOrtho(M4* a, M4 b) {
+	GLint i, j;
+	GLfloat s;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			a->m[i][j] = b.m[j][i];
+	a->m[3][0] = 0.0;
+	a->m[3][1] = 0.0;
+	a->m[3][2] = 0.0;
+	a->m[3][3] = 1.0;
+
+	for (i = 0; i < 3; i++) {
+		s = 0;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+		for (j = 0; j < 3; j++)
+			s -= b.m[j][i] * b.m[j][3];
+		a->m[i][3] = s;
+	}
+}
+
+/* Inversion of a general nxn matrix.
+   Note : m is destroyed */
+
+GLint Matrix_Inv(GLfloat* r, GLfloat* m, GLint n) {
+	GLint i, j, k, l;
+	GLfloat max, tmp, t;
+
+	/*  */
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+	for (i = 0; i < n * n; i++)
+		r[i] = 0;
+	for (i = 0; i < n; i++)
+		r[i * n + i] = 1;
+	for (j = 0; j < n; j++) {
+
+		/* recherche du nombre de plus grand module sur la colonne j */
+		max = m[j * n + j];
+		k = j;
+		for (i = j + 1; i < n; i++)
+			if (fabs(m[i * n + j]) > fabs(max)) {
+				k = i;
+				max = m[i * n + j];
+			}
+
+		/* non GLintersible matrix */
+		if (max == 0)
+			return 1;
+
+		/* permutation des lignes j et k */
+		if (k != j) {
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+			for (i = 0; i < n; i++) {
+				tmp = m[j * n + i];
+				m[j * n + i] = m[k * n + i];
+				m[k * n + i] = tmp;
+
+				tmp = r[j * n + i];
+				r[j * n + i] = r[k * n + i];
+				r[k * n + i] = tmp;
+			}
+		}
+
+		/* multiplication de la ligne j par 1/max */
+		max = 1 / max;
+#ifdef _OPENMP
+#  pragma omp simd
+#endif
+		for (i = 0; i < n; i++) {
+			m[j * n + i] *= max;
+			r[j * n + i] *= max;
+		}
+		for (l = 0; l < n; l++)
+			if (l != j) {
+				t = m[l * n + j];
+				for (i = 0; i < n; i++) {
+					m[l * n + i] -= m[j * n + i] * t;
+					r[l * n + i] -= r[j * n + i] * t;
+				}
+			}
+	}
+
+	return 0;
+}
+
+/* inversion of a 4x4 matrix */
+
+void gl_M4_Inv(M4* a, M4* b) {
+	M4 tmp;
+	memcpy(&tmp, b, sizeof(M4));
+	/*tmp=*b;*/
+	Matrix_Inv(&a->m[0][0], &tmp.m[0][0], 4);
+}
+
+void gl_M4_Rotate(M4* a, GLfloat t, GLint u) {
+	GLfloat s, c;
+	GLint v, w;
+	if ((v = u + 1) > 2)
+		v = 0;
+	if ((w = v + 1) > 2)
+		w = 0;
+	s = sin(t);
+	c = cos(t);
+	gl_M4_Id(a);
+	a->m[v][v] = c;
+	a->m[v][w] = -s;
+	a->m[w][v] = s;
+	a->m[w][w] = c;
+}
+
+/* inverse of a 3x3 matrix */
+void gl_M3_Inv(M3* a, M3* m) {
+	GLfloat det;
+
+	det = m->m[0][0] * m->m[1][1] * m->m[2][2] - m->m[0][0] * m->m[1][2] * m->m[2][1] - m->m[1][0] * m->m[0][1] * m->m[2][2] +
+		  m->m[1][0] * m->m[0][2] * m->m[2][1] + m->m[2][0] * m->m[0][1] * m->m[1][2] - m->m[2][0] * m->m[0][2] * m->m[1][1];
+	a->m[0][0] = (m->m[1][1] * m->m[2][2] - m->m[1][2] * m->m[2][1]) / det;
+	a->m[0][1] = -(m->m[0][1] * m->m[2][2] - m->m[0][2] * m->m[2][1]) / det;
+	a->m[0][2] = -(-m->m[0][1] * m->m[1][2] + m->m[0][2] * m->m[1][1]) / det;
+
+	a->m[1][0] = -(m->m[1][0] * m->m[2][2] - m->m[1][2] * m->m[2][0]) / det;
+	a->m[1][1] = (m->m[0][0] * m->m[2][2] - m->m[0][2] * m->m[2][0]) / det;
+	a->m[1][2] = -(m->m[0][0] * m->m[1][2] - m->m[0][2] * m->m[1][0]) / det;
+
+	a->m[2][0] = (m->m[1][0] * m->m[2][1] - m->m[1][1] * m->m[2][0]) / det;
+	a->m[2][1] = -(m->m[0][0] * m->m[2][1] - m->m[0][1] * m->m[2][0]) / det;
+	a->m[2][2] = (m->m[0][0] * m->m[1][1] - m->m[0][1] * m->m[1][0]) / det;
+}
+
+/* vector arithmetic */
+
+
+
+
+/*
+int gl_V3_Norm(V3* a) {
+	GLfloat n;
+	n = sqrt(a->X * a->X + a->Y * a->Y + a->Z * a->Z);
+	if (n == 0)
+		return 1;
+	a->X /= n;
+	a->Y /= n;
+	a->Z /= n;
+	return 0;
+}
+*/
+V3 gl_V3_New(GLfloat x, GLfloat y, GLfloat z) {
+	V3 a;
+	a.X = x;
+	a.Y = y;
+	a.Z = z;
+	return a;
+}
+
+V4 gl_V4_New(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+	V4 a;
+	a.X = x;
+	a.Y = y;
+	a.Z = z;
+	a.W = w;
+	return a;
+}
diff --git a/src/other/tinygl/src/zmath.h b/src/other/tinygl/src/zmath.h
new file mode 100644
index 0000000000..90449ab6ec
--- /dev/null
+++ b/src/other/tinygl/src/zmath.h
@@ -0,0 +1,73 @@
+#ifndef __ZMATH__
+#define __ZMATH__
+#include "../include/TGL/gl.h"
+#include "../include/zfeatures.h"
+#include <math.h>
+#include <stdlib.h>
+#include <string.h> 
+/* Matrix & Vertex */
+
+typedef struct {
+	TGL_ALIGN GLfloat m[4][4];
+} M4;
+
+typedef struct {
+	TGL_ALIGN GLfloat m[3][3];
+} M3;
+
+typedef struct {
+	TGL_ALIGN GLfloat m[3][4];
+} M34;
+
+#define X v[0]
+#define Y v[1]
+#define Z v[2]
+#define W v[3]
+
+typedef struct {
+	TGL_ALIGN GLfloat v[3];
+} V3;
+
+typedef struct {
+	TGL_ALIGN GLfloat v[4];
+} V4;
+
+void gl_M4_Id(M4* a);
+GLint gl_M4_IsId(M4* a);
+void gl_M4_Move(M4* a, M4* b);
+void gl_MoveV3(V3* a, V3* b);
+void gl_MulM4V3(V3* a, M4* b, V3* c);
+void gl_MulM3V3(V3* a, M4* b, V3* c);
+
+void gl_M4_MulV4(V4* a, M4* b, V4* c);
+void gl_M4_InvOrtho(M4* a, M4 b);
+void gl_M4_Inv(M4* a, M4* b);
+void gl_M4_Mul(M4* c, M4* a, M4* b);
+void gl_M4_MulLeft(M4* c, M4* a);
+void gl_M4_Transpose(M4* a, M4* b);
+void gl_M4_Rotate(M4* c, GLfloat t, GLint u);
+
+
+
+V3 gl_V3_New(GLfloat x, GLfloat y, GLfloat z);
+V4 gl_V4_New(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+
+GLint gl_Matrix_Inv(GLfloat* r, GLfloat* m, GLint n);
+
+
+#if TGL_FEATURE_FISR == 1
+static GLfloat fastInvSqrt(GLfloat x) {
+	GLint i;
+	GLfloat x2;
+	memcpy(&i, &x, 4);
+	i = 0x5F1FFFF9 - (i >> 1);
+	memcpy(&x2, &i, 4);
+	x2 *= 0.703952253f * (2.38924456f - x * x2 * x2);
+	return x2;
+}
+#endif
+
+extern int gl_V3_Norm_Fast(V3* a);
+
+#endif
+
diff --git a/src/other/tinygl/src/zpostprocess.c b/src/other/tinygl/src/zpostprocess.c
new file mode 100644
index 0000000000..04b200301a
--- /dev/null
+++ b/src/other/tinygl/src/zpostprocess.c
@@ -0,0 +1,14 @@
+#include "../include/TGL/gl.h"
+#include "../include/zbuffer.h"
+#include "zgl.h"
+
+void glPostProcess(GLuint (*postprocess)(GLint x, GLint y, GLuint pixel, GLushort z)) {
+	GLint i, j;
+	GLContext* c = gl_get_context();
+#ifdef _OPENMP
+#  pragma omp parallel for collapse(2)
+#endif
+	for (j = 0; j < c->zb->ysize; j++)
+		for (i = 0; i < c->zb->xsize; i++)
+			c->zb->pbuf[i + j * (c->zb->xsize)] = postprocess(i, j, c->zb->pbuf[i + j * (c->zb->xsize)], c->zb->zbuf[i + j * (c->zb->xsize)]);
+}
diff --git a/src/other/tinygl/src/zraster.c b/src/other/tinygl/src/zraster.c
new file mode 100644
index 0000000000..f76169dd9a
--- /dev/null
+++ b/src/other/tinygl/src/zraster.c
@@ -0,0 +1,229 @@
+#include "../include/TGL/gl.h"
+#include "../include/zbuffer.h"
+#include "msghandling.h"
+#include "zgl.h"
+
+static void gl_vertex_transform_raster(GLVertex* v) {
+	GLContext* c = gl_get_context();
+
+	{
+		/* no eye coordinates needed, no normal */
+		/* NOTE: W = 1 is assumed */
+		GLfloat* m = &c->matrix_model_projection.m[0][0];
+
+		v->pc.X = (v->coord.X * m[0] + v->coord.Y * m[1] + v->coord.Z * m[2] + m[3]);
+		v->pc.Y = (v->coord.X * m[4] + v->coord.Y * m[5] + v->coord.Z * m[6] + m[7]);
+		v->pc.Z = (v->coord.X * m[8] + v->coord.Y * m[9] + v->coord.Z * m[10] + m[11]);
+
+		if (c->matrix_model_projection_no_w_transform) {
+			v->pc.W = m[15];
+		} else {
+			v->pc.W = (v->coord.X * m[12] + v->coord.Y * m[13] + v->coord.Z * m[14] + m[15]);
+		}
+		m = &c->matrix_stack_ptr[0]->m[0][0];
+		v->ec.X = (v->coord.X * m[0] + v->coord.Y * m[1] + v->coord.Z * m[2] + m[3]);
+		v->ec.Y = (v->coord.X * m[4] + v->coord.Y * m[5] + v->coord.Z * m[6] + m[7]);
+		v->ec.Z = (v->coord.X * m[8] + v->coord.Y * m[9] + v->coord.Z * m[10] + m[11]);
+		v->ec.W = (v->coord.X * m[12] + v->coord.Y * m[13] + v->coord.Z * m[14] + m[15]);
+	}
+
+	v->clip_code = gl_clipcode(v->pc.X, v->pc.Y, v->pc.Z, v->pc.W);
+}
+
+void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+	GLParam p[5];
+	p[0].op = OP_RasterPos;
+	p[1].f = x;
+	p[2].f = y;
+	p[3].f = z;
+	p[4].f = w;
+	gl_add_op(p);
+}
+void glopRasterPos(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLVertex v;
+	v.coord.X = p[1].f;
+	v.coord.Y = p[2].f;
+	v.coord.Z = p[3].f;
+	v.coord.W = p[4].f;
+	gl_vertex_transform_raster(&v);
+	if (v.clip_code == 0) {
+		{
+			GLfloat winv = 1.0 / v.pc.W;
+			v.zp.x = (GLint)(v.pc.X * winv * c->viewport.scale.X + c->viewport.trans.X);
+			v.zp.y = (GLint)(v.pc.Y * winv * c->viewport.scale.Y + c->viewport.trans.Y);
+			v.zp.z = (GLint)(v.pc.Z * winv * c->viewport.scale.Z + c->viewport.trans.Z);
+		}
+		c->rasterpos.v[0] = v.zp.x;
+		c->rasterpos.v[1] = v.zp.y;
+		c->rastervertex = v;
+		/* c->rasterpos.v[2] = v.zp.z;*/
+		c->rasterpos_zz = v.zp.z >> ZB_POINT_Z_FRAC_BITS; 
+		c->rasterposvalid = 1;
+	} else
+		c->rasterposvalid = 0;
+}
+
+void glRasterPos2f(GLfloat x, GLfloat y) { glRasterPos4f(x, y, 0, 1); }
+void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) { glRasterPos4f(x, y, z, 1); }
+
+void glRasterPos2fv(GLfloat* v) { glRasterPos2f(v[0], v[1]); }
+void glRasterPos3fv(GLfloat* v) { glRasterPos3f(v[0], v[1], v[2]); }
+void glRasterPos4fv(GLfloat* v) { glRasterPos4f(v[0], v[1], v[2], v[3]); }
+
+void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, void* data) {
+	/* TODO: Come up with a clever scheme for storing the data to avoid pointer dependency. */
+#if TGL_FEATURE_RENDER_BITS == 32
+	if (type != GL_UNSIGNED_INT && type != GL_UNSIGNED_INT_8_8_8_8) {
+		tgl_warning("\nERROR: Incorrect type for glDrawPixels. It MUST be GL_UNSIGNED_INT or GL_UNSIGNED_INT_8_8_8_8, A R G B!");
+		return;
+	}
+#elif TGL_FEATURE_RENDER_BITS == 16
+	if (type != GL_UNSIGNED_SHORT && type != GL_UNSIGNED_SHORT_5_6_5) {
+		tgl_warning("\nERROR: Incorrect type for glDrawPixels. it MUST be GL_UNSIGNED_SHORT or GL_UNSIGNED_SHORT_5_6_5, R5 G6 B5!");
+		return;
+	}
+#else
+#error "Bad TGL_FEATURE_RENDER_BITS"
+#endif
+	if (format != GL_RGB) {
+		tgl_warning("\nERROR: Incorrect format for glDrawPixels.");
+		return;
+	}
+	GLParam p[6];
+	p[0].op = OP_DrawPixels;
+	p[1].i = width;
+	p[2].i = height;
+	p[3].p = data;
+	gl_add_op(p);
+}
+#define ZCMP(z, zpix) (!(zbdt) || z >= (zpix))
+#define CLIPTEST(_x, _y, _w, _h) ((0 <= _x) && (_w > _x) && (0 <= _y) && (_h > _y))
+void glopDrawPixels(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint sy, sx, ty, tx;
+	
+	GLint w = p[1].i;
+	GLint h = p[2].i;
+	V4 rastpos = c->rasterpos;
+	ZBuffer* zb = c->zb;
+	PIXEL* d = p[3].p;
+	PIXEL* pbuf = zb->pbuf;
+	GLushort* zbuf = zb->zbuf;
+
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	GLint tw = zb->xsize;
+	GLint th = zb->ysize;
+	GLfloat pzoomx = c->pzoomx;
+	GLfloat pzoomy = c->pzoomy;
+
+	GLint zz = c->rasterpos_zz;
+#if TGL_FEATURE_BLEND_DRAW_PIXELS == 1
+	TGL_BLEND_VARS
+#endif
+#if TGL_FEATURE_BLEND == 1
+#if TGL_FEATURE_BLEND_DRAW_PIXELS == 1
+	GLuint zbeb = zb->enable_blend;
+#endif
+#endif
+	if (!c->rasterposvalid)return;
+	
+#if TGL_FEATURE_ALT_RENDERMODES == 1
+	if (c->render_mode == GL_SELECT) {
+		gl_add_select(zz, zz);
+		return;
+	} else if (c->render_mode == GL_FEEDBACK) {
+		gl_add_feedback(GL_DRAW_PIXEL_TOKEN, &(c->rastervertex), NULL, NULL, 0);
+		return;
+	}
+#endif
+
+#if TGL_FEATURE_MULTITHREADED_DRAWPIXELS == 1
+
+#ifdef _OPENMP
+#  pragma omp parallel for
+#endif
+	for (sy = 0; sy < h; sy++)
+		for (sx = 0; sx < w; sx++) {
+			PIXEL col = d[sy * w + sx];
+			V4 rastoffset;
+			rastoffset.v[0] = rastpos.v[0] + (GLfloat)sx * pzoomx;
+			rastoffset.v[1] = rastpos.v[1] - ((GLfloat)(h - sy) * pzoomy);
+			rastoffset.v[2] = rastoffset.v[0] + pzoomx;
+			rastoffset.v[3] = rastoffset.v[1] - pzoomy;
+
+			for (ty = rastoffset.v[1]; (GLfloat)ty > rastoffset.v[3]; ty--)
+				for (tx = rastoffset.v[0]; (GLfloat)tx < rastoffset.v[2]; tx++)
+					if (CLIPTEST(tx, ty, tw, th)) {
+						GLushort* pz = zbuf + (ty * tw + tx);
+
+						if (ZCMP(zz, *pz)) {
+
+#if TGL_FEATURE_BLEND == 1
+#if TGL_FEATURE_BLEND_DRAW_PIXELS == 1
+							if (!zbeb)
+								pbuf[tx + ty * tw] = col;
+							else
+								TGL_BLEND_FUNC(col, pbuf[tx + ty * tw])
+#else
+							pbuf[tx + ty * tw] = col;
+#endif
+#else
+							pbuf[tx + ty * tw] = col;
+#endif
+							if (zbdw)
+								*pz = zz;
+						}
+					}
+		}
+#else
+	for (sy = 0; sy < h; sy++)
+		for (sx = 0; sx < w; sx++) {
+			PIXEL col = d[sy * w + sx];
+			V4 rastoffset;
+			rastoffset.v[0] = rastpos.v[0] + (GLfloat)sx * pzoomx;
+			rastoffset.v[1] = rastpos.v[1] - ((GLfloat)(h - sy) * pzoomy);
+			rastoffset.v[2] = rastoffset.v[0] + pzoomx;
+			rastoffset.v[3] = rastoffset.v[1] - pzoomy;
+
+			for (ty = rastoffset.v[1]; (GLfloat)ty > rastoffset.v[3]; ty--)
+				for (tx = rastoffset.v[0]; (GLfloat)tx < rastoffset.v[2]; tx++)
+					if (CLIPTEST(tx, ty, tw, th)) {
+						GLushort* pz = zbuf + (ty * tw + tx);
+
+						if (ZCMP(zz, *pz)) {
+
+#if TGL_FEATURE_BLEND == 1
+#if TGL_FEATURE_BLEND_DRAW_PIXELS == 1
+							if (!zbeb)
+								pbuf[tx + ty * tw] = col;
+							else
+								TGL_BLEND_FUNC(col, pbuf[tx + ty * tw])
+#else
+							pbuf[tx + ty * tw] = col;
+#endif
+#else
+							pbuf[tx + ty * tw] = col;
+#endif
+							if (zbdw)
+								*pz = zz;
+						}
+					}
+		}
+#endif
+}
+
+void glPixelZoom(GLfloat x, GLfloat y) {
+	GLParam p[3];
+	p[0].op = OP_PixelZoom;
+	p[1].f = x;
+	p[2].f = y;
+	gl_add_op(p);
+}
+
+void glopPixelZoom(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->pzoomx = p[1].f;
+	c->pzoomy = p[2].f;
+}
diff --git a/src/other/tinygl/src/ztext.c b/src/other/tinygl/src/ztext.c
new file mode 100644
index 0000000000..4fe3160d12
--- /dev/null
+++ b/src/other/tinygl/src/ztext.c
@@ -0,0 +1,94 @@
+#include "../include/TGL/gl.h"
+#include "../include/zbuffer.h"
+#include "font8x8_basic.h"
+#include "zgl.h"
+
+
+#include <stdlib.h>
+
+
+void glTextSize(GLTEXTSIZE mode) {
+#define NEED_CONTEXT
+#include "error_check_no_context.h"
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (mode < 1 || GL_MAX_TEXT_SIZE < mode)
+#define ERROR_FLAG GL_INVALID_ENUM
+#include "error_check.h"
+#endif
+		GLParam p[2];
+	p[0].op = OP_TextSize;
+	p[1].ui = mode;
+	gl_add_op(p);
+}
+void glopTextSize(GLParam* p) {
+	GLContext* c = gl_get_context();
+	c->textsize = p[1].ui;
+} 
+static void renderchar(GLbyte* bitmap, GLint _x, GLint _y, GLuint p) {
+	GLint x, y, i, j;
+	GLint set;
+	GLContext* c = gl_get_context();
+	GLint mult = c->textsize;
+	for (x = 0; x < 8; x++) {
+		for (y = 0; y < 8; y++) {
+			set = bitmap[x] & (1 << y);
+			if (set)
+				for (i = 0; i < mult; i++)
+					for (j = 0; j < mult; j++)
+						glPlotPixel(y * mult + i + _x, x * mult + j + _y, p);
+		}
+	}
+}
+
+void glopPlotPixel(GLParam* p) {
+	GLContext* c = gl_get_context();
+	GLint x = p[1].i;
+	PIXEL pix = p[2].ui;
+	c->zb->pbuf[x] = pix;
+	
+}
+
+void glPlotPixel(GLint x, GLint y, GLuint pix) {
+	GLParam p[3];
+	GLContext* c = gl_get_context();
+#include "error_check.h"
+	
+	GLint w = c->zb->xsize;
+	GLint h = c->zb->ysize;
+	p[0].op = OP_PlotPixel;
+
+	if (x > -1 && x < w && y > -1 && y < h) {
+#if TGL_FEATURE_RENDER_BITS == 16
+		pix = RGB_TO_PIXEL((pix & COLOR_MULT_MASK), ((pix & 0xFF00) << (COLOR_SHIFT - 8)), ((pix & 255) << COLOR_SHIFT));
+#endif
+		p[1].i = x + y * w;
+		p[2].ui = pix;
+		gl_add_op(p);
+	}
+}
+void glDrawText(const GLubyte* text, GLint x, GLint y, GLuint p) {
+	GLContext* c = gl_get_context();
+	GLint i = 0;
+#include "error_check.h"
+
+#if TGL_FEATURE_ERROR_CHECK == 1
+	if (!text)
+#define ERROR_FLAG GL_INVALID_VALUE
+#include "error_check.h"
+#endif
+		
+		GLint w = c->zb->xsize;
+	GLint h = c->zb->ysize;
+	GLint xoff = 0;
+	GLint yoff = 0;
+	GLint mult = c->textsize;
+	for (; text[i] != '\0' && y + 7 < h; i++) {
+		if (text[i] != '\n' && xoff + x < w) {
+			renderchar(font8x8_basic[text[i]], x + xoff, y + yoff, p);
+			xoff += 8 * mult;
+		} else if (text[i] == '\n') {
+			xoff = 0;
+			yoff += 8 * mult;
+		}
+	}
+}
diff --git a/src/other/tinygl/src/ztriangle.c b/src/other/tinygl/src/ztriangle.c
new file mode 100644
index 0000000000..874666350f
--- /dev/null
+++ b/src/other/tinygl/src/ztriangle.c
@@ -0,0 +1,489 @@
+#include "../include/zbuffer.h"
+#include "msghandling.h"
+#include <stdlib.h>
+
+#if 0
+/* TODO: Switch from scanline rasterizer to easily parallelized cross product rasterizer.*/
+static GLfloat edgeFunction(GLfloat ax, GLfloat ay, GLfloat bx, GLfloat by, GLfloat cx, GLfloat cy) {
+	return (cx - ax) * (by - ay) - (cy - ay) * (bx - ax);
+}
+#endif
+
+#if TGL_FEATURE_RENDER_BITS == 32
+#elif TGL_FEATURE_RENDER_BITS == 16
+#else
+#error "WRONG MODE!!!"
+#endif
+
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+
+#define TGL_STIPPLEVARS                                                                                                                                        \
+	GLubyte* zbstipplepattern = zb->stipplepattern;                                                                                                            \
+	GLubyte zbdostipple = zb->dostipple;
+#define THE_X ((GLint)(pp - pp1))
+#define XSTIP(_a) ((THE_X + _a) & TGL_POLYGON_STIPPLE_MASK_X)
+#define YSTIP (the_y & TGL_POLYGON_STIPPLE_MASK_Y)
+/* NOTES                                                           Divide by 8 to get the byte        Get the actual bit*/
+#define STIPBIT(_a) (zbstipplepattern[(XSTIP(_a) | (YSTIP << TGL_POLYGON_STIPPLE_POW2_WIDTH)) >> 3] & (1 << (XSTIP(_a) & 7)))
+#define STIPTEST(_a) &&(!(zbdostipple && !STIPBIT(_a)))
+
+#else
+
+#define TGL_STIPPLEVARS /* a comment */
+#define STIPTEST(_a)	/* a comment*/
+
+#endif
+
+#if TGL_FEATURE_NO_DRAW_COLOR == 1
+#define NODRAWTEST(c) &&((c & TGL_COLOR_MASK) != TGL_NO_DRAW_COLOR)
+#else
+#define NODRAWTEST(c) /* a comment */
+#endif
+
+#define ZCMP(z, zpix, _a, c) (((!zbdt) || (z >= zpix)) STIPTEST(_a) NODRAWTEST(c))
+#define ZCMPSIMP(z, zpix, _a, crabapple) (((!zbdt) || (z >= zpix)) STIPTEST(_a))
+
+void ZB_fillTriangleFlat(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+	GLubyte zbdt = zb->depth_test;
+	GLubyte zbdw = zb->depth_write;
+	GLuint color;
+	TGL_BLEND_VARS
+	TGL_STIPPLEVARS
+
+#undef INTERP_Z
+#undef INTERP_RGB
+#undef INTERP_ST
+#undef INTERP_STZ
+
+#define INTERP_Z
+
+
+#define DRAW_INIT()                                                                                                                                            \
+	{ color = RGB_TO_PIXEL(p2->r, p2->g, p2->b); }
+
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, color)) {                                                                                                             \
+				TGL_BLEND_FUNC(color, (pp[_a])) /*pp[_a] = color;*/                                                                                            \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+	}
+
+#include "ztriangle.h"
+}
+
+void ZB_fillTriangleFlatNOBLEND(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+	PIXEL color = RGB_TO_PIXEL(p2->r, p2->g, p2->b);
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	TGL_STIPPLEVARS
+#undef INTERP_Z
+#undef INTERP_RGB
+#undef INTERP_ST
+#undef INTERP_STZ
+#define INTERP_Z
+
+#define DRAW_INIT()                                                                                                                                            \
+	{}
+
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				pp[_a] = color;                                                                                                                                \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+	}
+
+#include "ztriangle.h"
+}
+
+/*
+ * Smooth filled triangle.
+ * The code below is very tricky :)
+ */
+
+void ZB_fillTriangleSmooth(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	TGL_BLEND_VARS
+	TGL_STIPPLEVARS
+
+#define INTERP_Z
+#define INTERP_RGB
+
+#define SAR_RND_TO_ZERO(v, n) (v / (1 << n))
+
+#if TGL_FEATURE_RENDER_BITS == 32
+#define DRAW_INIT()                                                                                                                                            \
+	{}
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				/*pp[_a] = RGB_TO_PIXEL(or1, og1, ob1);*/                                                                                                      \
+				TGL_BLEND_FUNC_RGB(or1, og1, ob1, (pp[_a]));                                                                                                   \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		og1 += dgdx;                                                                                                                                           \
+		or1 += drdx;                                                                                                                                           \
+		ob1 += dbdx;                                                                                                                                           \
+	}
+
+
+#elif TGL_FEATURE_RENDER_BITS == 16
+
+#define DRAW_INIT()                                                                                                                                            \
+	{}
+
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				/*pp[_a] = RGB_TO_PIXEL(or1, og1, ob1);*/                                                                                                      \
+				TGL_BLEND_FUNC_RGB(or1, og1, ob1, (pp[_a]));                                                                                                   \
+                                                                                                                                                               \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		og1 += dgdx;                                                                                                                                           \
+		or1 += drdx;                                                                                                                                           \
+		ob1 += dbdx;                                                                                                                                           \
+	}
+
+#endif
+
+#include "ztriangle.h"
+} 
+
+void ZB_fillTriangleSmoothNOBLEND(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	TGL_STIPPLEVARS
+
+#define INTERP_Z
+#define INTERP_RGB
+
+#define SAR_RND_TO_ZERO(v, n) (v / (1 << n))
+
+#if TGL_FEATURE_RENDER_BITS == 32
+#define DRAW_INIT()                                                                                                                                            \
+	{}
+
+#if TGL_FEATURE_NO_DRAW_COLOR != 1
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				pp[_a] = RGB_TO_PIXEL(or1, og1, ob1);                                                                                                          \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		og1 += dgdx;                                                                                                                                           \
+		or1 += drdx;                                                                                                                                           \
+		ob1 += dbdx;                                                                                                                                           \
+	}
+#else
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			/*c = RGB_TO_PIXEL(or1, og1, ob1);*/                                                                                                               \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				pp[_a] = RGB_TO_PIXEL(or1, og1, ob1);                                                                                                          \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		og1 += dgdx;                                                                                                                                           \
+		or1 += drdx;                                                                                                                                           \
+		ob1 += dbdx;                                                                                                                                           \
+	}
+#endif
+
+#elif TGL_FEATURE_RENDER_BITS == 16
+
+#define DRAW_INIT()                                                                                                                                            \
+	{}
+
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				pp[_a] = RGB_TO_PIXEL(or1, og1, ob1);                                                                                                          \
+                                                                                                                                                               \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		og1 += dgdx;                                                                                                                                           \
+		or1 += drdx;                                                                                                                                           \
+		ob1 += dbdx;                                                                                                                                           \
+	}
+
+#endif
+/* End of 16 bit mode stuff*/
+#include "ztriangle.h"
+} 
+
+/*
+
+
+			TEXTURE MAPPED TRIANGLES
+               Section_Header
+
+
+
+
+*/
+void ZB_setTexture(ZBuffer* zb, PIXEL* texture) { zb->current_texture = texture; }
+
+
+#if 1
+
+#define DRAW_LINE_TRI_TEXTURED()                                                                                                                               \
+	{                                                                                                                                                          \
+		register GLushort* pz;                                                                                                                                 \
+		register PIXEL* pp;                                                                                                                                    \
+		register GLuint s, t, z;                                                                                                                               \
+		register GLint n;                                                                                                                                      \
+		OR1OG1OB1DECL                                                                                                                                          \
+		GLfloat sz, tz, fzl, zinv;                                                                                                                             \
+		n = (x2 >> 16) - x1;                                                                                                                                   \
+		fzl = (GLfloat)z1;                                                                                                                                     \
+		zinv = 1.0 / fzl;                                                                                                                                      \
+		pp = (PIXEL*)((GLbyte*)pp1 + x1 * PSZB);                                                                                                               \
+		pz = pz1 + x1;                                                                                                                                         \
+		z = z1;                                                                                                                                                \
+		sz = sz1;                                                                                                                                              \
+		tz = tz1;                                                                                                                                              \
+		while (n >= (NB_INTERP - 1)) {                                                                                                                         \
+			register GLint dsdx, dtdx;                                                                                                                         \
+			{                                                                                                                                                  \
+				GLfloat ss, tt;                                                                                                                                \
+				ss = (sz * zinv);                                                                                                                              \
+				tt = (tz * zinv);                                                                                                                              \
+				s = (GLint)ss;                                                                                                                                 \
+				t = (GLint)tt;                                                                                                                                 \
+				dsdx = (GLint)((dszdx - ss * fdzdx) * zinv);                                                                                                   \
+				dtdx = (GLint)((dtzdx - tt * fdzdx) * zinv);                                                                                                   \
+			}                                                                                                                                                  \
+			fzl += fndzdx;                                                                                                                                     \
+			zinv = 1.0 / fzl;                                                                                                                                  \
+			PUT_PIXEL(0); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(1); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(2); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(3); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(4); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(5); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(6); /*the_x++;*/                                                                                                                         \
+			PUT_PIXEL(7); /*the_x-=7;*/                                                                                                                        \
+			pz += NB_INTERP;                                                                                                                                   \
+			pp += NB_INTERP; /*the_x+=NB_INTERP * PSZB;*/                                                                                                      \
+			n -= NB_INTERP;                                                                                                                                    \
+			sz += ndszdx;                                                                                                                                      \
+			tz += ndtzdx;                                                                                                                                      \
+		}                                                                                                                                                      \
+		{                                                                                                                                                      \
+			register GLint dsdx, dtdx;                                                                                                                         \
+			{                                                                                                                                                  \
+				GLfloat ss, tt;                                                                                                                                \
+				ss = (sz * zinv);                                                                                                                              \
+				tt = (tz * zinv);                                                                                                                              \
+				s = (GLint)ss;                                                                                                                                 \
+				t = (GLint)tt;                                                                                                                                 \
+				dsdx = (GLint)((dszdx - ss * fdzdx) * zinv);                                                                                                   \
+				dtdx = (GLint)((dtzdx - tt * fdzdx) * zinv);                                                                                                   \
+			}                                                                                                                                                  \
+			while (n >= 0) {                                                                                                                                   \
+				PUT_PIXEL(0);                                                                                                                                  \
+				pz += 1;                                                                                                                                       \
+				/*pp = (PIXEL*)((GLbyte*)pp + PSZB);*/                                                                                                         \
+				pp++;                                                                                                                                          \
+				n -= 1;                                                                                                                                        \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+	} 
+
+void ZB_fillTriangleMappingPerspective(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+	PIXEL* texture;
+
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	TGL_BLEND_VARS
+	TGL_STIPPLEVARS
+#define INTERP_Z
+#define INTERP_STZ
+#define INTERP_RGB
+
+
+#define NB_INTERP 8
+
+#define DRAW_INIT()                                                                                                                                            \
+	{                                                                                                                                                          \
+		texture = zb->current_texture;                                                                                                                         \
+		fdzdx = (GLfloat)dzdx;                                                                                                                                 \
+		fndzdx = NB_INTERP * fdzdx;                                                                                                                            \
+		ndszdx = NB_INTERP * dszdx;                                                                                                                            \
+		ndtzdx = NB_INTERP * dtzdx;                                                                                                                            \
+	}
+#if TGL_FEATURE_LIT_TEXTURES == 1
+#define OR1OG1OB1DECL                                                                                                                                          \
+	register GLint or1, og1, ob1;                                                                                                                              \
+	or1 = r1;                                                                                                                                                  \
+	og1 = g1;                                                                                                                                                  \
+	ob1 = b1;
+#define OR1G1B1INCR                                                                                                                                            \
+	og1 += dgdx;                                                                                                                                               \
+	or1 += drdx;                                                                                                                                               \
+	ob1 += dbdx;
+#else
+#define OR1OG1OB1DECL /*A comment*/
+#define OR1G1B1INCR   /*Another comment*/
+#define or1 COLOR_MULT_MASK
+#define og1 COLOR_MULT_MASK
+#define ob1 COLOR_MULT_MASK
+#endif
+#if TGL_FEATURE_NO_DRAW_COLOR != 1
+
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				/*pp[_a] = RGB_MIX_FUNC(or1, og1, ob1, TEXTURE_SAMPLE(texture, s, t));*/                                                                       \
+				TGL_BLEND_FUNC(RGB_MIX_FUNC(or1, og1, ob1, (TEXTURE_SAMPLE(texture, s, t))), (pp[_a]));                                                        \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		s += dsdx;                                                                                                                                             \
+		t += dtdx;                                                                                                                                             \
+		OR1G1B1INCR                                                                                                                                            \
+	}
+#else
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			PIXEL c = TEXTURE_SAMPLE(texture, s, t);                                                                                                           \
+			if (ZCMP(zz, pz[_a], _a, c)) {                                                                                                                     \
+				TGL_BLEND_FUNC(RGB_MIX_FUNC(or1, og1, ob1, c), (pp[_a]));                                                                                      \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		s += dsdx;                                                                                                                                             \
+		t += dtdx;                                                                                                                                             \
+		OR1G1B1INCR                                                                                                                                            \
+	}
+#endif
+#define DRAW_LINE()                                                                                                                                            \
+	{ DRAW_LINE_TRI_TEXTURED() }
+
+#include "ztriangle.h"
+}
+
+void ZB_fillTriangleMappingPerspectiveNOBLEND(ZBuffer* zb, ZBufferPoint* p0, ZBufferPoint* p1, ZBufferPoint* p2) {
+	PIXEL* texture;
+	
+	GLubyte zbdw = zb->depth_write;
+	GLubyte zbdt = zb->depth_test;
+	TGL_STIPPLEVARS
+#define INTERP_Z
+#define INTERP_STZ
+#define INTERP_RGB
+
+#define NB_INTERP 8
+
+#define DRAW_INIT()                                                                                                                                            \
+	{                                                                                                                                                          \
+		texture = zb->current_texture;                                                                                                                         \
+		fdzdx = (GLfloat)dzdx;                                                                                                                                 \
+		fndzdx = NB_INTERP * fdzdx;                                                                                                                            \
+		ndszdx = NB_INTERP * dszdx;                                                                                                                            \
+		ndtzdx = NB_INTERP * dtzdx;                                                                                                                            \
+	}
+#if TGL_FEATURE_LIT_TEXTURES == 1
+#define OR1OG1OB1DECL                                                                                                                                          \
+	register GLint or1, og1, ob1;                                                                                                                              \
+	or1 = r1;                                                                                                                                                  \
+	og1 = g1;                                                                                                                                                  \
+	ob1 = b1;
+#define OR1G1B1INCR                                                                                                                                            \
+	og1 += dgdx;                                                                                                                                               \
+	or1 += drdx;                                                                                                                                               \
+	ob1 += dbdx;
+#else
+#define OR1OG1OB1DECL /*A comment*/
+#define OR1G1B1INCR   /*Another comment*/
+#define or1 COLOR_MULT_MASK
+#define og1 COLOR_MULT_MASK
+#define ob1 COLOR_MULT_MASK
+#endif
+#if TGL_FEATURE_NO_DRAW_COLOR != 1
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			if (ZCMPSIMP(zz, pz[_a], _a, 0)) {                                                                                                                 \
+				pp[_a] = RGB_MIX_FUNC(or1, og1, ob1, TEXTURE_SAMPLE(texture, s, t));                                                                           \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		s += dsdx;                                                                                                                                             \
+		t += dtdx;                                                                                                                                             \
+		OR1G1B1INCR                                                                                                                                            \
+	}
+#else
+#define PUT_PIXEL(_a)                                                                                                                                          \
+	{                                                                                                                                                          \
+		{                                                                                                                                                      \
+			register GLuint zz = z >> ZB_POINT_Z_FRAC_BITS;                                                                                                    \
+			PIXEL c = TEXTURE_SAMPLE(texture, s, t);                                                                                                           \
+			if (ZCMP(zz, pz[_a], _a, c)) {                                                                                                                     \
+				pp[_a] = RGB_MIX_FUNC(or1, og1, ob1, c);                                                                                                       \
+				/*TGL_BLEND_FUNC(RGB_MIX_FUNC(or1, og1, ob1, c), (pp[_a]));*/                                                                                  \
+				if (zbdw)                                                                                                                                      \
+					pz[_a] = zz;                                                                                                                               \
+			}                                                                                                                                                  \
+		}                                                                                                                                                      \
+		z += dzdx;                                                                                                                                             \
+		s += dsdx;                                                                                                                                             \
+		t += dtdx;                                                                                                                                             \
+		OR1G1B1INCR                                                                                                                                            \
+	}
+#endif
+#define DRAW_LINE()                                                                                                                                            \
+	{ DRAW_LINE_TRI_TEXTURED() }
+#include "ztriangle.h"
+}
+
+#endif 
diff --git a/src/other/tinygl/src/ztriangle.h b/src/other/tinygl/src/ztriangle.h
new file mode 100644
index 0000000000..fc90dfa0cc
--- /dev/null
+++ b/src/other/tinygl/src/ztriangle.h
@@ -0,0 +1,414 @@
+/*
+ * An eXtReMeLy complicated, delicate, tuned triangle rasterizer
+ * Aight, so basically this is the most complicated code you'll ever read in your life.
+ * The lifetime of variables has been... SUPER Optimized, that's why there's so many random ass curly braces everywhere.
+ * Yes, it is necessary to do that. This code is extremely delicate
+ * and even a minor fuck-up is gonna tank the framerate
+
+Before committing any changes, run gears, model, and texture on your changed code to make sure you didn't
+fuck up!
+
+Things to keep in mind:
+ 1) Tight control of the lifetimes, scopes, and usage of variables lets us use registers more often and memory less
+ 2) Doing the same operation on multiple items is faster than doing different things on different items, generally, because
+   they will be able to take advantage of any/all applicable SIMD/vector ops on your hardware.
+ 3) Divide operations are vastly more expensive than add/sub/bitwise/etc
+ 4) Bit shifting is your friend, it's the fast way to multiply or divide by 2.
+ 5) Fixed point math is used for the depth "z" buffer
+ 6) We're not just using floats for everything because this is still supposed to be fast on platforms without SSE2
+ 7) Fewer variables is usually better
+ */
+
+{
+	GLfloat fdx1, fdx2, fdy1, fdy2;
+	GLushort* pz1;
+	PIXEL* pp1;
+
+	GLint part;
+	GLint dx1, dy1, dx2, dy2;
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+	GLint the_y;
+#endif
+	GLint error, derror;
+	GLint x1, dxdy_min, dxdy_max;
+	/* warning: x2 is multiplied by 2^16 */
+	GLint x2=0, dx2dy2=0;
+
+#ifdef INTERP_Z
+	GLint z1, dzdx, dzdy, dzdl_min, dzdl_max;
+#endif
+#ifdef INTERP_RGB
+	GLint r1, drdx, drdy, drdl_min, drdl_max;
+	GLint g1, dgdx, dgdy, dgdl_min, dgdl_max;
+	GLint b1, dbdx, dbdy, dbdl_min, dbdl_max;
+#endif
+#ifdef INTERP_ST
+	GLint s1, dsdx, dsdy, dsdl_min, dsdl_max;
+	GLint t1, dtdx, dtdy, dtdl_min, dtdl_max;
+#endif
+#ifdef INTERP_STZ
+	GLfloat sz1, dszdx, dszdy, dszdl_min, dszdl_max;
+	GLfloat tz1, dtzdx, dtzdy, dtzdl_min, dtzdl_max;
+	GLfloat fdzdx, fndzdx, ndszdx, ndtzdx;
+#endif
+
+	/* we sort the vertex with increasing y */
+	if (p1->y < p0->y) {
+		ZBufferPoint* t = p0;
+		p0 = p1;
+		p1 = t;
+	}
+	if (p2->y < p0->y) {
+		ZBufferPoint* t = p2;
+		p2 = p1;
+		p1 = p0;
+		p0 = t;
+	} else if (p2->y < p1->y) {
+		ZBufferPoint* t = p1;
+		p1 = p2;
+		p2 = t;
+	}
+
+	/* we compute dXdx and dXdy for all GLinterpolated values */
+	fdx1 = p1->x - p0->x; 
+	fdy1 = p1->y - p0->y; 
+
+	fdx2 = p2->x - p0->x;
+	fdy2 = p2->y - p0->y;
+
+	GLfloat fz = fdx1 * fdy2 - fdx2 * fdy1; 
+	/*
+	if (fz == 0)
+		return;
+	fz = 1.0 / fz; 
+	*/
+	if (fz != 0.0)
+		fz = 1.0 / fz;
+	
+	fdx1 *= fz;
+	fdy1 *= fz;
+	fdx2 *= fz;
+	fdy2 *= fz;
+	
+	{
+		GLfloat d1, d2;
+#ifdef INTERP_Z
+		{
+			d1 = p1->z - p0->z; 
+			d2 = p2->z - p0->z;
+			dzdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			dzdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+#endif
+
+#ifdef INTERP_RGB
+		{
+			d1 = p1->r - p0->r;
+			d2 = p2->r - p0->r;
+			drdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			drdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+		{
+			d1 = p1->g - p0->g;
+			d2 = p2->g - p0->g;
+			dgdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			dgdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+		{
+			d1 = p1->b - p0->b;
+			d2 = p2->b - p0->b;
+			dbdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			dbdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+#endif
+
+#ifdef INTERP_ST
+		{
+			d1 = p1->s - p0->s;
+			d2 = p2->s - p0->s;
+			dsdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			dsdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+		{
+			d1 = p1->t - p0->t;
+			d2 = p2->t - p0->t;
+			dtdx = (GLint)(fdy2 * d1 - fdy1 * d2);
+			dtdy = (GLint)(fdx1 * d2 - fdx2 * d1);
+		}
+#endif
+
+#ifdef INTERP_STZ
+		{
+			GLfloat zedzed;
+			zedzed = (GLfloat)p0->z;
+			p0->sz = (GLfloat)p0->s * zedzed;
+			p0->tz = (GLfloat)p0->t * zedzed;
+			zedzed = (GLfloat)p1->z;
+			p1->sz = (GLfloat)p1->s * zedzed;
+			p1->tz = (GLfloat)p1->t * zedzed;
+			zedzed = (GLfloat)p2->z;
+			p2->sz = (GLfloat)p2->s * zedzed;
+			p2->tz = (GLfloat)p2->t * zedzed;
+		}
+		{
+			d1 = p1->sz - p0->sz;
+			d2 = p2->sz - p0->sz;
+			dszdx = (fdy2 * d1 - fdy1 * d2);
+			dszdy = (fdx1 * d2 - fdx2 * d1);
+		}
+		{
+			d1 = p1->tz - p0->tz;
+			d2 = p2->tz - p0->tz;
+			dtzdx = (fdy2 * d1 - fdy1 * d2);
+			dtzdy = (fdx1 * d2 - fdx2 * d1);
+		}
+#endif
+	} 
+	/* screen coordinates */
+
+	pp1 = (PIXEL*)(zb->pbuf) + zb->xsize * p0->y; 
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+	the_y = p0->y;
+#endif
+	pz1 = zb->zbuf + p0->y * zb->xsize;
+
+	DRAW_INIT();
+	/*
+	 part used here and down.
+	 TODO: #pragma omp parallel for private(a, b, c)
+	 Required reading:
+	 jakascorner.com/blog/2016/06/omp-data-sharing-attributes.html
+	 I'd also like to figure out if the main while() loop over raster lines can be OMP parallelized, but I suspect it isn't worth it.
+	*/
+	ZBufferPoint *pr1, *pr2, *l1, *l2; 
+	for (part = 0; part < 2; part++) {
+		GLint nb_lines;
+		{
+			register GLint update_left, update_right; 
+			if (part == 0) {
+				if (fz > 0) {		 
+					update_left = 1; 
+					update_right = 1;
+					l1 = p0;  
+					l2 = p2;  
+					pr1 = p0; 
+					pr2 = p1; 
+				} else {
+					update_left = 1; 
+					update_right = 1;
+					l1 = p0;
+					l2 = p1;
+					pr1 = p0;
+					pr2 = p2;
+				}
+				nb_lines = p1->y - p0->y;
+			} else {
+				/* second part */
+				if (fz > 0) {
+					update_left = 0;
+					update_right = 1;
+					pr1 = p1;
+					pr2 = p2;
+				} else {
+					update_left = 1;
+					update_right = 0;
+					l1 = p1;
+					l2 = p2;
+				}
+				nb_lines = p2->y - p1->y + 1;
+			}
+			/* compute the values for the left edge */
+			/*pr1 and pr2 are not used inside this area.*/
+			if (update_left) { 
+				{
+					register GLint tmp;
+					dy1 = l2->y - l1->y;
+					dx1 = l2->x - l1->x;
+					if (dy1 > 0)
+						tmp = (dx1 << 16) / dy1;
+					else
+						tmp = 0;
+					x1 = l1->x;
+					error = 0;
+					derror = tmp & 0x0000ffff;
+					dxdy_min = tmp >> 16;
+				}
+				dxdy_max = dxdy_min + 1;
+#ifdef INTERP_Z
+				z1 = l1->z;
+				dzdl_min = (dzdy + dzdx * dxdy_min);
+				dzdl_max = dzdl_min + dzdx;
+#endif
+#ifdef INTERP_RGB
+				r1 = l1->r;
+				drdl_min = (drdy + drdx * dxdy_min);
+				drdl_max = drdl_min + drdx;
+				g1 = l1->g;
+				dgdl_min = (dgdy + dgdx * dxdy_min);
+				dgdl_max = dgdl_min + dgdx;
+				b1 = l1->b;
+				dbdl_min = (dbdy + dbdx * dxdy_min);
+				dbdl_max = dbdl_min + dbdx;
+#endif
+#ifdef INTERP_ST
+				s1 = l1->s;
+				dsdl_min = (dsdy + dsdx * dxdy_min);
+				dsdl_max = dsdl_min + dsdx;
+				t1 = l1->t;
+				dtdl_min = (dtdy + dtdx * dxdy_min);
+				dtdl_max = dtdl_min + dtdx;
+#endif
+#ifdef INTERP_STZ
+				sz1 = l1->sz;
+				dszdl_min = (dszdy + dszdx * dxdy_min);
+				dszdl_max = dszdl_min + dszdx;
+				tz1 = l1->tz;
+				dtzdl_min = (dtzdy + dtzdx * dxdy_min);
+				dtzdl_max = dtzdl_min + dtzdx;
+#endif
+			}
+			/* compute values for the right edge */
+
+			if (update_right) { /*Update right tested*/
+				dx2 = (pr2->x - pr1->x);
+				dy2 = (pr2->y - pr1->y); /*LAST USAGE OF PR2*/
+				if (dy2 > 0)
+					dx2dy2 = (dx2 << 16) / dy2;
+				else
+					dx2dy2 = 0;
+				x2 = pr1->x << 16; /*LAST USAGE OF PR1*/
+			}					   /*EOF update right*/
+		}						   /*End of lifetime for ZBufferpoints*/
+		/* we draw all the scan line of the part */
+
+		while (nb_lines > 0) {
+			nb_lines--;
+#ifndef DRAW_LINE
+			/* generic draw line */
+			{
+				register PIXEL* pp;
+				register GLint n;
+#ifdef INTERP_Z
+				register GLushort* pz;
+				register GLuint z;
+#endif
+#ifdef INTERP_RGB
+				register GLint or1, og1, ob1;
+#endif
+#ifdef INTERP_ST
+				register GLuint s, t;
+#endif
+#ifdef INTERP_STZ
+				
+#endif
+
+				n = (x2 >> 16) - x1;
+				
+				pp = (PIXEL*)pp1 + x1;
+#ifdef INTERP_Z
+				pz = pz1 + x1;
+				z = z1;
+#endif
+#ifdef INTERP_RGB
+				or1 = r1;
+				og1 = g1;
+				ob1 = b1;
+#endif
+#ifdef INTERP_ST
+				s = s1;
+				t = t1;
+#endif
+#ifdef INTERP_STZ
+
+
+#endif
+				while (n >= 3) {
+					PUT_PIXEL(0); /*the_x++;*/
+					PUT_PIXEL(1); /*the_x++;*/
+					PUT_PIXEL(2); /*the_x++;*/
+					PUT_PIXEL(3); /*the_x++;*/
+#ifdef INTERP_Z
+					pz += 4;
+#endif
+					
+					pp += 4;
+					n -= 4;
+				}
+				while (n >= 0) {
+					PUT_PIXEL(0); /*the_x++;*/
+#ifdef INTERP_Z
+					
+					pz++;
+#endif
+					/*pp = (PIXEL*)((GLbyte*)pp + PS_ZB);*/
+					pp++;
+					n--;
+				}
+			}
+#else
+			DRAW_LINE();
+#endif
+
+			/* left edge */
+			error += derror;
+			if (error > 0) {
+				error -= 0x10000;
+				x1 += dxdy_max;
+#ifdef INTERP_Z
+				z1 += dzdl_max;
+#endif
+#ifdef INTERP_RGB
+				r1 += drdl_max;
+				g1 += dgdl_max;
+				b1 += dbdl_max;
+#endif
+#ifdef INTERP_ST
+				s1 += dsdl_max;
+				t1 += dtdl_max;
+#endif
+#ifdef INTERP_STZ
+				sz1 += dszdl_max;
+				tz1 += dtzdl_max;
+#endif
+			} else {
+				x1 += dxdy_min;
+#ifdef INTERP_Z
+				z1 += dzdl_min;
+#endif
+#ifdef INTERP_RGB
+				r1 += drdl_min;
+				g1 += dgdl_min;
+				b1 += dbdl_min;
+#endif
+#ifdef INTERP_ST
+				s1 += dsdl_min;
+				t1 += dtdl_min;
+#endif
+#ifdef INTERP_STZ
+				sz1 += dszdl_min;
+				tz1 += dtzdl_min;
+#endif
+			}
+
+			/* right edge */
+			x2 += dx2dy2;
+
+			/* screen coordinates */
+			
+			pp1 += zb->xsize;
+#if TGL_FEATURE_POLYGON_STIPPLE == 1
+			the_y++;
+#endif
+			pz1 += zb->xsize;
+		}
+	}
+}
+
+#undef INTERP_Z
+#undef INTERP_RGB
+#undef INTERP_ST
+#undef INTERP_STZ
+
+#undef DRAW_INIT
+#undef DRAW_LINE
+#undef PUT_PIXEL
