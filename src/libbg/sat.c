/*                           S A T . C
 * BRL-CAD
 *
 * Based on implementations in GeometircTools:
 *
 * https://github.com/davideberly/GeometricTools
 *
 * David Eberly, Geometric Tools, Redmond WA 98052
 * Copyright (c) 1998-2022
 *
 * Distributed under:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/** @file sat.c
 *
 * Implementations of various Separating Axis Theorem algorithms for detecting
 * collisions between various types of objects (detection only, no calculations
 * to find points or shapes.)
 *
 * OBBTree: A Hierarchical Structure for Rapid Interference Detection
 * http://www.cs.unc.edu/techreports/96-013.pdf
 *
 * Dynamic Collision Detection using Oriented Bounding Boxes
 * https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf
 *
 * The test-intersection implementations use the method of separating axes.
 * https://www.geometrictools.com/Documentation/MethodOfSeparatingAxes.pdf
 *
 * Intersection of Orthogonal View Frustum and Oriented Bounding Box using
 * Separation Axis Testing
 * https://www.geometrictools.com/Documentation/IntersectionBox3Frustum3.pdf
 */

#include "common.h"
#include "vmath.h"
#include "bv/defines.h"
#include "bg/sat.h"

/* Check line against ABB and OBB
 *
 * See GTE/Mathematics/IntrLine3AlignedBox3.h and IntrLine3OrientedBox3.h
 */
static int
line_aabb_query(point_t origin, vect_t ldir, vect_t aabb_extent)
{
    vect_t WxD;
    fastf_t absWdU[3];

    VCROSS(WxD, ldir, origin);
    absWdU[0] = fabs(ldir[0]);
    absWdU[1] = fabs(ldir[1]);
    absWdU[2] = fabs(ldir[2]);

    if (fabs(WxD[0]) > aabb_extent[1] * absWdU[2] + aabb_extent[2] * absWdU[1])
	return 0;

    if (fabs(WxD[1]) > aabb_extent[0] * absWdU[2] + aabb_extent[2] * absWdU[0])
	return 0;

    if (fabs(WxD[2]) > aabb_extent[0] * absWdU[1] + aabb_extent[1] * absWdU[0])
	return 0;

    return 1;
}

int
bg_sat_line_aabb(point_t origin, vect_t ldir, point_t aabb_center, vect_t aabb_extent)
{
    vect_t lineOrigin;
    // Transform the line to the aligned-box coordinate system.
    VSUB2(lineOrigin, origin, aabb_center);
    return line_aabb_query(lineOrigin, ldir, aabb_extent);
}

int
bg_sat_line_obb(point_t origin, vect_t ldir, point_t obb_center, vect_t obb_extent1, vect_t obb_extent2, vect_t obb_extent3)
{
    vect_t diff, lineOrigin, lineDirection, aabb_extent;
    vect_t A[3];
    VSUB2(diff, origin, obb_center);
    VMOVE(A[0], obb_extent1);
    VMOVE(A[1], obb_extent2);
    VMOVE(A[2], obb_extent3);
    VUNITIZE(A[0]);
    VUNITIZE(A[1]);
    VUNITIZE(A[2]);
    VSET(lineOrigin, VDOT(diff, A[0]), VDOT(diff, A[1]), VDOT(diff, A[2]));
    VSET(lineDirection, VDOT(ldir, A[0]), VDOT(ldir, A[1]), VDOT(ldir, A[2]));
    VSET(aabb_extent, MAGNITUDE(obb_extent1), MAGNITUDE(obb_extent2), MAGNITUDE(obb_extent3));
    return line_aabb_query(lineOrigin, lineDirection, aabb_extent);
}

static void
GetProjectionOBB(fastf_t *imin, fastf_t *imax,
	vect_t axis, point_t center, vect_t extent, vect_t A0, vect_t A1, vect_t A2)
{
    fastf_t origin = VDOT(axis, center);
    fastf_t maximumExtent =
	fabs(extent[0] * VDOT(axis, A0)) +
	fabs(extent[1] * VDOT(axis, A1)) +
	fabs(extent[2] * VDOT(axis, A2));

    (*imin) = origin - maximumExtent;
    (*imax) = origin + maximumExtent;
}

static void
GetProjectionTri(fastf_t *imin, fastf_t *imax, vect_t axis, point_t v1, point_t v2, point_t v3)
{
    fastf_t dot[3];
    dot[0] = VDOT(axis, v1);
    dot[1] = VDOT(axis, v2);
    dot[2] = VDOT(axis, v3);

    (*imin) = dot[0];
    (*imax) = (*imin);

    if (dot[1] < (*imin)) {
	(*imin) = dot[1];
    } else if (dot[1] > (*imax)) {
	(*imax) = dot[1];
    }

    if (dot[2] < (*imin)) {
	(*imin) = dot[2];
    } else if (dot[2] > (*imax)) {
	(*imax) = dot[2];
    }
}

/* Check AABB against a triangle.
 *
 * See GTE/Mathematics/IntrTriangle3OrientedBox3.h.h
 */
int
bg_sat_tri_aabb(
	point_t v1, point_t v2, point_t v3,
	point_t center, vect_t extent
	)
{
    vect_t extents[3];
    VSET(extents[0], extent[0], 0, 0);
    VSET(extents[1], 0, extent[1], 0);
    VSET(extents[2], 0, 0, extent[2]);
    return bg_sat_tri_obb(v1, v2, v3, center, extents[0], extents[1], extents[2]);
}

/* Check OBB against a triangle.
 *
 * See GTE/Mathematics/IntrTriangle3OrientedBox3.h.h
 */
int
bg_sat_tri_obb(
	point_t v1, point_t v2, point_t v3,
	point_t obb_center, vect_t obb_extent1, vect_t obb_extent2, vect_t obb_extent3
	)
{
    fastf_t min0 = 0.0, max0 = 0.0, min1 = 0.0, max1 = 0.0;
    vect_t D, edge[3];
    vect_t extent, A[3];
    VSET(extent, MAGNITUDE(obb_extent1), MAGNITUDE(obb_extent2), MAGNITUDE(obb_extent3));
    VMOVE(A[0], obb_extent1);
    VUNITIZE(A[0]);
    VMOVE(A[1], obb_extent2);
    VUNITIZE(A[1]);
    VMOVE(A[2], obb_extent3);
    VUNITIZE(A[2]);

    // Test direction of triangle normal.
    VSUB2(edge[0], v2, v1);
    VSUB2(edge[1], v3, v1);
    VCROSS(D, edge[0], edge[1]);
    min0 = VDOT(D, v1);
    max0 = min0;

    GetProjectionOBB(&min1, &max1, D, obb_center, extent, A[0], A[1], A[2]);
    if (max1 < min0 || max0 < min1)
	return 0;

    // Test direction of box faces.
    for (int32_t i = 0; i < 3; ++i) {
	VMOVE(D, A[i]);
	GetProjectionTri(&min0, &max0, D, v1, v2, v3);
	fastf_t DdC = VDOT(D, obb_center);
	min1 = DdC - extent[i];
	max1 = DdC + extent[i];
	if (max1 < min0 || max0 < min1)
	    return 0;
    }

    // Test direction of triangle-box edge cross products.
    VSUB2(edge[2], edge[1], edge[0]);
    for (int32_t i0 = 0; i0 < 3; ++i0) {
	for (int32_t i1 = 0; i1 < 3; ++i1) {
	    VCROSS(D, edge[i0], A[i1]);
	    GetProjectionTri(&min0, &max0, D, v1, v2, v3);
	    GetProjectionOBB(&min1, &max1, D, obb_center, extent, A[0], A[1], A[2]);
	    if (max1 < min0 || max0 < min1)
		return 0;
	}
    }

    return 1;
}

/* Check AABB against an OBB.
 *
 * See GTE/Mathematics/IntrAlignedBox3OrientedBox3.h
 */
int
bg_sat_aabb_obb(
	point_t aabb_min, point_t aabb_max,
	point_t obb_center, vect_t obb_extent1, vect_t obb_extent2, vect_t obb_extent3
	)
{
    // Get the center/extent form of the aligned box. The axes are
    // implicitly A0[0] = (1,0,0), A0[1] = (0,1,0) and
    // A0[2] = (0,0,1).
    vect_t C0, E0;
    VADD2SCALE(C0, aabb_max, aabb_min, 0.5);
    VSUB2SCALE(E0, aabb_max, aabb_min, 0.5);

    // Convenience variables.
    vect_t C1, E1;
    VMOVE(C1, obb_center);
    VSET(E1, MAGNITUDE(obb_extent1), MAGNITUDE(obb_extent2), MAGNITUDE(obb_extent3));
    vect_t A1[3];
    VMOVE(A1[0], obb_extent1);
    VUNITIZE(A1[0]);
    VMOVE(A1[1], obb_extent2);
    VUNITIZE(A1[1]);
    VMOVE(A1[2], obb_extent3);
    VUNITIZE(A1[2]);

    fastf_t epsilon = VUNITIZE_TOL;
    fastf_t cutoff = 1.0 - epsilon;
    int existsParallelPair = 0;

    // Compute the difference of box centers.
    vect_t D;
    VSUB2(D, C1, C0);

    // dot01[i][j] = VDOT(A0[i],A1[j]) = A1[j][i]
    fastf_t dot01[3][3];

    // |dot01[i][j]|
    fastf_t absDot01[3][3];

    // interval radii and distance between centers
    fastf_t r0, r1, r;

    // r0 + r1
    fastf_t r01;

    // Test for separation on the axis C0 + t*A0[0].
    for (int i = 0; i < 3; ++i) {
	dot01[0][i] = A1[i][0];
	absDot01[0][i] = fabs(A1[i][0]);
	if (absDot01[0][i] >= cutoff)
	    existsParallelPair = 1;
    }
    r = fabs(D[0]);
    r1 = E1[0] * absDot01[0][0] + E1[1] * absDot01[0][1] + E1[2] * absDot01[0][2];
    r01 = E0[0] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1].
    for (int i = 0; i < 3; ++i) {
	dot01[1][i] = A1[i][1];
	absDot01[1][i] = fabs(A1[i][1]);
	if (absDot01[1][i] >= cutoff)
	    existsParallelPair = 1;
    }
    r = fabs(D[1]);
    r1 = E1[0] * absDot01[1][0] + E1[1] * absDot01[1][1] + E1[2] * absDot01[1][2];
    r01 = E0[1] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2].
    for (int i = 0; i < 3; ++i) {
	dot01[2][i] = A1[i][2];
	absDot01[2][i] = fabs(A1[i][2]);
	if (absDot01[2][i] >= cutoff)
	    existsParallelPair = 1;
    }
    r = fabs(D[2]);
    r1 = E1[0] * absDot01[2][0] + E1[1] * absDot01[2][1] + E1[2] * absDot01[2][2];
    r01 = E0[2] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[0].
    r = fabs(VDOT(D, A1[0]));
    r0 = E0[0] * absDot01[0][0] + E0[1] * absDot01[1][0] + E0[2] * absDot01[2][0];
    r01 = r0 + E1[0];
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[1].
    r = fabs(VDOT(D, A1[1]));
    r0 = E0[0] * absDot01[0][1] + E0[1] * absDot01[1][1] + E0[2] * absDot01[2][1];
    r01 = r0 + E1[1];
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[2].
    r = fabs(VDOT(D, A1[2]));
    r0 = E0[0] * absDot01[0][2] + E0[1] * absDot01[1][2] + E0[2] * absDot01[2][2];
    r01 = r0 + E1[2];
    if (r > r01)
	return 0;

    // At least one pair of box axes was parallel, so the separation is
    // effectively in 2D. The edge-edge axes do not need to be tested.
    if (existsParallelPair) {
	// The result.separating[] values are invalid because there is
	// no separation.
	return 1;
    }

    // Test for separation on the axis C0 + t*A0[0]xA1[0].
    r = fabs(D[2] * dot01[1][0] - D[1] * dot01[2][0]);
    r0 = E0[1] * absDot01[2][0] + E0[2] * absDot01[1][0];
    r1 = E1[1] * absDot01[0][2] + E1[2] * absDot01[0][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[0]xA1[1].
    r = fabs(D[2] * dot01[1][1] - D[1] * dot01[2][1]);
    r0 = E0[1] * absDot01[2][1] + E0[2] * absDot01[1][1];
    r1 = E1[0] * absDot01[0][2] + E1[2] * absDot01[0][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[0]xA1[2].
    r = fabs(D[2] * dot01[1][2] - D[1] * dot01[2][2]);
    r0 = E0[1] * absDot01[2][2] + E0[2] * absDot01[1][2];
    r1 = E1[0] * absDot01[0][1] + E1[1] * absDot01[0][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[0].
    r = fabs(D[0] * dot01[2][0] - D[2] * dot01[0][0]);
    r0 = E0[0] * absDot01[2][0] + E0[2] * absDot01[0][0];
    r1 = E1[1] * absDot01[1][2] + E1[2] * absDot01[1][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[1].
    r = fabs(D[0] * dot01[2][1] - D[2] * dot01[0][1]);
    r0 = E0[0] * absDot01[2][1] + E0[2] * absDot01[0][1];
    r1 = E1[0] * absDot01[1][2] + E1[2] * absDot01[1][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[2].
    r = fabs(D[0] * dot01[2][2] - D[2] * dot01[0][2]);
    r0 = E0[0] * absDot01[2][2] + E0[2] * absDot01[0][2];
    r1 = E1[0] * absDot01[1][1] + E1[1] * absDot01[1][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[0].
    r = fabs(D[1] * dot01[0][0] - D[0] * dot01[1][0]);
    r0 = E0[0] * absDot01[1][0] + E0[1] * absDot01[0][0];
    r1 = E1[1] * absDot01[2][2] + E1[2] * absDot01[2][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[1].
    r = fabs(D[1] * dot01[0][1] - D[0] * dot01[1][1]);
    r0 = E0[0] * absDot01[1][1] + E0[1] * absDot01[0][1];
    r1 = E1[0] * absDot01[2][2] + E1[2] * absDot01[2][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[2].
    r = fabs(D[1] * dot01[0][2] - D[0] * dot01[1][2]);
    r0 = E0[0] * absDot01[1][2] + E0[1] * absDot01[0][2];
    r1 = E1[0] * absDot01[2][1] + E1[1] * absDot01[2][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // The result.separating[] values are invalid because there is no
    // separation.
    return 1;
}

/* Check OBB against another OBB.
 *
 * See GTE/Mathematics/IntrOrientedBox3OrientedBox3.h
 */
int
bg_sat_obb_obb(
	point_t obb1_center, vect_t obb1_extent1, vect_t obb1_extent2, vect_t obb1_extent3,
	point_t obb2_center, vect_t obb2_extent1, vect_t obb2_extent2, vect_t obb2_extent3
	)
{
    // Convenience variables.
    vect_t C0, E0, C1, E1;
    VMOVE(C0, obb1_center);
    VSET(E0, MAGNITUDE(obb1_extent1), MAGNITUDE(obb1_extent2), MAGNITUDE(obb1_extent3));
    VMOVE(C1, obb2_center);
    VSET(E1, MAGNITUDE(obb2_extent1), MAGNITUDE(obb2_extent2), MAGNITUDE(obb2_extent3));

    vect_t A0[3];
    VMOVE(A0[0], obb1_extent1);
    VUNITIZE(A0[0]);
    VMOVE(A0[1], obb1_extent2);
    VUNITIZE(A0[1]);
    VMOVE(A0[2], obb1_extent3);
    VUNITIZE(A0[2]);

    vect_t A1[3];
    VMOVE(A1[0], obb2_extent1);
    VUNITIZE(A1[0]);
    VMOVE(A1[1], obb2_extent2);
    VUNITIZE(A1[1]);
    VMOVE(A1[2], obb2_extent3);
    VUNITIZE(A1[2]);

    fastf_t epsilon = VUNITIZE_TOL;
    fastf_t cutoff = 1.0 - epsilon;
    int existsParallelPair = 0;

    // Compute difference of box centers.
    vect_t D;
    VSUB2(D, C1, C0);

    // dot01[i][j] = Dot(A0[i],A1[j]) = A1[j][i]
    fastf_t dot01[3][3];

    // |dot01[i][j]|
    fastf_t absDot01[3][3];

    // Dot(D, A0[i])
    fastf_t dotDA0[3];

    // interval radii and distance between centers
    fastf_t r0, r1, r;

    // r0 + r1
    fastf_t r01;

    // Test for separation on the axis C0 + t*A0[0].
    for (int i = 0; i < 3; ++i) {
	dot01[0][i] = VDOT(A0[0], A1[i]);
	absDot01[0][i] = fabs(dot01[0][i]);
	if (absDot01[0][i] > cutoff)
	    existsParallelPair = 1;
    }
    dotDA0[0] = VDOT(D, A0[0]);
    r = fabs(dotDA0[0]);
    r1 = E1[0] * absDot01[0][0] + E1[1] * absDot01[0][1] + E1[2] * absDot01[0][2];
    r01 = E0[0] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1].
    for (int i = 0; i < 3; ++i) {
	dot01[1][i] = VDOT(A0[1], A1[i]);
	absDot01[1][i] = fabs(dot01[1][i]);
	if (absDot01[1][i] > cutoff)
	    existsParallelPair = 1;
    }
    dotDA0[1] = VDOT(D, A0[1]);
    r = fabs(dotDA0[1]);
    r1 = E1[0] * absDot01[1][0] + E1[1] * absDot01[1][1] + E1[2] * absDot01[1][2];
    r01 = E0[1] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2].
    for (int i = 0; i < 3; ++i) {
	dot01[2][i] = VDOT(A0[2], A1[i]);
	absDot01[2][i] = fabs(dot01[2][i]);
	if (absDot01[2][i] > cutoff)
	    existsParallelPair = 1;
    }
    dotDA0[2] = VDOT(D, A0[2]);
    r = fabs(dotDA0[2]);
    r1 = E1[0] * absDot01[2][0] + E1[1] * absDot01[2][1] + E1[2] * absDot01[2][2];
    r01 = E0[2] + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[0].
    r = fabs(VDOT(D, A1[0]));
    r0 = E0[0] * absDot01[0][0] + E0[1] * absDot01[1][0] + E0[2] * absDot01[2][0];
    r01 = r0 + E1[0];
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[1].
    r = fabs(VDOT(D, A1[1]));
    r0 = E0[0] * absDot01[0][1] + E0[1] * absDot01[1][1] + E0[2] * absDot01[2][1];
    r01 = r0 + E1[1];
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A1[2].
    r = fabs(VDOT(D, A1[2]));
    r0 = E0[0] * absDot01[0][2] + E0[1] * absDot01[1][2] + E0[2] * absDot01[2][2];
    r01 = r0 + E1[2];
    if (r > r01)
	return 0;

    // At least one pair of box axes was parallel, so the separation is
    // effectively in 2D. The edge-edge axes do not need to be tested.
    if (existsParallelPair)
	return 1;

    // Test for separation on the axis C0 + t*A0[0]xA1[0].
    r = fabs(dotDA0[2] * dot01[1][0] - dotDA0[1] * dot01[2][0]);
    r0 = E0[1] * absDot01[2][0] + E0[2] * absDot01[1][0];
    r1 = E1[1] * absDot01[0][2] + E1[2] * absDot01[0][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[0]xA1[1].
    r = fabs(dotDA0[2] * dot01[1][1] - dotDA0[1] * dot01[2][1]);
    r0 = E0[1] * absDot01[2][1] + E0[2] * absDot01[1][1];
    r1 = E1[0] * absDot01[0][2] + E1[2] * absDot01[0][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[0]xA1[2].
    r = fabs(dotDA0[2] * dot01[1][2] - dotDA0[1] * dot01[2][2]);
    r0 = E0[1] * absDot01[2][2] + E0[2] * absDot01[1][2];
    r1 = E1[0] * absDot01[0][1] + E1[1] * absDot01[0][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[0].
    r = fabs(dotDA0[0] * dot01[2][0] - dotDA0[2] * dot01[0][0]);
    r0 = E0[0] * absDot01[2][0] + E0[2] * absDot01[0][0];
    r1 = E1[1] * absDot01[1][2] + E1[2] * absDot01[1][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[1].
    r = fabs(dotDA0[0] * dot01[2][1] - dotDA0[2] * dot01[0][1]);
    r0 = E0[0] * absDot01[2][1] + E0[2] * absDot01[0][1];
    r1 = E1[0] * absDot01[1][2] + E1[2] * absDot01[1][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[1]xA1[2].
    r = fabs(dotDA0[0] * dot01[2][2] - dotDA0[2] * dot01[0][2]);
    r0 = E0[0] * absDot01[2][2] + E0[2] * absDot01[0][2];
    r1 = E1[0] * absDot01[1][1] + E1[1] * absDot01[1][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[0].
    r = fabs(dotDA0[1] * dot01[0][0] - dotDA0[0] * dot01[1][0]);
    r0 = E0[0] * absDot01[1][0] + E0[1] * absDot01[0][0];
    r1 = E1[1] * absDot01[2][2] + E1[2] * absDot01[2][1];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[1].
    r = fabs(dotDA0[1] * dot01[0][1] - dotDA0[0] * dot01[1][1]);
    r0 = E0[0] * absDot01[1][1] + E0[1] * absDot01[0][1];
    r1 = E1[0] * absDot01[2][2] + E1[2] * absDot01[2][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // Test for separation on the axis C0 + t*A0[2]xA1[2].
    r = fabs(dotDA0[1] * dot01[0][2] - dotDA0[0] * dot01[1][2]);
    r0 = E0[0] * absDot01[1][2] + E0[1] * absDot01[0][2];
    r1 = E1[0] * absDot01[2][1] + E1[1] * absDot01[2][0];
    r01 = r0 + r1;
    if (r > r01)
	return 0;

    // There is no separation.
    return 1;
}

/* Check AABB against view frustum.
 *
 * See GTE/Mathematics/IntrOrientedBox3Frustum3.h
 */
int
bg_sat_frustum_aabb(
	struct bv_frustum *v,
	point_t aabb_min, point_t aabb_max
	)
{
    point_t E;
    point_t aabb_center;
    vect_t aabb_extent1, aabb_extent2, aabb_extent3;
    VADD2SCALE(aabb_center, aabb_max, aabb_min, 0.5);
    VSUB2SCALE(E, aabb_max, aabb_min, 0.5);
    VSET(aabb_extent1, 1, 0, 0);
    VSET(aabb_extent2, 0, 1, 0);
    VSET(aabb_extent3, 0, 0, 1);
    VSCALE(aabb_extent1, aabb_extent1, E[0]);
    VSCALE(aabb_extent2, aabb_extent2, E[1]);
    VSCALE(aabb_extent3, aabb_extent3, E[2]);

    return bg_sat_frustum_obb(v, aabb_center, aabb_extent1, aabb_extent2, aabb_extent3);
}

/* Check OBB against view frustum.
 *
 * See GTE/Mathematics/IntrOrientedBox3Frustum3.h
 */
int
bg_sat_frustum_obb(
	struct bv_frustum *vf,
	point_t obb_center, vect_t obb_extent1, vect_t obb_extent2, vect_t obb_extent3
	)
{
    // Convenience variables.
    vect_t axis[3];
    vect_t extent;
    VMOVE(axis[0], obb_extent1);
    VMOVE(axis[1], obb_extent2);
    VMOVE(axis[2], obb_extent3);
    VUNITIZE(axis[0]);
    VUNITIZE(axis[1]);
    VUNITIZE(axis[2]);
    VSET(extent, MAGNITUDE(obb_extent1), MAGNITUDE(obb_extent2), MAGNITUDE(obb_extent3));

    vect_t diff;
    VSUB2(diff, obb_center, vf->origin);  // C-E

    fastf_t f_DRatio = vf->far_plane/vf->near_plane;

    fastf_t A[3];      // Dot(R,A[i])
    fastf_t B[3];      // Dot(U,A[i])
    fastf_t C[3];      // Dot(D,A[i])
    fastf_t D[3];      // (Dot(R,C-E),Dot(U,C-E),Dot(D,C-E))
    fastf_t NA[3];     // dmin*Dot(R,A[i])
    fastf_t NB[3];     // dmin*Dot(U,A[i])
    fastf_t NC[3];     // dmin*Dot(D,A[i])
    fastf_t ND[3];     // dmin*(Dot(R,C-E),Dot(U,C-E),?)
    fastf_t RC[3];     // rmax*Dot(D,A[i])
    fastf_t RD[3];     // rmax*(?,?,Dot(D,C-E))
    fastf_t UC[3];     // umax*Dot(D,A[i])
    fastf_t UD[3];     // umax*(?,?,Dot(D,C-E))
    fastf_t NApRC[3];  // dmin*Dot(R,A[i]) + rmax*Dot(D,A[i])
    fastf_t NAmRC[3];  // dmin*Dot(R,A[i]) - rmax*Dot(D,A[i])
    fastf_t NBpUC[3];  // dmin*Dot(U,A[i]) + umax*Dot(D,A[i])
    fastf_t NBmUC[3];  // dmin*Dot(U,A[i]) - umax*Dot(D,A[i])
    fastf_t RBpUA[3];  // rmax*Dot(U,A[i]) + umax*Dot(R,A[i])
    fastf_t RBmUA[3];  // rmax*Dot(U,A[i]) - umax*Dot(R,A[i])
    fastf_t DdD, radius, p, fmin, fmax, MTwoUF, MTwoRF, tmp;

    // M = D
    D[2] = VDOT(diff, vf->dir);
    for (int32_t i = 0; i < 3; ++i) {
	C[i] = VDOT(axis[i], vf->dir);
    }
    radius = extent[0] * fabs(C[0]) + extent[1] * fabs(C[1]) + extent[2] * fabs(C[2]);
    if (D[2] + radius < vf->near_plane || D[2] - radius > vf->far_plane)
	return 0;

    // M = n*R - r*D
    for (int32_t i = 0; i < 3; ++i) {
	A[i] = VDOT(axis[i], vf->right);
	RC[i] = vf->r_extent * C[i];
	NA[i] = vf->near_plane * A[i];
	NAmRC[i] = NA[i] - RC[i];
    }
    D[0] = VDOT(diff, vf->right);
    radius = extent[0] * fabs(NAmRC[0]) + extent[1] * fabs(NAmRC[1]) + extent[2] * fabs(NAmRC[2]);
    ND[0] = vf->near_plane * D[0];
    RD[2] = vf->r_extent * D[2];
    DdD = ND[0] - RD[2];
    MTwoRF = -2*vf->r_extent*vf->far_plane;
    if (DdD + radius < MTwoRF || DdD > radius)
	return 0;

    // M = -n*R - r*D
    for (int32_t i = 0; i < 3; ++i) {
	NApRC[i] = NA[i] + RC[i];
    }
    radius = extent[0] * fabs(NApRC[0]) + extent[1] * fabs(NApRC[1]) + extent[2] * fabs(NApRC[2]);
    DdD = -(ND[0] + RD[2]);
    if (DdD + radius < MTwoRF || DdD > radius)
	return 0;

    // M = n*U - u*D
    for (int32_t i = 0; i < 3; ++i) {
	B[i] = VDOT(axis[i], vf->up);
	UC[i] = vf->u_extent * C[i];
	NB[i] = vf->near_plane * B[i];
	NBmUC[i] = NB[i] - UC[i];
    }
    D[1] = VDOT(diff, vf->up);
    radius = extent[0] * fabs(NBmUC[0]) + extent[1] * fabs(NBmUC[1]) + extent[2] * fabs(NBmUC[2]);
    ND[1] = vf->near_plane * D[1];
    UD[2] = vf->u_extent * D[2];
    DdD = ND[1] - UD[2];
    MTwoUF = -2*vf->u_extent*vf->far_plane;
    if (DdD + radius < MTwoUF || DdD > radius)
	return 0;

    // M = -n*U - u*D
    for (int32_t i = 0; i < 3; ++i) {
	NBpUC[i] = NB[i] + UC[i];
    }
    radius =
	extent[0] * fabs(NBpUC[0]) +
	extent[1] * fabs(NBpUC[1]) +
	extent[2] * fabs(NBpUC[2]);
    DdD = -(ND[1] + UD[2]);
    if (DdD + radius < MTwoUF || DdD > radius)
	return 0;

    // M = A[i]
    for (int32_t i = 0; i < 3; ++i) {
	p = vf->r_extent * fabs(A[i]) + vf->u_extent * fabs(B[i]);
	NC[i] = vf->near_plane * C[i];
	fmin = NC[i] - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = NC[i] + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = A[i] * D[0] + B[i] * D[1] + C[i] * D[2];
	if (DdD + extent[i] < fmin || DdD - extent[i] > fmax)
	    return 0;
    }

    // M = Cross(R,A[i])
    for (int32_t i = 0; i < 3; ++i) {
	p = vf->u_extent * fabs(C[i]);
	fmin = -NB[i] - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = -NB[i] + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = C[i] * D[1] - B[i] * D[2];
	radius =
	    extent[0] * fabs(B[i] * C[0] - B[0] * C[i]) +
	    extent[1] * fabs(B[i] * C[1] - B[1] * C[i]) +
	    extent[2] * fabs(B[i] * C[2] - B[2] * C[i]);
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    // M = Cross(U,A[i])
    for (int32_t i = 0; i < 3; ++i) {
	p = vf->r_extent * fabs(C[i]);
	fmin = NA[i] - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = NA[i] + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = -C[i] * D[0] + A[i] * D[2];
	radius =
	    extent[0] * fabs(A[i] * C[0] - A[0] * C[i]) +
	    extent[1] * fabs(A[i] * C[1] - A[1] * C[i]) +
	    extent[2] * fabs(A[i] * C[2] - A[2] * C[i]);
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    // M = Cross(n*D+r*R+u*U,A[i])
    for (int32_t i = 0; i < 3; ++i) {
	fastf_t fRB = vf->r_extent * B[i];
	fastf_t fUA = vf->u_extent * A[i];
	RBpUA[i] = fRB + fUA;
	RBmUA[i] = fRB - fUA;
    }
    for (int32_t i = 0; i < 3; ++i)
    {
	p = vf->r_extent * fabs(NBmUC[i]) +
	    vf->u_extent * fabs(NAmRC[i]);
	tmp = -vf->near_plane * RBmUA[i];
	fmin = tmp - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = tmp + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = D[0] * NBmUC[i] - D[1] * NAmRC[i] - D[2] * RBmUA[i];
	radius = 0;
	for (int32_t j = 0; j < 3; j++) {
	    radius += extent[j] * fabs(A[j] * NBmUC[i] -
		    B[j] * NAmRC[i] - C[j] * RBmUA[i]);
	}
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    // M = Cross(n*D+r*R-u*U,A[i])
    for (int32_t i = 0; i < 3; ++i)
    {
	p = vf->r_extent * fabs(NBpUC[i]) +
	    vf->u_extent * fabs(NAmRC[i]);
	tmp = -vf->near_plane * RBpUA[i];
	fmin = tmp - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = tmp + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = D[0] * NBpUC[i] - D[1] * NAmRC[i] - D[2] * RBpUA[i];
	radius = 0;
	for (int32_t j = 0; j < 3; ++j) {
	    radius += extent[j] * fabs(A[j] * NBpUC[i] -
		    B[j] * NAmRC[i] - C[j] * RBpUA[i]);
	}
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    // M = Cross(n*D-r*R+u*U,A[i])
    for (int32_t i = 0; i < 3; ++i)
    {
	p = vf->r_extent * fabs(NBmUC[i]) +
	    vf->u_extent * fabs(NApRC[i]);
	tmp = vf->near_plane * RBpUA[i];
	fmin = tmp - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = tmp + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = D[0] * NBmUC[i] - D[1] * NApRC[i] + D[2] * RBpUA[i];
	radius = 0;
	for (int32_t j = 0; j < 3; ++j) {
	    radius += extent[j] * fabs(A[j] * NBmUC[i] -
		    B[j] * NApRC[i] + C[j] * RBpUA[i]);
	}
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    // M = Cross(n*D-r*R-u*U,A[i])
    for (int32_t i = 0; i < 3; ++i)
    {
	p = vf->r_extent * fabs(NBpUC[i]) +
	    vf->u_extent * fabs(NApRC[i]);
	tmp = vf->near_plane * RBmUA[i];
	fmin = tmp - p;
	if (fmin < 0)
	    fmin *= f_DRatio;
	fmax = tmp + p;
	if (fmax > 0)
	    fmax *= f_DRatio;
	DdD = D[0] * NBpUC[i] - D[1] * NApRC[i] + D[2] * RBmUA[i];
	radius = 0;
	for (int32_t j = 0; j < 3; ++j) {
	    radius += extent[j] * fabs(A[j] * NBpUC[i] -
		    B[j] * NApRC[i] + C[j] * RBmUA[i]);
	}
	if (DdD + radius < fmin || DdD - radius > fmax)
	    return 0;
    }

    return 1;
}

/*
 * Local Variables:
 * tab-width: 8
 * mode: C
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
